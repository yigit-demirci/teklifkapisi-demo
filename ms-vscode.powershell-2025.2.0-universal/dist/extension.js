"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@microsoft/1ds-core-js/dist/es5/ms.core.js
var require_ms_core = __commonJS({
  "node_modules/@microsoft/1ds-core-js/dist/es5/ms.core.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.oneDS = global2.oneDS || {}));
    })(exports2, function(exports3) {
      "use strict";
      var strShimFunction = "function";
      var strShimObject = "object";
      var strShimUndefined = "undefined";
      var strShimPrototype = "prototype";
      var ObjClass$1 = Object;
      var ObjProto$1 = ObjClass$1[strShimPrototype];
      // @__NO_SIDE_EFFECTS__
      function _pureAssign(func1, func2) {
        return func1 || func2;
      }
      // @__NO_SIDE_EFFECTS__
      function _pureRef(value, name) {
        return value[name];
      }
      var UNDEF_VALUE = void 0;
      var NULL_VALUE = null;
      var EMPTY = "";
      var FUNCTION = "function";
      var OBJECT = "object";
      var PROTOTYPE = "prototype";
      var __PROTO__ = "__proto__";
      var UNDEFINED = "undefined";
      var CONSTRUCTOR = "constructor";
      var SYMBOL = "Symbol";
      var LENGTH = "length";
      var NAME = "name";
      var CALL = "call";
      var TO_STRING = "toString";
      var GET_OWN_PROPERTY_DESCRIPTOR = "getOwnPropertyDescriptor";
      var ObjClass = /* @__PURE__ */ _pureAssign(Object);
      var ObjProto = /* @__PURE__ */ _pureRef(ObjClass, PROTOTYPE);
      var StrCls = /* @__PURE__ */ _pureAssign(String);
      var StrProto = /* @__PURE__ */ _pureRef(StrCls, PROTOTYPE);
      var MathCls = /* @__PURE__ */ _pureAssign(Math);
      var ArrCls = /* @__PURE__ */ _pureAssign(Array);
      var ArrProto = /* @__PURE__ */ _pureRef(ArrCls, PROTOTYPE);
      var ArrSlice = /* @__PURE__ */ _pureRef(ArrProto, "slice");
      var POLYFILL_TAG = "_polyfill";
      var POLYFILL_TYPE_NAME = "__nw21$polytype__";
      function safe(func, argArray) {
        try {
          return {
            v: func.apply(this, argArray)
          };
        } catch (e) {
          return { e };
        }
      }
      // @__NO_SIDE_EFFECTS__
      function safeGet(cb, defValue, argArray) {
        var result = safe(cb, argArray);
        return result.e ? defValue : result.v;
      }
      var _primitiveTypes;
      // @__NO_SIDE_EFFECTS__
      function _createIs(theType) {
        return function(value) {
          return typeof value === theType;
        };
      }
      // @__NO_SIDE_EFFECTS__
      function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function(value) {
          return !!(value && /* @__PURE__ */ objToString(value) === theType);
        };
      }
      // @__NO_SIDE_EFFECTS__
      function objToString(value) {
        return ObjProto[TO_STRING].call(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isTypeof(value, theType) {
        return typeof value === theType;
      }
      // @__NO_SIDE_EFFECTS__
      function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictUndefined(arg) {
        return arg === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isNullOrUndefined(value) {
        return value === NULL_VALUE || /* @__PURE__ */ isUndefined(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || value === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isPrimitiveType(theType) {
        !_primitiveTypes && (_primitiveTypes = ["string", "number", "boolean", UNDEFINED, "symbol", "bigint"]);
        return !!(theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1);
      }
      var isString = /* @__PURE__ */ _createIs("string");
      var isFunction = /* @__PURE__ */ _createIs(FUNCTION);
      // @__NO_SIDE_EFFECTS__
      function isObject(value) {
        if (!value && /* @__PURE__ */ isNullOrUndefined(value)) {
          return false;
        }
        return !!value && typeof value === OBJECT;
      }
      var isArray = /* @__PURE__ */ _pureRef(ArrCls, "isArray");
      var isDate = /* @__PURE__ */ _createObjIs("Date");
      var isNumber = /* @__PURE__ */ _createIs("number");
      var isBoolean = /* @__PURE__ */ _createIs("boolean");
      var isError = /* @__PURE__ */ _createObjIs("Error");
      // @__NO_SIDE_EFFECTS__
      function isPromiseLike(value) {
        return !!(value && value.then && isFunction(value.then));
      }
      // @__NO_SIDE_EFFECTS__
      function isNotTruthy(value) {
        return !value || !/* @__PURE__ */ isTruthy(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isTruthy(value) {
        return !(!value || /* @__PURE__ */ safeGet(function() {
          return !(value && 0 + value);
        }, !value));
      }
      function _returnNothing() {
        return;
      }
      function _returnFalse() {
        return false;
      }
      var asString = /* @__PURE__ */ _pureAssign(StrCls);
      var ERROR_TYPE = "[object Error]";
      // @__NO_SIDE_EFFECTS__
      function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
          object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
          propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format === "number" ? format : 4 : UNDEF_VALUE);
          propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
        } catch (e) {
          propertyValueDump = " - " + /* @__PURE__ */ dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
      }
      function throwError(message) {
        throw new Error(message);
      }
      function throwTypeError(message) {
        throw new TypeError(message);
      }
      function _throwIfNullOrUndefined(obj) {
        if (/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          throwTypeError("Cannot convert undefined or null to object");
        }
      }
      function _throwIfNotString(value) {
        if (!isString(value)) {
          throwTypeError("'" + /* @__PURE__ */ dumpObj(value) + "' is not a string");
        }
      }
      // @__NO_SIDE_EFFECTS__
      function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
      }
      var _objGetOwnPropertyDescriptor$2 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var objHasOwn = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "hasOwn"), polyObjHasOwn);
      // @__NO_SIDE_EFFECTS__
      function polyObjHasOwn(obj, prop) {
        _throwIfNullOrUndefined(obj);
        return /* @__PURE__ */ objHasOwnProperty(obj, prop) || !!_objGetOwnPropertyDescriptor$2(obj, prop);
      }
      function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && (/* @__PURE__ */ isObject(theObject) || isFunction(theObject))) {
          for (var prop in theObject) {
            if (objHasOwn(theObject, prop)) {
              if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                break;
              }
            }
          }
        }
      }
      function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
          var len = theArray[LENGTH] >>> 0;
          for (var idx = 0; idx < len; idx++) {
            if (idx in theArray) {
              if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                break;
              }
            }
          }
        }
      }
      var _unwrapFunction = _unwrapFunctionWithPoly;
      // @__NO_SIDE_EFFECTS__
      function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
        return function(thisArg) {
          var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
          if (theFunc || polyFunc) {
            var theArgs = arguments;
            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
          }
          throwTypeError('"' + asString(funcName) + '" not defined for ' + /* @__PURE__ */ dumpObj(thisArg));
        };
      }
      // @__NO_SIDE_EFFECTS__
      function _unwrapProp(propName) {
        return function(thisArg) {
          return thisArg[propName];
        };
      }
      var _objGetOwnPropertyDescriptor$1 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
      };
      // @__NO_SIDE_EFFECTS__
      function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
          prop.get = function() {
            return value.l.v;
          };
          var desc = _objGetOwnPropertyDescriptor$1(value.l, "v");
          if (desc && desc.set) {
            prop.set = function(newValue) {
              value.l.v = newValue;
            };
          }
        }
        objForEachKey(value, function(key, value2) {
          prop[propMap[key]] = /* @__PURE__ */ isStrictUndefined(value2) ? prop[propMap[key]] : value2;
        });
        return prop;
      }
      var objDefineProp = /* @__PURE__ */ _pureRef(ObjClass, "defineProperty");
      var objDefineProperties = /* @__PURE__ */ _pureRef(ObjClass, "defineProperties");
      function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {
        var desc = {
          e: enumerable,
          c: configurable
        };
        if (getProp) {
          desc.g = getProp;
        }
        if (setProp) {
          desc.s = setProp;
        }
        return objDefineProp(target, prop, /* @__PURE__ */ _createProp(desc));
      }
      function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, /* @__PURE__ */ _createProp(propDesc));
      }
      // @__NO_SIDE_EFFECTS__
      function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
        var theMap = {};
        objForEachKey(values, function(key, value) {
          _assignMapValue(theMap, key, keyType ? value : key);
          _assignMapValue(theMap, value, valueType ? value : key);
        });
        return completeFn ? completeFn(theMap) : theMap;
      }
      function _assignMapValue(theMap, key, value, writable) {
        objDefineProp(theMap, key, {
          value,
          enumerable: true,
          writable: false
        });
      }
      var objIsFrozen = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "isFrozen"), _returnFalse);
      var _objFreeze = /* @__PURE__ */ _pureRef(ObjClass, "freeze");
      function _doNothing(value) {
        return value;
      }
      // @__NO_SIDE_EFFECTS__
      function _getProto(value) {
        _throwIfNullOrUndefined(value);
        return value[__PROTO__] || NULL_VALUE;
      }
      var objAssign = /* @__PURE__ */ _pureRef(ObjClass, "assign");
      var objKeys = /* @__PURE__ */ _pureRef(ObjClass, "keys");
      function _deepFreeze(val, visited) {
        if ((isArray(val) || /* @__PURE__ */ isObject(val) || isFunction(val)) && !objIsFrozen(val)) {
          for (var lp = 0; lp < visited.length; lp++) {
            if (visited[lp] === val) {
              return val;
            }
          }
          visited.push(val);
          objForEachKey(val, function(_key, propValue) {
            _deepFreeze(propValue, visited);
          });
          objFreeze(val);
        }
        return val;
      }
      function objDeepFreeze(value) {
        return _objFreeze ? _deepFreeze(value, []) : value;
      }
      var objFreeze = /* @__PURE__ */ _pureAssign(_objFreeze, _doNothing);
      var objSeal = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "seal"), _doNothing);
      var objGetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "getPrototypeOf"), _getProto);
      // @__NO_SIDE_EFFECTS__
      function createEnum(values) {
        return /* @__PURE__ */ _createKeyValueMap(values, 1, 0, objFreeze);
      }
      // @__NO_SIDE_EFFECTS__
      function createEnumKeyMap(values) {
        return /* @__PURE__ */ _createKeyValueMap(values, 0, 0, objFreeze);
      }
      var _wellKnownSymbolMap = /* @__PURE__ */ createEnumKeyMap({
        asyncIterator: 0,
        hasInstance: 1,
        isConcatSpreadable: 2,
        iterator: 3,
        match: 4,
        matchAll: 5,
        replace: 6,
        search: 7,
        species: 8,
        split: 9,
        toPrimitive: 10,
        toStringTag: 11,
        unscopables: 12
      });
      var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
      var _globalCfg;
      // @__NO_SIDE_EFFECTS__
      function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
          result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
          result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
          result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
          result = global;
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function _getGlobalConfig() {
        if (!_globalCfg) {
          var gbl = safe(_getGlobalValue).v || {};
          _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
      }
      var mathMax = /* @__PURE__ */ _pureRef(MathCls, "max");
      var strSlice = /* @__PURE__ */ _unwrapFunction("slice", StrProto);
      var strSubstring = /* @__PURE__ */ _unwrapFunction("substring", StrProto);
      var strSubstr = /* @__PURE__ */ _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
      // @__NO_SIDE_EFFECTS__
      function polyStrSubstr(value, start, length) {
        _throwIfNullOrUndefined(value);
        if (length < 0) {
          return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
          start = mathMax(start + value[LENGTH], 0);
        }
        if (/* @__PURE__ */ isUndefined(length)) {
          return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
      }
      // @__NO_SIDE_EFFECTS__
      function strLeft(value, count) {
        return strSubstring(value, 0, count);
      }
      function _tagAsPolyfill(target, polyfillTypeName) {
        if (target) {
          safe(function() {
            target[POLYFILL_TAG] = true;
            target[POLYFILL_TYPE_NAME] = polyfillTypeName;
          });
          safe(objDefine, [target, POLYFILL_TAG, {
            v: true,
            w: false,
            e: false
          }]);
          safe(objDefine, [target, POLYFILL_TYPE_NAME, {
            v: polyfillTypeName,
            w: false,
            e: false
          }]);
        }
        return target;
      }
      var objCreate = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "create"), polyObjCreate);
      // @__NO_SIDE_EFFECTS__
      function polyObjCreate(obj, properties) {
        var newObj = null;
        function tempFunc() {
        }
        if (!/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          var type = typeof obj;
          if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + /* @__PURE__ */ dumpObj(obj));
          }
          tempFunc[PROTOTYPE] = obj;
          safe(function() {
            tempFunc[__PROTO__] = obj;
          });
          newObj = new tempFunc();
        } else {
          newObj = {};
        }
        if (properties) {
          safe(objDefineProperties, [newObj, properties]);
        }
        return newObj;
      }
      // @__NO_SIDE_EFFECTS__
      function utcNow() {
        return (Date.now || polyUtcNow)();
      }
      // @__NO_SIDE_EFFECTS__
      function polyUtcNow() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
      function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
      }
      var _globalLazyTestHooks;
      function _initTestHooks() {
        _globalLazyTestHooks = /* @__PURE__ */ _getGlobalConfig();
      }
      // @__NO_SIDE_EFFECTS__
      function getLazy(cb, argArray) {
        var lazyValue = {};
        !_globalLazyTestHooks && _initTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
          configurable: true,
          get: function() {
            var result = fnApply(cb, null, argArray);
            if (!_globalLazyTestHooks.lzy) {
              objDefineProp(lazyValue, "v", {
                value: result
              });
            }
            lazyValue.b = _globalLazyTestHooks.lzy;
            return result;
          }
        });
        return lazyValue;
      }
      var mathRandom = /* @__PURE__ */ _pureRef(MathCls, "random");
      var _uniqueInstanceId = /* @__PURE__ */ getLazy(function() {
        var value = (/* @__PURE__ */ utcNow()).toString(36).slice(2);
        while (value.length < 16) {
          value += mathRandom().toString(36).slice(2);
        }
        value = value.substring(0, 16);
        return value;
      });
      var UNIQUE_REGISTRY_ID = "_urid";
      var POLY_SYM = "$nw21sym";
      var _polySymbols;
      var _polyId = 0;
      // @__NO_SIDE_EFFECTS__
      function _globalSymbolRegistry() {
        if (!_polySymbols) {
          var gblCfg = /* @__PURE__ */ _getGlobalConfig();
          _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
      }
      var _wellKnownSymbolCache;
      // @__NO_SIDE_EFFECTS__
      function polyNewSymbol(description) {
        var uniqueId = "_" + _polyId++ + "_" + _uniqueInstanceId.v;
        var symString = SYMBOL + "(" + description + ")";
        function _setProp(name, value) {
          objDefine(theSymbol, name, {
            v: value,
            e: false,
            w: false
          });
        }
        var theSymbol = objCreate(null);
        _setProp("description", asString(description));
        _setProp(TO_STRING, function() {
          return symString + POLY_SYM + uniqueId;
        });
        _setProp("valueOf", function() {
          return theSymbol;
        });
        _setProp("v", symString);
        _setProp("_uid", uniqueId);
        return _tagAsPolyfill(theSymbol, "symbol");
      }
      // @__NO_SIDE_EFFECTS__
      function polySymbolFor(key) {
        var registry = /* @__PURE__ */ _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
          var newSymbol_1 = /* @__PURE__ */ polyNewSymbol(key);
          var regId_1 = objKeys(registry.s).length;
          newSymbol_1[UNIQUE_REGISTRY_ID] = function() {
            return regId_1 + "_" + newSymbol_1[TO_STRING]();
          };
          registry.k[key] = newSymbol_1;
          registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
      }
      // @__NO_SIDE_EFFECTS__
      function polyGetKnownSymbol(name) {
        !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
          result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || /* @__PURE__ */ polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function createCachedValue(value) {
        return objDefineProp({
          toJSON: function() {
            return value;
          }
        }, "v", { value });
      }
      var WINDOW = "window";
      var _cachedGlobal;
      function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function() {
          !_globalLazyTestHooks && _initTestHooks();
          if (!cachedValue || _globalLazyTestHooks.lzy) {
            cachedValue = /* @__PURE__ */ createCachedValue(safe(getFn, theArgs).v);
          }
          return cachedValue.v;
        };
      }
      function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        if (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) {
          _cachedGlobal = /* @__PURE__ */ createCachedValue(safe(_getGlobalValue).v || NULL_VALUE);
        }
        return _cachedGlobal.v;
      }
      // @__NO_SIDE_EFFECTS__
      function getInst(name, useCached) {
        var gbl;
        if (!_cachedGlobal || useCached === false) {
          gbl = getGlobal(useCached);
        } else {
          gbl = _cachedGlobal.v;
        }
        if (gbl && gbl[name]) {
          return gbl[name];
        }
        if (name === WINDOW) {
          try {
            return window;
          } catch (e) {
          }
        }
        return NULL_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function hasDocument() {
        return !!/* @__PURE__ */ getDocument();
      }
      var getDocument = /* @__PURE__ */ _getGlobalInstFn(getInst, ["document"]);
      // @__NO_SIDE_EFFECTS__
      function hasWindow() {
        return !!/* @__PURE__ */ getWindow();
      }
      var getWindow = /* @__PURE__ */ _getGlobalInstFn(getInst, [WINDOW]);
      // @__NO_SIDE_EFFECTS__
      function hasNavigator() {
        return !!/* @__PURE__ */ getNavigator();
      }
      var getNavigator = /* @__PURE__ */ _getGlobalInstFn(getInst, ["navigator"]);
      // @__NO_SIDE_EFFECTS__
      function hasHistory() {
        return !!/* @__PURE__ */ getHistory();
      }
      var getHistory = /* @__PURE__ */ _getGlobalInstFn(getInst, ["history"]);
      var isNode = /* @__PURE__ */ _getGlobalInstFn(function() {
        return !!safe(function() {
          return process && (process.versions || {}).node;
        }).v;
      });
      var _symbol;
      var _symbolFor;
      // @__NO_SIDE_EFFECTS__
      function _initSymbol() {
        _symbol = /* @__PURE__ */ createCachedValue(safe(getInst, [SYMBOL]).v);
        return _symbol;
      }
      function _getSymbolKey(key) {
        var gblSym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return gblSym.v ? gblSym.v[key] : UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function hasSymbol() {
        return !!/* @__PURE__ */ getSymbol();
      }
      // @__NO_SIDE_EFFECTS__
      function getSymbol() {
        !_globalLazyTestHooks && _initTestHooks();
        return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol()).v;
      }
      // @__NO_SIDE_EFFECTS__
      function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        !_globalLazyTestHooks && _initTestHooks();
        var sym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return sym.v ? sym.v[knownName || name] : !noPoly ? /* @__PURE__ */ polyGetKnownSymbol(name) : UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return sym.v ? sym.v(description) : !noPoly ? /* @__PURE__ */ polyNewSymbol(description) : NULL_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = (!_globalLazyTestHooks.lzy ? _symbolFor : 0) || /* @__PURE__ */ createCachedValue(safe(_getSymbolKey, ["for"]).v);
        return (_symbolFor.v || polySymbolFor)(key);
      }
      // @__NO_SIDE_EFFECTS__
      function isIterator(value) {
        return !!value && isFunction(value.next);
      }
      // @__NO_SIDE_EFFECTS__
      function isIterable(value) {
        return !/* @__PURE__ */ isStrictNullOrUndefined(value) && isFunction(value[/* @__PURE__ */ getKnownSymbol(3)]);
      }
      var _iterSymbol$1;
      function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
          if (!/* @__PURE__ */ isIterator(iter)) {
            !_iterSymbol$1 && (_iterSymbol$1 = /* @__PURE__ */ createCachedValue(/* @__PURE__ */ getKnownSymbol(3)));
            iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : NULL_VALUE;
          }
          if (/* @__PURE__ */ isIterator(iter)) {
            var err = UNDEF_VALUE;
            var iterResult = UNDEF_VALUE;
            try {
              var count = 0;
              while (!(iterResult = iter.next()).done) {
                if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                  break;
                }
                count++;
              }
            } catch (failed) {
              err = { e: failed };
              if (iter.throw) {
                iterResult = NULL_VALUE;
                iter.throw(err);
              }
            } finally {
              try {
                if (iterResult && !iterResult.done) {
                  iter.return && iter.return(iterResult);
                }
              } finally {
                if (err) {
                  throw err.e;
                }
              }
            }
          }
        }
      }
      function arrAppend(target, elms) {
        if (!/* @__PURE__ */ isUndefined(elms) && target) {
          if (isArray(elms)) {
            fnApply(target.push, target, elms);
          } else if (/* @__PURE__ */ isIterator(elms) || /* @__PURE__ */ isIterable(elms)) {
            iterForOf(elms, function(elm) {
              target.push(elm);
            });
          } else {
            target.push(elms);
          }
        }
        return target;
      }
      var arrIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", ArrProto);
      var arrMap = /* @__PURE__ */ _unwrapFunction("map", ArrProto);
      function arrSlice(theArray, start, end) {
        return ((theArray ? theArray["slice"] : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
      }
      // @__NO_SIDE_EFFECTS__
      function polyArrIncludes(theArray, searchElement, fromIndex) {
        return arrIndexOf(theArray, searchElement, fromIndex) !== -1;
      }
      var arrIncludes = /* @__PURE__ */ _unwrapFunctionWithPoly("includes", ArrProto, polyArrIncludes);
      var arrReduce = /* @__PURE__ */ _unwrapFunction("reduce", ArrProto);
      var _isProtoArray;
      var objSetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "setPrototypeOf"), _polyObjSetPrototypeOf);
      function _polyObjSetPrototypeOf(obj, proto) {
        var _a2;
        !_isProtoArray && (_isProtoArray = /* @__PURE__ */ createCachedValue((_a2 = {}, _a2[__PROTO__] = [], _a2) instanceof Array));
        _isProtoArray.v ? obj[__PROTO__] = proto : objForEachKey(proto, function(key, value) {
          return obj[key] = value;
        });
        return obj;
      }
      // @__NO_SIDE_EFFECTS__
      function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
          this[CONSTRUCTOR] = d;
          safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
      }
      function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
      }
      // @__NO_SIDE_EFFECTS__
      function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return /* @__PURE__ */ _createCustomError(name, function() {
          var _this = this;
          var theArgs = arguments;
          try {
            safe(_setName, [theBaseClass, name]);
            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
            if (_self !== _this) {
              var orgProto = objGetPrototypeOf(_this);
              if (orgProto !== objGetPrototypeOf(_self)) {
                objSetPrototypeOf(_self, orgProto);
              }
            }
            captureFn && captureFn(_self, _this[CONSTRUCTOR]);
            constructCb && constructCb(_self, theArgs);
            return _self;
          } finally {
            safe(_setName, [theBaseClass, orgName]);
          }
        }, theBaseClass);
      }
      // @__NO_SIDE_EFFECTS__
      function _createTrimFn(exp) {
        return function _doTrim(value) {
          _throwIfNullOrUndefined(value);
          if (value && value.replace) {
            value = value.replace(exp, EMPTY);
          }
          return value;
        };
      }
      var polyStrTrim = /* @__PURE__ */ _createTrimFn(/^\s+|(?=\s)\s+$/g);
      var strTrim = /* @__PURE__ */ _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim);
      var mathFloor = /* @__PURE__ */ _pureRef(MathCls, "floor");
      var _fnToString;
      var _objCtrFnString;
      var _gblWindow;
      // @__NO_SIDE_EFFECTS__
      function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
          return false;
        }
        if (!_gblWindow) {
          _gblWindow = /* @__PURE__ */ hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
          if (!_objCtrFnString) {
            _fnToString = Function[PROTOTYPE][TO_STRING];
            _objCtrFnString = _fnToString[CALL](ObjClass);
          }
          try {
            var proto = objGetPrototypeOf(value);
            result = !proto;
            if (!result) {
              if (/* @__PURE__ */ objHasOwnProperty(proto, CONSTRUCTOR)) {
                proto = proto[CONSTRUCTOR];
              }
              result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);
            }
          } catch (ex) {
          }
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function _defaultDeepCopyHandler(details) {
        details.value && plainObjDeepCopyHandler(details);
        return true;
      }
      var defaultDeepCopyHandlers = [
        arrayDeepCopyHandler,
        plainObjDeepCopyHandler,
        functionDeepCopyHandler,
        dateDeepCopyHandler
      ];
      // @__NO_SIDE_EFFECTS__
      function _getSetVisited(visitMap, source, newPath, cb) {
        var theEntry;
        arrForEach(visitMap, function(entry) {
          if (entry.k === source) {
            theEntry = entry;
            return -1;
          }
        });
        if (!theEntry) {
          theEntry = { k: source, v: source };
          visitMap.push(theEntry);
          cb(theEntry);
        }
        return theEntry.v;
      }
      function _deepCopy(visitMap, value, ctx, key) {
        var userHandler = ctx.handler;
        var newPath = ctx.path ? key ? ctx.path.concat(key) : ctx.path : [];
        var newCtx = {
          handler: ctx.handler,
          src: ctx.src,
          path: newPath
        };
        var theType = typeof value;
        var isPlain = false;
        var isPrim = value === NULL_VALUE;
        if (!isPrim) {
          if (value && theType === OBJECT) {
            isPlain = /* @__PURE__ */ isPlainObject(value);
          } else {
            isPrim = /* @__PURE__ */ isPrimitiveType(theType);
          }
        }
        var details = {
          type: theType,
          isPrim,
          isPlain,
          value,
          result: value,
          path: newPath,
          origin: ctx.src,
          copy: function(source, newKey) {
            return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
          },
          copyTo: function(target, source) {
            return _copyProps(visitMap, target, source, newCtx);
          }
        };
        if (!details.isPrim) {
          return /* @__PURE__ */ _getSetVisited(visitMap, value, newPath, function(newEntry) {
            objDefine(details, "result", {
              g: function() {
                return newEntry.v;
              },
              s: function(newValue) {
                newEntry.v = newValue;
              }
            });
            var idx = 0;
            var handler = userHandler;
            while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {
              handler = NULL_VALUE;
            }
          });
        }
        if (userHandler && userHandler[CALL](ctx, details)) {
          return details.result;
        }
        return value;
      }
      function _copyProps(visitMap, target, source, ctx) {
        if (!/* @__PURE__ */ isNullOrUndefined(source)) {
          for (var key in source) {
            target[key] = _deepCopy(visitMap, source[key], ctx, key);
          }
        }
        return target;
      }
      function objCopyProps(target, source, handler) {
        var ctx = {
          handler,
          src: source,
          path: []
        };
        return _copyProps([], target, source, ctx);
      }
      // @__NO_SIDE_EFFECTS__
      function objDeepCopy(source, handler) {
        var ctx = {
          handler,
          src: source
        };
        return _deepCopy([], source, ctx);
      }
      function arrayDeepCopyHandler(details) {
        var value = details.value;
        if (isArray(value)) {
          var target = details.result = [];
          target.length = value.length;
          details.copyTo(target, value);
          return true;
        }
        return false;
      }
      function dateDeepCopyHandler(details) {
        var value = details.value;
        if (isDate(value)) {
          details.result = new Date(value.getTime());
          return true;
        }
        return false;
      }
      function functionDeepCopyHandler(details) {
        if (details.type === FUNCTION) {
          return true;
        }
        return false;
      }
      function plainObjDeepCopyHandler(details) {
        var value = details.value;
        if (value && details.isPlain) {
          var target = details.result = {};
          details.copyTo(target, value);
          return true;
        }
        return false;
      }
      function _doExtend(target, theArgs) {
        arrForEach(theArgs, function(theArg) {
          objCopyProps(target, theArg);
        });
        return target;
      }
      function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
        return _doExtend(/* @__PURE__ */ objDeepCopy(target) || {}, ArrSlice[CALL](arguments));
      }
      var getLength = /* @__PURE__ */ _unwrapProp(LENGTH);
      var _perf;
      // @__NO_SIDE_EFFECTS__
      function getPerformance() {
        !_globalLazyTestHooks && _initTestHooks();
        if (!_perf || _globalLazyTestHooks.lzy) {
          _perf = /* @__PURE__ */ createCachedValue(safe(getInst, ["performance"]).v);
        }
        return _perf.v;
      }
      // @__NO_SIDE_EFFECTS__
      function perfNow() {
        var perf = /* @__PURE__ */ getPerformance();
        if (perf && perf.now) {
          return perf.now();
        }
        return /* @__PURE__ */ utcNow();
      }
      var objGetOwnPropertyDescriptor = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var strEndsWith = /* @__PURE__ */ _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
      // @__NO_SIDE_EFFECTS__
      function polyStrEndsWith(value, searchString, length) {
        _throwIfNotString(value);
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var end = !/* @__PURE__ */ isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
        return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
      }
      var strIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", StrProto);
      var strStartsWith = /* @__PURE__ */ _unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith);
      // @__NO_SIDE_EFFECTS__
      function polyStrStartsWith(value, searchString, position) {
        _throwIfNotString(value);
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var pos = position > 0 ? position : 0;
        return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;
      }
      var REF = "ref";
      var UNREF = "unref";
      var HAS_REF = "hasRef";
      var ENABLED = "enabled";
      // @__NO_SIDE_EFFECTS__
      function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
          ref = false;
          timerId && timerId[UNREF] && timerId[UNREF]();
          return theTimerHandler;
        }
        function _cancel() {
          timerId && cancelFn(timerId);
          timerId = NULL_VALUE;
        }
        function _refresh() {
          timerId = refreshFn(timerId);
          if (!ref) {
            _unref();
          }
          return theTimerHandler;
        }
        function _setEnabled(value) {
          !value && timerId && _cancel();
          value && !timerId && _refresh();
        }
        theTimerHandler = {
          cancel: _cancel,
          refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function() {
          if (timerId && timerId[HAS_REF]) {
            return timerId[HAS_REF]();
          }
          return ref;
        };
        theTimerHandler[REF] = function() {
          ref = true;
          timerId && timerId[REF] && timerId[REF]();
          return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
          get: function() {
            return !!timerId;
          },
          set: _setEnabled
        });
        return {
          h: theTimerHandler,
          dn: function() {
            timerId = NULL_VALUE;
          }
        };
      }
      var _setTimeoutFn;
      var _clearTimeoutFn;
      function _resolveTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _setTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 0 && isFunction(globalOverrides[0])) {
            result = globalOverrides[0];
          }
        }
        return result || setTimeout;
      }
      function _resolveClearTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _clearTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 1 && isFunction(globalOverrides[1])) {
            result = globalOverrides[1];
          }
        }
        return result || clearTimeout;
      }
      function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = _resolveTimeoutFn(len > 0 ? overrideFn[0] : !isArr ? overrideFn : UNDEF_VALUE);
        var clearFn = _resolveClearTimeoutFn(len > 1 ? overrideFn[1] : UNDEF_VALUE);
        var timerFn = theArgs[0];
        theArgs[0] = function() {
          handler.dn();
          fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = /* @__PURE__ */ _createTimerHandler(startTimer, function(timerId) {
          if (timerId) {
            if (timerId.refresh) {
              timerId.refresh();
              return timerId;
            }
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
          }
          return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function(timerId) {
          fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
      }
      function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
      }
      function createTimeout(callback, timeout) {
        return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));
      }
      (getGlobal() || {})["Symbol"];
      (getGlobal() || {})["Reflect"];
      var strHasOwnProperty = "hasOwnProperty";
      var extendStaticsFn = function(d, b) {
        extendStaticsFn = ObjClass$1["setPrototypeOf"] || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2[strHasOwnProperty](p)) {
              d2[p] = b2[p];
            }
          }
        };
        return extendStaticsFn(d, b);
      };
      function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
          throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
          this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
      }
      function __spreadArrayFn(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
          to[j] = from[i];
        }
        return to;
      }
      var _a$5;
      var Constructor = "constructor";
      var Prototype = "prototype";
      var strFunction = "function";
      var DynInstFuncTable = "_dynInstFuncs";
      var DynProxyTag = "_isDynProxy";
      var DynClassName = "_dynClass";
      var DynClassNamePrefix = "_dynCls$";
      var DynInstChkTag = "_dynInstChk";
      var DynAllowInstChkTag = DynInstChkTag;
      var DynProtoDefaultOptions = "_dfOpts";
      var UnknownValue = "_unknown_";
      var str__Proto = "__proto__";
      var DynProtoBaseProto = "_dyn" + str__Proto;
      var DynProtoGlobalSettings = "__dynProto$Gbl";
      var DynProtoCurrent = "_dynInstProto";
      var strUseBaseInst = "useBaseInst";
      var strSetInstFuncs = "setInstFuncs";
      var Obj = Object;
      var _objGetPrototypeOf = Obj["getPrototypeOf"];
      var _objGetOwnProps = Obj["getOwnPropertyNames"];
      var _gbl = getGlobal();
      var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$5 = {}, _a$5[strSetInstFuncs] = true, _a$5[strUseBaseInst] = true, _a$5),
        n: 1e3
      });
      function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
      }
      function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
      }
      function _getObjProto(target) {
        var newProto;
        if (target) {
          if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
          }
          var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
          newProto = target[DynProtoBaseProto] || curProto;
          if (!/* @__PURE__ */ objHasOwnProperty(target, DynProtoBaseProto)) {
            delete target[DynProtoCurrent];
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
          }
        }
        return newProto;
      }
      function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
          props = _objGetOwnProps(target);
        } else {
          for (var name_1 in target) {
            if (typeof name_1 === "string" && /* @__PURE__ */ objHasOwnProperty(target, name_1)) {
              props.push(name_1);
            }
          }
        }
        if (props && props.length > 0) {
          for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
          }
        }
      }
      function _isDynamicCandidate(target, funcName, skipOwn) {
        return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || /* @__PURE__ */ objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
      }
      function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
      }
      function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function(name) {
          if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
            instFuncs[name] = thisTarget[name];
          }
        });
        return instFuncs;
      }
      function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
          if (values[lp] === value) {
            return true;
          }
        }
        return false;
      }
      function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
          var theFunc = funcHost[funcName];
          if (theFunc[DynProxyTag] && useBaseInst) {
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
          }
          return function() {
            return theFunc.apply(target, arguments);
          };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function(name) {
          baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
          _forEachProp(baseProto, function(name) {
            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
              baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
            }
          });
          visited.push(baseProto);
          baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
      }
      function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && /* @__PURE__ */ objHasOwnProperty(proto, DynClassName)) {
          var instFuncTable = target[DynInstFuncTable] || objCreate(null);
          instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
          if (!instFunc) {
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
          }
          if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            var canAddInst = !/* @__PURE__ */ objHasOwnProperty(target, funcName);
            var objProto = _getObjProto(target);
            var visited = [];
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
              var protoFunc = objProto[funcName];
              if (protoFunc) {
                canAddInst = protoFunc === currentDynProtoProxy;
                break;
              }
              visited.push(objProto);
              objProto = _getObjProto(objProto);
            }
            try {
              if (canAddInst) {
                target[funcName] = instFunc;
              }
              instFunc[DynInstChkTag] = 1;
            } catch (e) {
              instFuncTable[DynAllowInstChkTag] = false;
            }
          }
        }
        return instFunc;
      }
      function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
          protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
          _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
      }
      function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto2, funcName) {
          var dynProtoProxy = function() {
            var instFunc = _getInstFunc(this, funcName, proto2, dynProtoProxy) || _getProtoFunc(funcName, proto2, dynProtoProxy);
            return instFunc.apply(this, arguments);
          };
          dynProtoProxy[DynProxyTag] = 1;
          return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
          var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
          if (!_isObjectOrArrayPrototype(instFuncTable)) {
            var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
            }
            if (!_isObjectOrArrayPrototype(instFuncs_1)) {
              _forEachProp(target, function(name) {
                if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                  instFuncs_1[name] = target[name];
                  delete target[name];
                  if (!/* @__PURE__ */ objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) {
                    proto[name] = _createDynamicPrototype(proto, name);
                  }
                }
              });
            }
          }
        }
      }
      function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
          var visited = [];
          var thisProto = _getObjProto(thisTarget);
          while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
              return true;
            }
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
          }
          return false;
        }
        return true;
      }
      function _getObjName(target, unknownValue) {
        if (/* @__PURE__ */ objHasOwnProperty(target, Prototype)) {
          return target.name || unknownValue || UnknownValue;
        }
        return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
      }
      function dynamicProto(theClass, target, delegateFunc, options) {
        if (!/* @__PURE__ */ objHasOwnProperty(theClass, Prototype)) {
          _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
          _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (/* @__PURE__ */ objHasOwnProperty(classProto, DynClassName)) {
          className = classProto[DynClassName];
        } else {
          className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
          _gblInst.n++;
          classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== void 0) {
          useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
          setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
      }
      dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
      var MinChannelPriorty = 100;
      var createEnumStyle = createEnum;
      var EventsDiscardedReason = createEnumStyle({
        Unknown: 0,
        NonRetryableStatus: 1,
        InvalidEvent: 2,
        SizeLimitExceeded: 3,
        KillSwitch: 4,
        QueueFull: 5
      });
      var ActiveStatus = createEnumStyle({
        NONE: 0,
        PENDING: 3,
        INACTIVE: 1,
        ACTIVE: 2
      });
      var _DYN_TO_LOWER_CASE = "toLowerCase";
      var _DYN_LENGTH$1 = "length";
      var _DYN_WARN_TO_CONSOLE = "warnToConsole";
      var _DYN_THROW_INTERNAL = "throwInternal";
      var _DYN_WATCH = "watch";
      var _DYN_APPLY = "apply";
      var _DYN_PUSH = "push";
      var _DYN_SPLICE = "splice";
      var _DYN_LOGGER = "logger";
      var _DYN_CANCEL = "cancel";
      var _DYN_INITIALIZE$1 = "initialize";
      var _DYN_IDENTIFIER = "identifier";
      var _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener";
      var _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener";
      var _DYN_IS_INITIALIZED = "isInitialized";
      var _DYN_GET_NOTIFY_MGR = "getNotifyMgr";
      var _DYN_GET_PLUGIN = "getPlugin";
      var _DYN_NAME = "name";
      var _DYN_PROCESS_NEXT = "processNext";
      var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext";
      var _DYN_VALUE$1 = "value";
      var _DYN_ENABLED = "enabled";
      var _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs";
      var _DYN_UNLOAD = "unload";
      var _DYN_ON_COMPLETE = "onComplete";
      var _DYN_VERSION = "version";
      var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
      var _DYN_CREATE_NEW = "createNew";
      var _DYN_TEARDOWN = "teardown";
      var _DYN_MESSAGE_ID = "messageId";
      var _DYN_MESSAGE = "message";
      var _DYN_DIAG_LOG = "diagLog";
      var _DYN__DO_TEARDOWN = "_doTeardown";
      var _DYN_UPDATE = "update";
      var _DYN_GET_NEXT = "getNext";
      var _DYN_SET_NEXT_PLUGIN = "setNextPlugin";
      var _DYN_USER_AGENT = "userAgent";
      var _DYN_SPLIT = "split";
      var _DYN_REPLACE = "replace";
      var _DYN_TYPE = "type";
      var _DYN_EVT_NAME = "evtName";
      var _DYN_STATUS = "status";
      var _DYN_INDEX_OF$1 = "indexOf";
      var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders";
      var _DYN_IS_CHILD_EVT = "isChildEvt";
      var _DYN_DATA = "data";
      var _DYN_GET_CTX = "getCtx";
      var _DYN_SET_CTX = "setCtx";
      var _DYN_ITEMS_RECEIVED = "itemsReceived";
      var _DYN_HEADERS = "headers";
      var _DYN_URL_STRING = "urlString";
      var _DYN_TIMEOUT = "timeout";
      var _DYN_TRACE_FLAGS = "traceFlags";
      var aggregationErrorType;
      function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
          aggregationErrorType = /* @__PURE__ */ createCustomError("AggregationError", function(self2, args) {
            if (args[_DYN_LENGTH$1] > 1) {
              self2.errors = args[1];
            }
          });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function(srcError, idx) {
          theMessage += "\n".concat(idx, " > ").concat(/* @__PURE__ */ dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
      }
      var STR_PROMISE = "Promise";
      var REJECTED = "rejected";
      function doAwaitResponse(value, cb) {
        return doAwait(value, function(value2) {
          return cb ? cb({
            status: "fulfilled",
            rejected: false,
            value: value2
          }) : value2;
        }, function(reason) {
          return cb ? cb({
            status: REJECTED,
            rejected: true,
            reason
          }) : reason;
        });
      }
      function doAwait(value, resolveFn, rejectFn, finallyFn) {
        var result = value;
        try {
          if (/* @__PURE__ */ isPromiseLike(value)) {
            if (resolveFn || rejectFn) {
              result = value.then(resolveFn, rejectFn);
            }
          } else {
            try {
              if (resolveFn) {
                result = resolveFn(value);
              }
            } catch (err) {
              if (rejectFn) {
                result = rejectFn(err);
              } else {
                throw err;
              }
            }
          }
        } finally {
          if (finallyFn) {
            doFinally(result, finallyFn);
          }
        }
        return result;
      }
      function doFinally(value, finallyFn) {
        var result = value;
        if (finallyFn) {
          if (/* @__PURE__ */ isPromiseLike(value)) {
            if (value.finally) {
              result = value.finally(finallyFn);
            } else {
              result = value.then(function(value2) {
                finallyFn();
                return value2;
              }, function(reason) {
                finallyFn();
                throw reason;
              });
            }
          } else {
            finallyFn();
          }
        }
        return result;
      }
      var STRING_STATES = [
        "pending",
        "resolving",
        "resolved",
        REJECTED
      ];
      var DISPATCH_EVENT = "dispatchEvent";
      var _hasInitEvent;
      function _hasInitEventFn(doc) {
        var evt;
        if (doc && doc.createEvent) {
          evt = doc.createEvent("Event");
        }
        return !!evt && evt.initEvent;
      }
      function emitEvent(target, evtName, populateEvent, useNewEvent) {
        var doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = /* @__PURE__ */ createCachedValue(!!safe(_hasInitEventFn, [doc]).v));
        var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : useNewEvent ? new Event(evtName) : {};
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
          theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
          target[DISPATCH_EVENT](theEvt);
        } else {
          var handler = target["on" + evtName];
          if (handler) {
            handler(theEvt);
          } else {
            var theConsole = /* @__PURE__ */ getInst("console");
            theConsole && (theConsole["error"] || theConsole["log"])(evtName, /* @__PURE__ */ dumpObj(theEvt));
          }
        }
      }
      var NODE_UNHANDLED_REJECTION = "unhandledRejection";
      var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
      var _unhandledRejectionTimeout = 10;
      var _hasPromiseRejectionEvent;
      function dumpFnObj(value) {
        if (isFunction(value)) {
          return value.toString();
        }
        return /* @__PURE__ */ dumpObj(value);
      }
      function _createPromise(newPromise, processor, executor) {
        var additionalArgs = arrSlice(arguments, 3);
        var _state = 0;
        var _hasResolved = false;
        var _settledValue;
        var _queue = [];
        var _handled = false;
        var _unHandledRejectionHandler = null;
        var _thePromise;
        function _then(onResolved, onRejected) {
          try {
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            var thenPromise = newPromise(function(resolve3, reject) {
              _queue.push(function() {
                try {
                  var handler = _state === 2 ? onResolved : onRejected;
                  var value = /* @__PURE__ */ isUndefined(handler) ? _settledValue : isFunction(handler) ? handler(_settledValue) : handler;
                  if (/* @__PURE__ */ isPromiseLike(value)) {
                    value.then(resolve3, reject);
                  } else if (handler) {
                    resolve3(value);
                  } else if (_state === 3) {
                    reject(value);
                  } else {
                    resolve3(value);
                  }
                } catch (e) {
                  reject(e);
                }
              });
              if (_hasResolved) {
                _processQueue();
              }
            }, additionalArgs);
            return thenPromise;
          } finally {
          }
        }
        function _catch(onRejected) {
          return _then(void 0, onRejected);
        }
        function _finally(onFinally) {
          var thenFinally = onFinally;
          var catchFinally = onFinally;
          if (isFunction(onFinally)) {
            thenFinally = function(value) {
              onFinally && onFinally();
              return value;
            };
            catchFinally = function(reason) {
              onFinally && onFinally();
              throw reason;
            };
          }
          return _then(thenFinally, catchFinally);
        }
        function _strState() {
          return STRING_STATES[_state];
        }
        function _processQueue() {
          if (_queue.length > 0) {
            var pending = _queue.slice();
            _queue = [];
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            processor(pending);
          }
        }
        function _createSettleIfFn(newState, allowState) {
          return function(theValue) {
            if (_state === allowState) {
              if (newState === 2 && /* @__PURE__ */ isPromiseLike(theValue)) {
                _state = 1;
                theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
                return;
              }
              _state = newState;
              _hasResolved = true;
              _settledValue = theValue;
              _processQueue();
              if (!_handled && newState === 3 && !_unHandledRejectionHandler) {
                _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
              }
            }
          };
        }
        function _notifyUnhandledRejection() {
          if (!_handled) {
            _handled = true;
            if (isNode()) {
              process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            } else {
              var gbl = getWindow() || getGlobal();
              !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = /* @__PURE__ */ createCachedValue(safe(getInst, [STR_PROMISE + "RejectionEvent"]).v));
              emitEvent(gbl, UNHANDLED_REJECTION, function(theEvt) {
                objDefine(theEvt, "promise", { g: function() {
                  return _thePromise;
                } });
                theEvt.reason = _settledValue;
                return theEvt;
              }, !!_hasPromiseRejectionEvent.v);
            }
          }
        }
        _thePromise = {
          then: _then,
          "catch": _catch,
          finally: _finally
        };
        objDefineProp(_thePromise, "state", {
          get: _strState
        });
        if (/* @__PURE__ */ hasSymbol()) {
          _thePromise[/* @__PURE__ */ getKnownSymbol(11)] = "IPromise";
        }
        function _toString() {
          return "IPromise " + _strState() + (_hasResolved ? " - " + dumpFnObj(_settledValue) : "");
        }
        _thePromise.toString = _toString;
        (function _initialize() {
          if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
          }
          var _rejectFn = _createSettleIfFn(3, 0);
          try {
            executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
          } catch (e) {
            _rejectFn(e);
          }
        })();
        return _thePromise;
      }
      // @__NO_SIDE_EFFECTS__
      function _createAllPromise(newPromise) {
        return function(input) {
          var additionalArgs = arrSlice(arguments, 1);
          return newPromise(function(resolve3, reject) {
            try {
              var values_1 = [];
              var pending_1 = 1;
              iterForOf(input, function(item, idx) {
                if (item) {
                  pending_1++;
                  doAwait(item, function(value) {
                    values_1[idx] = value;
                    if (--pending_1 === 0) {
                      resolve3(values_1);
                    }
                  }, reject);
                }
              });
              pending_1--;
              if (pending_1 === 0) {
                resolve3(values_1);
              }
            } catch (e) {
              reject(e);
            }
          }, additionalArgs);
        };
      }
      // @__NO_SIDE_EFFECTS__
      function _createAllSettledPromise(newPromise) {
        return /* @__PURE__ */ createCachedValue(function(input) {
          var additionalArgs = arrSlice(arguments, 1);
          return newPromise(function(resolve3, reject) {
            var values = [];
            var pending = 1;
            function processItem(item, idx) {
              pending++;
              doAwaitResponse(item, function(value) {
                if (value.rejected) {
                  values[idx] = {
                    status: REJECTED,
                    reason: value.reason
                  };
                } else {
                  values[idx] = {
                    status: "fulfilled",
                    value: value.value
                  };
                }
                if (--pending === 0) {
                  resolve3(values);
                }
              });
            }
            try {
              if (isArray(input)) {
                arrForEach(input, processItem);
              } else if (/* @__PURE__ */ isIterable(input)) {
                iterForOf(input, processItem);
              } else {
                throwTypeError("Input is not an iterable");
              }
              pending--;
              if (pending === 0) {
                resolve3(values);
              }
            } catch (e) {
              reject(e);
            }
          }, additionalArgs);
        });
      }
      function syncItemProcessor(pending) {
        arrForEach(pending, function(fn) {
          try {
            fn();
          } catch (e) {
          }
        });
      }
      function timeoutItemProcessor(timeout) {
        var callbackTimeout = isNumber(timeout) ? timeout : 0;
        return function(pending) {
          scheduleTimeout(function() {
            syncItemProcessor(pending);
          }, callbackTimeout);
        };
      }
      function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
      }
      var _promiseCls;
      function createNativePromise(executor, timeout) {
        !_promiseCls && (_promiseCls = /* @__PURE__ */ createCachedValue(safe(getInst, [STR_PROMISE]).v || null));
        var PrmCls = _promiseCls.v;
        if (!PrmCls) {
          return createAsyncPromise(executor);
        }
        if (!isFunction(executor)) {
          throwTypeError(STR_PROMISE + ": executor is not a function - " + /* @__PURE__ */ dumpObj(executor));
        }
        var _state = 0;
        function _strState() {
          return STRING_STATES[_state];
        }
        var thePromise = new PrmCls(function(resolve3, reject) {
          function _resolve(value) {
            _state = 2;
            resolve3(value);
          }
          function _reject(reason) {
            _state = 3;
            reject(reason);
          }
          executor(_resolve, _reject);
        });
        objDefineProp(thePromise, "state", {
          get: _strState
        });
        return thePromise;
      }
      var _allSyncSettledCreator;
      function createSyncPromise(executor) {
        return _createPromise(createSyncPromise, syncItemProcessor, executor);
      }
      function createSyncAllSettledPromise(input, timeout) {
        !_allSyncSettledCreator && (_allSyncSettledCreator = /* @__PURE__ */ _createAllSettledPromise(createSyncPromise));
        return _allSyncSettledCreator.v(input, timeout);
      }
      var _promiseCreator;
      function createPromise(executor, timeout) {
        !_promiseCreator && (_promiseCreator = /* @__PURE__ */ createCachedValue(createNativePromise));
        return _promiseCreator.v.call(this, executor, timeout);
      }
      var createAllPromise = /* @__PURE__ */ _createAllPromise(createPromise);
      var UNDEFINED_VALUE = void 0;
      var STR_EMPTY$2 = "";
      var STR_CHANNELS = "channels";
      var STR_CORE = "core";
      var STR_CREATE_PERF_MGR = "createPerfMgr";
      var STR_DISABLED = "disabled";
      var STR_EXTENSION_CONFIG = "extensionConfig";
      var STR_EXTENSIONS = "extensions";
      var STR_PROCESS_TELEMETRY = "processTelemetry";
      var STR_PRIORITY = "priority";
      var STR_EVENTS_SENT = "eventsSent";
      var STR_EVENTS_DISCARDED = "eventsDiscarded";
      var STR_EVENTS_SEND_REQUEST = "eventsSendRequest";
      var STR_PERF_EVENT = "perfEvent";
      var STR_OFFLINE_STORE = "offlineEventsStored";
      var STR_OFFLINE_SENT = "offlineBatchSent";
      var STR_OFFLINE_DROP = "offlineBatchDrop";
      var STR_GET_PERF_MGR = "getPerfMgr";
      var STR_DOMAIN = "domain";
      var STR_PATH = "path";
      var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";
      var rCamelCase = /-([a-z])/g;
      var rNormalizeInvalid = /([^\w\d_$])/g;
      var rLeadingNumeric = /^(\d+[\w\d_$])/;
      function isNotNullOrUndefined(value) {
        return !/* @__PURE__ */ isNullOrUndefined(value);
      }
      function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
          value = value[_DYN_REPLACE](rCamelCase, function(_all, letter) {
            return letter.toUpperCase();
          });
          value = value[_DYN_REPLACE](rNormalizeInvalid, "_");
          value = value[_DYN_REPLACE](rLeadingNumeric, function(_all, match) {
            return "_" + match;
          });
        }
        return value;
      }
      function strContains(value, search) {
        if (value && search) {
          return strIndexOf(value, search) !== -1;
        }
        return false;
      }
      function toISOString(date) {
        return date && date.toISOString() || "";
      }
      function getExceptionName(object) {
        if (isError(object)) {
          return object[_DYN_NAME];
        }
        return STR_EMPTY$2;
      }
      function setValue(target, field, value, valChk, srcChk) {
        var theValue = value;
        if (target) {
          theValue = target[field];
          if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
            theValue = value;
            target[field] = theValue;
          }
        }
        return theValue;
      }
      function getSetValue(target, field, defValue) {
        var theValue;
        if (target) {
          theValue = target[field];
          if (!theValue && /* @__PURE__ */ isNullOrUndefined(theValue)) {
            theValue = !/* @__PURE__ */ isUndefined(defValue) ? defValue : {};
            target[field] = theValue;
          }
        } else {
          theValue = !/* @__PURE__ */ isUndefined(defValue) ? defValue : {};
        }
        return theValue;
      }
      function _createProxyFunction(source, funcName) {
        var srcFunc = null;
        var src = null;
        if (isFunction(source)) {
          srcFunc = source;
        } else {
          src = source;
        }
        return function() {
          var originalArguments = arguments;
          if (srcFunc) {
            src = srcFunc();
          }
          if (src) {
            return src[funcName][_DYN_APPLY](src, originalArguments);
          }
        };
      }
      function proxyAssign(target, source, chkSet) {
        if (target && source && /* @__PURE__ */ isObject(target) && /* @__PURE__ */ isObject(source)) {
          var _loop_1 = function(field2) {
            if (isString(field2)) {
              var value = source[field2];
              if (isFunction(value)) {
                if (!chkSet || chkSet(field2, true, source, target)) {
                  target[field2] = _createProxyFunction(source, field2);
                }
              } else if (!chkSet || chkSet(field2, false, source, target)) {
                if (objHasOwn(target, field2)) {
                  delete target[field2];
                }
                objDefine(target, field2, {
                  g: function() {
                    return source[field2];
                  },
                  s: function(theValue) {
                    source[field2] = theValue;
                  }
                });
              }
            }
          };
          for (var field in source) {
            _loop_1(field);
          }
        }
        return target;
      }
      function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
        if (target && name && source) {
          if (overwriteTarget !== false || /* @__PURE__ */ isUndefined(target[name])) {
            target[name] = _createProxyFunction(source, theFunc);
          }
        }
      }
      function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
        if (target && source && /* @__PURE__ */ isObject(target) && isArray(functionsToProxy)) {
          arrForEach(functionsToProxy, function(theFuncName) {
            if (isString(theFuncName)) {
              proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
            }
          });
        }
        return target;
      }
      function optimizeObject(theObject) {
        if (theObject && objAssign) {
          theObject = ObjClass$1(objAssign({}, theObject));
        }
        return theObject;
      }
      function isFeatureEnabled(feature, cfg, sdkDefaultState) {
        var ft = cfg && cfg.featureOptIn && cfg.featureOptIn[feature];
        if (feature && ft) {
          var mode = ft.mode;
          if (mode === 3) {
            return true;
          } else if (mode === 2) {
            return false;
          }
        }
        return sdkDefaultState;
      }
      function getResponseText(xhr) {
        try {
          return xhr.responseText;
        } catch (e) {
        }
        return null;
      }
      function formatErrorMessageXdr(xdr, message) {
        if (xdr) {
          return "XDomainRequest,Response:" + getResponseText(xdr) || "";
        }
        return message;
      }
      function formatErrorMessageXhr(xhr, message) {
        if (xhr) {
          return "XMLHttpRequest,Status:" + xhr[_DYN_STATUS] + ",Response:" + getResponseText(xhr) || xhr.response || "";
        }
        return message;
      }
      function prependTransports(theTransports, newTransports) {
        if (newTransports) {
          if (isNumber(newTransports)) {
            theTransports = [newTransports].concat(theTransports);
          } else if (isArray(newTransports)) {
            theTransports = newTransports.concat(theTransports);
          }
        }
        return theTransports;
      }
      var strDisabledPropertyName$1 = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var strWithCredentials$1 = "withCredentials";
      var strTimeout$1 = "timeout";
      function openXhr$1(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) {
          disabled = false;
        }
        if (isSync === void 0) {
          isSync = false;
        }
        function _wrapSetXhrProp(xhr2, prop, value) {
          try {
            xhr2[prop] = value;
          } catch (e) {
          }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
          _wrapSetXhrProp(xhr, strDisabledPropertyName$1, disabled);
        }
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials$1, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials$1, withCredentials);
        }
        if (!isSync && timeout) {
          _wrapSetXhrProp(xhr, strTimeout$1, timeout);
        }
        return xhr;
      }
      function convertAllHeadersToMap(headersString) {
        var headers = {};
        if (isString(headersString)) {
          var headersArray = strTrim(headersString)[_DYN_SPLIT](/[\r\n]+/);
          arrForEach(headersArray, function(headerEntry) {
            if (headerEntry) {
              var idx = headerEntry[_DYN_INDEX_OF$1](": ");
              if (idx !== -1) {
                var header = strTrim(headerEntry.substring(0, idx))[_DYN_TO_LOWER_CASE]();
                var value = strTrim(headerEntry.substring(idx + 1));
                headers[header] = value;
              } else {
                headers[strTrim(headerEntry)] = 1;
              }
            }
          });
        }
        return headers;
      }
      function _appendHeader(theHeaders, xhr, name) {
        if (!theHeaders[name] && xhr && xhr.getResponseHeader) {
          var value = xhr.getResponseHeader(name);
          if (value) {
            theHeaders[name] = strTrim(value);
          }
        }
        return theHeaders;
      }
      var STR_KILL_DURATION_HEADER = "kill-duration";
      var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
      var STR_TIME_DELTA_HEADER = "time-delta-millis";
      function _getAllResponseHeaders(xhr, isOneDs) {
        var theHeaders = {};
        if (!xhr[_DYN_GET_ALL_RESPONSE_HEA5]) {
          if (!!isOneDs) {
            theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
          }
        } else {
          theHeaders = convertAllHeadersToMap(xhr[_DYN_GET_ALL_RESPONSE_HEA5]());
        }
        return theHeaders;
      }
      var strDocumentMode = "documentMode";
      var strLocation = "location";
      var strConsole = "console";
      var strJSON = "JSON";
      var strCrypto = "crypto";
      var strMsCrypto = "msCrypto";
      var strReactNative = "ReactNative";
      var strMsie = "msie";
      var strTrident = "trident/";
      var strXMLHttpRequest = "XMLHttpRequest";
      var _isTrident = null;
      var _navUserAgentCheck = null;
      var _enableMocks = false;
      var _useXDomainRequest = null;
      var _beaconsSupported = null;
      function _hasProperty(theClass, property) {
        var supported = false;
        if (theClass) {
          try {
            supported = property in theClass;
            if (!supported) {
              var proto = theClass[strShimPrototype];
              if (proto) {
                supported = property in proto;
              }
            }
          } catch (e) {
          }
          if (!supported) {
            try {
              var tmp = new theClass();
              supported = !/* @__PURE__ */ isUndefined(tmp[property]);
            } catch (e) {
            }
          }
        }
        return supported;
      }
      function setEnableEnvMocks(enabled) {
        _enableMocks = enabled;
      }
      function getLocation(checkForMock) {
        if (checkForMock && _enableMocks) {
          var mockLocation = /* @__PURE__ */ getInst("__mockLocation");
          if (mockLocation) {
            return mockLocation;
          }
        }
        if (typeof location === strShimObject && location) {
          return location;
        }
        return /* @__PURE__ */ getInst(strLocation);
      }
      function getConsole() {
        if (typeof console !== strShimUndefined) {
          return console;
        }
        return /* @__PURE__ */ getInst(strConsole);
      }
      function hasJSON() {
        return Boolean(typeof JSON === strShimObject && JSON || /* @__PURE__ */ getInst(strJSON) !== null);
      }
      function getJSON() {
        if (hasJSON()) {
          return JSON || /* @__PURE__ */ getInst(strJSON);
        }
        return null;
      }
      function getCrypto() {
        return /* @__PURE__ */ getInst(strCrypto);
      }
      function getMsCrypto() {
        return /* @__PURE__ */ getInst(strMsCrypto);
      }
      function isReactNative() {
        var nav = getNavigator();
        if (nav && nav.product) {
          return nav.product === strReactNative;
        }
        return false;
      }
      function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
          _navUserAgentCheck = nav[_DYN_USER_AGENT];
          var userAgent = (_navUserAgentCheck || STR_EMPTY$2)[_DYN_TO_LOWER_CASE]();
          _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
        }
        return _isTrident;
      }
      function getIEVersion(userAgentStr) {
        if (userAgentStr === void 0) {
          userAgentStr = null;
        }
        if (!userAgentStr) {
          var navigator_1 = getNavigator() || {};
          userAgentStr = navigator_1 ? (navigator_1.userAgent || STR_EMPTY$2)[_DYN_TO_LOWER_CASE]() : STR_EMPTY$2;
        }
        var ua = (userAgentStr || STR_EMPTY$2)[_DYN_TO_LOWER_CASE]();
        if (strContains(ua, strMsie)) {
          var doc = getDocument() || {};
          return mathMax(parseInt(ua[_DYN_SPLIT](strMsie)[1]), doc[strDocumentMode] || 0);
        } else if (strContains(ua, strTrident)) {
          var tridentVer = parseInt(ua[_DYN_SPLIT](strTrident)[1]);
          if (tridentVer) {
            return tridentVer + 4;
          }
        }
        return null;
      }
      function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
          _beaconsSupported = /* @__PURE__ */ hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
      }
      function isFetchSupported(withKeepAlive) {
        var isSupported = false;
        try {
          isSupported = !!/* @__PURE__ */ getInst("fetch");
          var request = /* @__PURE__ */ getInst("Request");
          if (isSupported && withKeepAlive && request) {
            isSupported = _hasProperty(request, "keepalive");
          }
        } catch (e) {
        }
        return isSupported;
      }
      function useXDomainRequest() {
        if (_useXDomainRequest === null) {
          _useXDomainRequest = typeof XDomainRequest !== strShimUndefined;
          if (_useXDomainRequest && isXhrSupported()) {
            _useXDomainRequest = _useXDomainRequest && !_hasProperty(/* @__PURE__ */ getInst(strXMLHttpRequest), "withCredentials");
          }
        }
        return _useXDomainRequest;
      }
      function isXhrSupported() {
        var isSupported = false;
        try {
          var xmlHttpRequest = /* @__PURE__ */ getInst(strXMLHttpRequest);
          isSupported = !!xmlHttpRequest;
        } catch (e) {
        }
        return isSupported;
      }
      function _getNamedValue(values, name) {
        if (values) {
          for (var i = 0; i < values[_DYN_LENGTH$1]; i++) {
            var value = values[i];
            if (value[_DYN_NAME]) {
              if (value[_DYN_NAME] === name) {
                return value;
              }
            }
          }
        }
        return {};
      }
      function findMetaTag(name) {
        var doc = getDocument();
        if (doc && name) {
          return _getNamedValue(doc.querySelectorAll("meta"), name).content;
        }
        return null;
      }
      function findNamedServerTiming(name) {
        var value;
        var perf = /* @__PURE__ */ getPerformance();
        if (perf) {
          var navPerf = perf.getEntriesByType("navigation") || [];
          value = _getNamedValue((navPerf[_DYN_LENGTH$1] > 0 ? navPerf[0] : {}).serverTiming, name).description;
        }
        return value;
      }
      var UInt32Mask = 4294967296;
      var MaxUInt32 = 4294967295;
      var SEED1 = 123456789;
      var SEED2 = 987654321;
      var _mwcSeeded = false;
      var _mwcW = SEED1;
      var _mwcZ = SEED2;
      function _mwcSeed(seedValue) {
        if (seedValue < 0) {
          seedValue >>>= 0;
        }
        _mwcW = SEED1 + seedValue & MaxUInt32;
        _mwcZ = SEED2 - seedValue & MaxUInt32;
        _mwcSeeded = true;
      }
      function _autoSeedMwc() {
        try {
          var now = /* @__PURE__ */ utcNow() & 2147483647;
          _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
        } catch (e) {
        }
      }
      function randomValue(maxValue) {
        if (maxValue > 0) {
          return mathFloor(random32() / MaxUInt32 * (maxValue + 1)) >>> 0;
        }
        return 0;
      }
      function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
          value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
          if (!_mwcSeeded) {
            _autoSeedMwc();
          }
          value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
          value = mathFloor(UInt32Mask * Math.random() | 0);
        }
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function mwcRandom32(signed) {
        _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32;
        _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
        var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function newId(maxLength) {
        if (maxLength === void 0) {
          maxLength = 22;
        }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY$2;
        while (result[_DYN_LENGTH$1] < maxLength) {
          chars++;
          result += base64chars.charAt(number & 63);
          number >>>= 6;
          if (chars === 5) {
            number = (random32() << 2 & 4294967295 | number & 3) >>> 0;
            chars = 0;
          }
        }
        return result;
      }
      var version = "3.3.7";
      var instanceName = "." + newId(6);
      var _dataUid = 0;
      function _canAcceptData(target) {
        return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
      }
      function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
          theCache = {};
          try {
            if (_canAcceptData(target)) {
              objDefine(target, data.id, {
                e: false,
                v: theCache
              });
            }
          } catch (e) {
          }
        }
        return theCache;
      }
      function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) {
          includeVersion = false;
        }
        return normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY$2) + instanceName);
      }
      function createElmNodeData(name) {
        var data = {
          id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY$2) + "." + version),
          accept: function(target) {
            return _canAcceptData(target);
          },
          get: function(target, name2, defValue, addDefault) {
            var theCache = target[data.id];
            if (!theCache) {
              if (addDefault) {
                theCache = _getCache(data, target);
                theCache[normalizeJsName(name2)] = defValue;
              }
              return defValue;
            }
            return theCache[normalizeJsName(name2)];
          },
          kill: function(target, name2) {
            if (target && target[name2]) {
              try {
                delete target[name2];
              } catch (e) {
              }
            }
          }
        };
        return data;
      }
      function _isConfigDefaults(value) {
        return value && /* @__PURE__ */ isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
      }
      function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
          var fallbacks = cfgDefaults.fb;
          if (!isArray(fallbacks)) {
            fallbacks = [fallbacks];
          }
          for (var lp = 0; lp < fallbacks[_DYN_LENGTH$1]; lp++) {
            var fallback = fallbacks[lp];
            var fbValue = theConfig[fallback];
            if (isDefaultValid(fbValue)) {
              defValue = fbValue;
            } else if (dynamicHandler) {
              fbValue = dynamicHandler.cfg[fallback];
              if (isDefaultValid(fbValue)) {
                defValue = fbValue;
              }
              dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
            }
            if (isDefaultValid(defValue)) {
              break;
            }
          }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
          defValue = cfgDefaults.v;
        }
        return defValue;
      }
      function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
          theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
          if (_isConfigDefaults(theValue)) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
          }
          var newValue_1;
          if (isArray(theValue)) {
            newValue_1 = [];
            newValue_1[_DYN_LENGTH$1] = theValue[_DYN_LENGTH$1];
          } else if (/* @__PURE__ */ isPlainObject(theValue)) {
            newValue_1 = {};
          }
          if (newValue_1) {
            objForEachKey(theValue, function(key, value) {
              if (value && _isConfigDefaults(value)) {
                value = _resolveDefaultValue(dynamicHandler, theConfig, value);
              }
              newValue_1[key] = value;
            });
            theValue = newValue_1;
          }
        }
        return theValue;
      }
      function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
          isValid = cfgDefaults.isVal;
          setFn = cfgDefaults.set;
          readOnly = cfgDefaults.rdOnly;
          blkDynamicValue = cfgDefaults.blkVal;
          mergeDf = cfgDefaults.mrg;
          reference = cfgDefaults.ref;
          if (!reference && /* @__PURE__ */ isUndefined(reference)) {
            reference = !!mergeDf;
          }
          defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        } else {
          defValue = defaultValue;
        }
        if (blkDynamicValue) {
          dynamicHandler.blkVal(theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !/* @__PURE__ */ isNullOrUndefined(cfgValue)) {
          theValue = cfgValue;
          usingDefault = false;
          if (isValid && theValue !== defValue && !isValid(theValue)) {
            theValue = defValue;
            usingDefault = true;
          }
          if (setFn) {
            theValue = setFn(theValue, defValue, theConfig);
            usingDefault = theValue === defValue;
          }
        }
        if (!usingDefault) {
          if (/* @__PURE__ */ isPlainObject(theValue) || isArray(defValue)) {
            if (mergeDf && defValue && (/* @__PURE__ */ isPlainObject(defValue) || isArray(defValue))) {
              objForEachKey(defValue, function(dfName, dfValue) {
                _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
              });
            }
          }
        } else if (defValue) {
          theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        } else {
          theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
          dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
          dynamicHandler.rdOnly(theConfig, name);
        }
      }
      var CFG_HANDLER_LINK = /* @__PURE__ */ symbolFor("[[ai_dynCfg_1]]");
      var BLOCK_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_blkDynCfg_1]]");
      var FORCE_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_frcDynCfg_1]]");
      function _cfgDeepCopy(source) {
        if (source) {
          var target_1;
          if (isArray(source)) {
            target_1 = [];
            target_1[_DYN_LENGTH$1] = source[_DYN_LENGTH$1];
          } else if (/* @__PURE__ */ isPlainObject(source)) {
            target_1 = {};
          }
          if (target_1) {
            objForEachKey(source, function(key, value) {
              target_1[key] = _cfgDeepCopy(value);
            });
            return target_1;
          }
        }
        return source;
      }
      function getDynamicConfigHandler(value) {
        if (value) {
          var handler = value[CFG_HANDLER_LINK] || value;
          if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler;
          }
        }
        return null;
      }
      function blockDynamicConversion(value) {
        if (value && (/* @__PURE__ */ isPlainObject(value) || isArray(value))) {
          try {
            value[BLOCK_DYNAMIC] = true;
          } catch (e) {
          }
        }
        return value;
      }
      function forceDynamicConversion(value) {
        if (value) {
          try {
            value[FORCE_DYNAMIC] = true;
          } catch (e) {
          }
        }
        return value;
      }
      function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
          result = value[FORCE_DYNAMIC];
          if (!result && !value[BLOCK_DYNAMIC]) {
            result = /* @__PURE__ */ isPlainObject(value) || isArray(value);
          }
        }
        return result;
      }
      function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
      }
      var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
      ];
      var _throwDynamicError = function(logger2, name, desc, e) {
        logger2 && logger2[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + /* @__PURE__ */ dumpObj(e));
      };
      function _patchArray(state, target, name) {
        if (isArray(target)) {
          arrForEach(arrayMethodsToPatch, function(method) {
            var orgMethod = target[method];
            target[method] = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var result = orgMethod[_DYN_APPLY](this, args);
              _makeDynamicObject(state, target, name, "Patching");
              return result;
            };
          });
        }
      }
      function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
      }
      function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
          n: name,
          h: [],
          trk: function(handler) {
            if (handler && handler.fn) {
              if (arrIndexOf(detail.h, handler) === -1) {
                detail.h[_DYN_PUSH](handler);
              }
              state.trk(handler, detail);
            }
          },
          clr: function(handler) {
            var idx = arrIndexOf(detail.h, handler);
            if (idx !== -1) {
              detail.h[_DYN_SPLICE](idx, 1);
            }
          }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
          if (checkDynamic) {
            isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
            if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
              value = _makeDynamicObject(state, value, name, "Converting");
            }
            checkDynamic = false;
          }
          var activeHandler = state.act;
          if (activeHandler) {
            detail.trk(activeHandler);
          }
          return value;
        }
        _getProperty[state.prop] = {
          chng: function() {
            state.add(detail);
          }
        };
        function _setProperty(newValue) {
          if (value !== newValue) {
            if (!!_getProperty[state.ro] && !state.upd) {
              throwInvalidAccess("[" + name + "] is read-only:" + /* @__PURE__ */ dumpObj(theConfig));
            }
            if (checkDynamic) {
              isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
              checkDynamic = false;
            }
            var isReferenced = isObjectOrArray && _getProperty[state.rf];
            if (isObjectOrArray) {
              if (isReferenced) {
                objForEachKey(value, function(key) {
                  value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
                });
                try {
                  objForEachKey(newValue, function(key, theValue) {
                    _setDynamicProperty(state, value, key, theValue);
                  });
                  newValue = value;
                } catch (e) {
                  _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e);
                  isObjectOrArray = false;
                }
              } else if (value && value[CFG_HANDLER_LINK]) {
                objForEachKey(value, function(key) {
                  var getter = _getOwnPropGetter(value, key);
                  if (getter) {
                    var valueState = getter[state.prop];
                    valueState && valueState.chng();
                  }
                });
              }
            }
            if (newValue !== value) {
              var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
              if (!isReferenced && newIsObjectOrArray) {
                newValue = _makeDynamicObject(state, newValue, name, "Converting");
              }
              value = newValue;
              isObjectOrArray = newIsObjectOrArray;
            }
            state.add(detail);
          }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
      }
      function _setDynamicProperty(state, target, name, value) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          if (!isDynamic) {
            _createDynamicProperty(state, target, name, value);
          } else {
            target[name] = value;
          }
        }
        return target;
      }
      function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          var inPlace = flags && flags[0];
          var rdOnly = flags && flags[1];
          var blkProp = flags && flags[2];
          if (!isDynamic) {
            if (blkProp) {
              try {
                blockDynamicConversion(target);
              } catch (e) {
                _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
              }
            }
            try {
              _setDynamicProperty(state, target, name, target[name]);
              getter = _getOwnPropGetter(target, name);
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
            }
          }
          if (inPlace) {
            getter[state.rf] = inPlace;
          }
          if (rdOnly) {
            getter[state.ro] = rdOnly;
          }
          if (blkProp) {
            getter[state.blkVal] = true;
          }
        }
        return target;
      }
      function _makeDynamicObject(state, target, name, desc) {
        try {
          objForEachKey(target, function(key, value) {
            _setDynamicProperty(state, target, key, value);
          });
          if (!target[CFG_HANDLER_LINK]) {
            objDefineProp(target, CFG_HANDLER_LINK, {
              get: function() {
                return state.hdlr;
              }
            });
            _patchArray(state, target, name);
          }
        } catch (e) {
          _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
        }
        return target;
      }
      var symPrefix = "[[ai_";
      var symPostfix = "]]";
      function _createState(cfgHandler) {
        var dynamicPropertySymbol = /* @__PURE__ */ newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = /* @__PURE__ */ newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = /* @__PURE__ */ newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = /* @__PURE__ */ newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = /* @__PURE__ */ newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
          var prevWatcher = theState.act;
          try {
            theState.act = activeHandler;
            if (activeHandler && activeHandler[dynamicPropertyDetail]) {
              arrForEach(activeHandler[dynamicPropertyDetail], function(detail) {
                detail.clr(activeHandler);
              });
              activeHandler[dynamicPropertyDetail] = [];
            }
            callback({
              cfg: cfgHandler.cfg,
              set: cfgHandler.set.bind(cfgHandler),
              setDf: cfgHandler.setDf.bind(cfgHandler),
              ref: cfgHandler.ref.bind(cfgHandler),
              rdOnly: cfgHandler.rdOnly.bind(cfgHandler)
            });
          } catch (e) {
            var logger2 = cfgHandler[_DYN_LOGGER];
            if (logger2) {
              logger2[_DYN_THROW_INTERNAL](1, 107, /* @__PURE__ */ dumpObj(e));
            }
            throw e;
          } finally {
            theState.act = prevWatcher || null;
          }
        }
        function _notifyWatchers() {
          if (_waitingHandlers) {
            var notifyHandlers = _waitingHandlers;
            _waitingHandlers = null;
            _watcherTimer && _watcherTimer[_DYN_CANCEL]();
            _watcherTimer = null;
            var watcherFailures_1 = [];
            arrForEach(notifyHandlers, function(handler) {
              if (handler) {
                if (handler[dynamicPropertyDetail]) {
                  arrForEach(handler[dynamicPropertyDetail], function(detail) {
                    detail.clr(handler);
                  });
                  handler[dynamicPropertyDetail] = null;
                }
                if (handler.fn) {
                  try {
                    _useHandler(handler, handler.fn);
                  } catch (e) {
                    watcherFailures_1[_DYN_PUSH](e);
                  }
                }
              }
            });
            if (_waitingHandlers) {
              try {
                _notifyWatchers();
              } catch (e) {
                watcherFailures_1[_DYN_PUSH](e);
              }
            }
            if (watcherFailures_1[_DYN_LENGTH$1] > 0) {
              throwAggregationError("Watcher error(s): ", watcherFailures_1);
            }
          }
        }
        function _addWatcher(detail) {
          if (detail && detail.h[_DYN_LENGTH$1] > 0) {
            if (!_waitingHandlers) {
              _waitingHandlers = [];
            }
            if (!_watcherTimer) {
              _watcherTimer = scheduleTimeout(function() {
                _watcherTimer = null;
                _notifyWatchers();
              }, 0);
            }
            for (var idx = 0; idx < detail.h[_DYN_LENGTH$1]; idx++) {
              var handler = detail.h[idx];
              if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                _waitingHandlers[_DYN_PUSH](handler);
              }
            }
          }
        }
        function _trackHandler(handler, detail) {
          if (handler) {
            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
            if (arrIndexOf(details, detail) === -1) {
              details[_DYN_PUSH](detail);
            }
          }
        }
        theState = {
          prop: dynamicPropertySymbol,
          ro: dynamicPropertyReadOnly,
          rf: dynamicPropertyReferenced,
          blkVal: dynamicPropertyBlockValue,
          hdlr: cfgHandler,
          add: _addWatcher,
          notify: _notifyWatchers,
          use: _useHandler,
          trk: _trackHandler
        };
        return theState;
      }
      function _createAndUseHandler(state, configHandler) {
        var handler = {
          fn: configHandler,
          rm: function() {
            handler.fn = null;
            state = null;
            configHandler = null;
          }
        };
        objDefine(handler, "toJSON", { v: function() {
          return "WatcherHandler" + (handler.fn ? "" : "[X]");
        } });
        state.use(handler, configHandler);
        return handler;
      }
      function _createDynamicHandler(logger2, target, inPlace) {
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
          return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = target && inPlace !== false ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
          theState.notify();
        }
        function _setValue(target2, name, value) {
          try {
            target2 = _setDynamicProperty(theState, target2, name, value);
          } catch (e) {
            _throwDynamicError(logger2, name, "Setting value", e);
          }
          return target2[name];
        }
        function _watch(configHandler) {
          return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
          theState.use(null, function(details) {
            var prevUpd = theState.upd;
            try {
              if (!/* @__PURE__ */ isUndefined(allowUpdate)) {
                theState.upd = allowUpdate;
              }
              configHandler(details);
            } finally {
              theState.upd = prevUpd;
            }
          });
        }
        function _ref(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[0] = true, _a2))[name];
        }
        function _rdOnly(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[1] = true, _a2))[name];
        }
        function _blkPropValue(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[2] = true, _a2))[name];
        }
        function _applyDefaults(theConfig, defaultValues2) {
          if (defaultValues2) {
            objForEachKey(defaultValues2, function(name, value) {
              _applyDefaultValue(cfgHandler, theConfig, name, value);
            });
          }
          return theConfig;
        }
        var cfgHandler = {
          uid: null,
          cfg: newTarget,
          logger: logger2,
          notify: _notifyWatchers,
          set: _setValue,
          setDf: _applyDefaults,
          watch: _watch,
          ref: _ref,
          rdOnly: _rdOnly,
          blkVal: _blkPropValue,
          _block
        };
        objDefine(cfgHandler, "uid", {
          c: false,
          e: false,
          w: false,
          v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
      }
      function _logInvalidAccess(logger2, message) {
        if (logger2) {
          logger2[_DYN_WARN_TO_CONSOLE](message);
          logger2[_DYN_THROW_INTERNAL](2, 108, message);
        } else {
          throwInvalidAccess(message);
        }
      }
      function createDynamicConfig(config, defaultConfig2, logger2, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger2, config || {}, inPlace);
        if (defaultConfig2) {
          dynamicHandler.setDf(dynamicHandler.cfg, defaultConfig2);
        }
        return dynamicHandler;
      }
      function onConfigChange(config, configHandler, logger2) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
          return handler[_DYN_WATCH](configHandler);
        }
        _logInvalidAccess(logger2, STR_NOT_DYNAMIC_ERROR + /* @__PURE__ */ dumpObj(config));
        return createDynamicConfig(config, null, logger2)[_DYN_WATCH](configHandler);
      }
      function runTargetUnload(target, isAsync) {
        if (target && target[_DYN_UNLOAD]) {
          return target[_DYN_UNLOAD](isAsync);
        }
      }
      function doUnloadAll(targets, isAsync, done) {
        var result;
        if (!done) {
          result = createPromise(function(resolved) {
            done = resolved;
          });
        }
        if (targets && getLength(targets) > 0) {
          doAwaitResponse(runTargetUnload(targets[0], isAsync), function() {
            doUnloadAll(arrSlice(targets, 1), isAsync, done);
          });
        } else {
          done();
        }
        return result;
      }
      var ChannelControllerPriority = 500;
      var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      function cfgDfMerge(defaultValue) {
        return {
          mrg: true,
          v: defaultValue
        };
      }
      var listenerFuncs = [STR_EVENTS_SENT, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_PERF_EVENT];
      var _aiNamespace = null;
      var _debugListener;
      function _listenerProxyFunc(name, config) {
        return function() {
          var args = arguments;
          var dbgExt = getDebugExt(config);
          if (dbgExt) {
            var listener = dbgExt.listener;
            if (listener && listener[name]) {
              listener[name][_DYN_APPLY](listener, args);
            }
          }
        };
      }
      function _getExtensionNamespace() {
        var target = /* @__PURE__ */ getInst("Microsoft");
        if (target) {
          _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
      }
      function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
          ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
      }
      function getDebugListener(config) {
        if (!_debugListener) {
          _debugListener = {};
          for (var lp = 0; lp < listenerFuncs[_DYN_LENGTH$1]; lp++) {
            _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
          }
        }
        return _debugListener;
      }
      var _a$4;
      var STR_WARN_TO_CONSOLE = "warnToConsole";
      var AiNonUserActionablePrefix = "AI (Internal): ";
      var AiUserActionablePrefix = "AI: ";
      var AIInternalMessagePrefix = "AITR_";
      var defaultValues$2 = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
      };
      var _logFuncs = (_a$4 = {}, _a$4[0] = null, _a$4[1] = "errorToConsole", _a$4[2] = STR_WARN_TO_CONSOLE, _a$4[3] = "debugToConsole", _a$4);
      function _sanitizeDiagnosticText(text) {
        if (text) {
          return '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY$2) + '"';
        }
        return STR_EMPTY$2;
      }
      function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
          var logFunc = "log";
          if (theConsole[func]) {
            logFunc = func;
          }
          if (isFunction(theConsole[logFunc])) {
            theConsole[logFunc](message);
          }
        }
      }
      var _InternalLogMessage = (
        /** @class */
        function() {
          function _InternalLogMessage2(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) {
              isUserAct = false;
            }
            var _self = this;
            _self[_DYN_MESSAGE_ID] = msgId;
            _self[_DYN_MESSAGE] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
            var strProps = STR_EMPTY$2;
            if (hasJSON()) {
              strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY$2) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY$2);
            _self[_DYN_MESSAGE] += diagnosticText;
          }
          _InternalLogMessage2.dataType = "MessageData";
          return _InternalLogMessage2;
        }()
      );
      function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
      }
      var DiagnosticLogger = (
        /** @class */
        function() {
          function DiagnosticLogger2(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger2, this, function(_self) {
              _unloadHandler = _setDefaultsFromConfig(config || {});
              _self.consoleLoggingLevel = function() {
                return _loggingLevelConsole;
              };
              _self[_DYN_THROW_INTERNAL] = function(severity, msgId, msg, properties, isUserAct) {
                if (isUserAct === void 0) {
                  isUserAct = false;
                }
                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                if (_enableDebug) {
                  throw /* @__PURE__ */ dumpObj(message);
                } else {
                  var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                  if (!/* @__PURE__ */ isUndefined(message[_DYN_MESSAGE])) {
                    if (isUserAct) {
                      var messageKey = +message[_DYN_MESSAGE_ID];
                      if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE]);
                        _messageLogged[messageKey] = true;
                      }
                    } else {
                      if (_loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE]);
                      }
                    }
                    _logInternalMessage2(severity, message);
                  } else {
                    _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);
                  }
                }
              };
              _self.debugToConsole = function(message) {
                _logToConsole("debug", message);
                _debugExtMsg("warning", message);
              };
              _self[_DYN_WARN_TO_CONSOLE] = function(message) {
                _logToConsole("warn", message);
                _debugExtMsg("warning", message);
              };
              _self.errorToConsole = function(message) {
                _logToConsole("error", message);
                _debugExtMsg("error", message);
              };
              _self.resetInternalMessageCount = function() {
                _messageCount = 0;
                _messageLogged = {};
              };
              _self.logInternalMessage = _logInternalMessage2;
              _self[_DYN_UNLOAD] = function(isAsync) {
                _unloadHandler && _unloadHandler.rm();
                _unloadHandler = null;
              };
              function _logInternalMessage2(severity, message) {
                if (_areInternalMessagesThrottled()) {
                  return;
                }
                var logMessage = true;
                var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
                if (_messageLogged[messageKey]) {
                  logMessage = false;
                } else {
                  _messageLogged[messageKey] = true;
                }
                if (logMessage) {
                  if (severity <= _loggingLevelTelemetry) {
                    _self.queue[_DYN_PUSH](message);
                    _messageCount++;
                    _debugExtMsg(severity === 1 ? "error" : "warn", message);
                  }
                  if (_messageCount === _maxInternalMessageLimit) {
                    var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                    var throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, false);
                    _self.queue[_DYN_PUSH](throttleMessage);
                    if (severity === 1) {
                      _self.errorToConsole(throttleLimitMessage);
                    } else {
                      _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
                    }
                  }
                }
              }
              function _setDefaultsFromConfig(config2) {
                return onConfigChange(createDynamicConfig(config2, defaultValues$2, _self).cfg, function(details) {
                  var config3 = details.cfg;
                  _loggingLevelConsole = config3[_DYN_LOGGING_LEVEL_CONSOL4];
                  _loggingLevelTelemetry = config3.loggingLevelTelemetry;
                  _maxInternalMessageLimit = config3.maxMessageLimit;
                  _enableDebug = config3.enableDebug;
                });
              }
              function _areInternalMessagesThrottled() {
                return _messageCount >= _maxInternalMessageLimit;
              }
              function _debugExtMsg(name, data) {
                var dbgExt = getDebugExt(config || {});
                if (dbgExt && dbgExt[_DYN_DIAG_LOG]) {
                  dbgExt[_DYN_DIAG_LOG](name, data);
                }
              }
            });
          }
          DiagnosticLogger2.__ieDyn = 1;
          return DiagnosticLogger2;
        }()
      );
      function _getLogger(logger2) {
        return logger2 || new DiagnosticLogger();
      }
      function _throwInternal(logger2, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) {
          isUserAct = false;
        }
        _getLogger(logger2)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
      }
      function _warnToConsole(logger2, message) {
        _getLogger(logger2)[_DYN_WARN_TO_CONSOLE](message);
      }
      function _logInternalMessage(logger2, severity, message) {
        _getLogger(logger2).logInternalMessage(severity, message);
      }
      var _a$3, _b;
      var strToGMTString = "toGMTString";
      var strToUTCString = "toUTCString";
      var strCookie = "cookie";
      var strExpires = "expires";
      var strIsCookieUseDisabled = "isCookieUseDisabled";
      var strDisableCookiesUsage = "disableCookiesUsage";
      var strConfigCookieMgr = "_ckMgr";
      var _supportsCookies = null;
      var _allowUaSameSite = null;
      var _parsedCookieValue = null;
      var _doc;
      var _cookieCache = {};
      var _globalCookieConfig = {};
      var rootDefaultConfig = (_a$3 = {
        cookieCfg: cfgDfMerge((_b = {}, _b[STR_DOMAIN] = { fb: "cookieDomain", dfVal: isNotNullOrUndefined }, _b.path = { fb: "cookiePath", dfVal: isNotNullOrUndefined }, _b.enabled = UNDEFINED_VALUE, _b.ignoreCookies = UNDEFINED_VALUE, _b.blockedCookies = UNDEFINED_VALUE, _b)),
        cookieDomain: UNDEFINED_VALUE,
        cookiePath: UNDEFINED_VALUE
      }, _a$3[strDisableCookiesUsage] = UNDEFINED_VALUE, _a$3);
      function _getDoc() {
        !_doc && (_doc = /* @__PURE__ */ getLazy(function() {
          return getDocument();
        }));
      }
      function _gblCookieMgr(config, logger2) {
        var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
        if (!inst) {
          inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger2);
          _globalCookieConfig[strConfigCookieMgr] = inst;
        }
        return inst;
      }
      function _isMgrEnabled(cookieMgr) {
        if (cookieMgr) {
          return cookieMgr.isEnabled();
        }
        return true;
      }
      function _isIgnoredCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.ignoreCookies)) {
          return arrIndexOf(cookieMgrCfg.ignoreCookies, name) !== -1;
        }
        return false;
      }
      function _isBlockedCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.blockedCookies)) {
          if (arrIndexOf(cookieMgrCfg.blockedCookies, name) !== -1) {
            return true;
          }
        }
        return _isIgnoredCookie(cookieMgrCfg, name);
      }
      function _isCfgEnabled(rootConfig, cookieMgrConfig) {
        var isCfgEnabled = cookieMgrConfig[_DYN_ENABLED];
        if (/* @__PURE__ */ isNullOrUndefined(isCfgEnabled)) {
          var cookieEnabled = void 0;
          if (!/* @__PURE__ */ isUndefined(rootConfig[strIsCookieUseDisabled])) {
            cookieEnabled = !rootConfig[strIsCookieUseDisabled];
          }
          if (!/* @__PURE__ */ isUndefined(rootConfig[strDisableCookiesUsage])) {
            cookieEnabled = !rootConfig[strDisableCookiesUsage];
          }
          isCfgEnabled = cookieEnabled;
        }
        return isCfgEnabled;
      }
      function safeGetCookieMgr(core, config) {
        var cookieMgr;
        if (core) {
          cookieMgr = core.getCookieMgr();
        } else if (config) {
          var cookieCfg = config.cookieCfg;
          if (cookieCfg && cookieCfg[strConfigCookieMgr]) {
            cookieMgr = cookieCfg[strConfigCookieMgr];
          } else {
            cookieMgr = createCookieMgr(config);
          }
        }
        if (!cookieMgr) {
          cookieMgr = _gblCookieMgr(config, (core || {})[_DYN_LOGGER]);
        }
        return cookieMgr;
      }
      function createCookieMgr(rootConfig, logger2) {
        var cookieMgrConfig;
        var _path;
        var _domain;
        var unloadHandler;
        var _enabled;
        var _getCookieFn;
        var _setCookieFn;
        var _delCookieFn;
        rootConfig = createDynamicConfig(rootConfig || _globalCookieConfig, null, logger2).cfg;
        unloadHandler = onConfigChange(rootConfig, function(details) {
          details.setDf(details.cfg, rootDefaultConfig);
          cookieMgrConfig = details.ref(details.cfg, "cookieCfg");
          _path = cookieMgrConfig[STR_PATH] || "/";
          _domain = cookieMgrConfig[STR_DOMAIN];
          _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false;
          _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue;
          _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
          _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
        }, logger2);
        var cookieMgr = {
          isEnabled: function() {
            var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false && _enabled && areCookiesSupported(logger2);
            var gblManager = _globalCookieConfig[strConfigCookieMgr];
            if (enabled && gblManager && cookieMgr !== gblManager) {
              enabled = _isMgrEnabled(gblManager);
            }
            return enabled;
          },
          setEnabled: function(value) {
            _enabled = value !== false;
            cookieMgrConfig[_DYN_ENABLED] = value;
          },
          set: function(name, value, maxAgeSec, domain, path11) {
            var result = false;
            if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name)) {
              var values = {};
              var theValue = strTrim(value || STR_EMPTY$2);
              var idx = strIndexOf(theValue, ";");
              if (idx !== -1) {
                theValue = strTrim(/* @__PURE__ */ strLeft(value, idx));
                values = _extractParts(strSubstring(value, idx + 1));
              }
              setValue(values, STR_DOMAIN, domain || _domain, isTruthy, isUndefined);
              if (!/* @__PURE__ */ isNullOrUndefined(maxAgeSec)) {
                var _isIE = isIE();
                if (/* @__PURE__ */ isUndefined(values[strExpires])) {
                  var nowMs = /* @__PURE__ */ utcNow();
                  var expireMs = nowMs + maxAgeSec * 1e3;
                  if (expireMs > 0) {
                    var expiry = /* @__PURE__ */ new Date();
                    expiry.setTime(expireMs);
                    setValue(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || STR_EMPTY$2, isTruthy);
                  }
                }
                if (!_isIE) {
                  setValue(values, "max-age", STR_EMPTY$2 + maxAgeSec, null, isUndefined);
                }
              }
              var location_1 = getLocation();
              if (location_1 && location_1.protocol === "https:") {
                setValue(values, "secure", null, null, isUndefined);
                if (_allowUaSameSite === null) {
                  _allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT]);
                }
                if (_allowUaSameSite) {
                  setValue(values, "SameSite", "None", null, isUndefined);
                }
              }
              setValue(values, STR_PATH, path11 || _path, null, isUndefined);
              _setCookieFn(name, _formatCookieValue(theValue, values));
              result = true;
            }
            return result;
          },
          get: function(name) {
            var value = STR_EMPTY$2;
            if (_isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name)) {
              value = _getCookieFn(name);
            }
            return value;
          },
          del: function(name, path11) {
            var result = false;
            if (_isMgrEnabled(cookieMgr)) {
              result = cookieMgr.purge(name, path11);
            }
            return result;
          },
          purge: function(name, path11) {
            var _a2;
            var result = false;
            if (areCookiesSupported(logger2)) {
              var values = (_a2 = {}, _a2[STR_PATH] = path11 ? path11 : "/", _a2[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", _a2);
              if (!isIE()) {
                values["max-age"] = "0";
              }
              _delCookieFn(name, _formatCookieValue(STR_EMPTY$2, values));
              result = true;
            }
            return result;
          },
          unload: function(isAsync) {
            unloadHandler && unloadHandler.rm();
            unloadHandler = null;
          }
        };
        cookieMgr[strConfigCookieMgr] = cookieMgr;
        return cookieMgr;
      }
      function areCookiesSupported(logger2) {
        if (_supportsCookies === null) {
          _supportsCookies = false;
          !_doc && _getDoc();
          try {
            var doc = _doc.v || {};
            _supportsCookies = doc[strCookie] !== void 0;
          } catch (e) {
            _throwInternal(logger2, 2, 68, "Cannot access document.cookie - " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return _supportsCookies;
      }
      function _extractParts(theValue) {
        var values = {};
        if (theValue && theValue[_DYN_LENGTH$1]) {
          var parts = strTrim(theValue)[_DYN_SPLIT](";");
          arrForEach(parts, function(thePart) {
            thePart = strTrim(thePart || STR_EMPTY$2);
            if (thePart) {
              var idx = strIndexOf(thePart, "=");
              if (idx === -1) {
                values[thePart] = null;
              } else {
                values[strTrim(/* @__PURE__ */ strLeft(thePart, idx))] = strTrim(strSubstring(thePart, idx + 1));
              }
            }
          });
        }
        return values;
      }
      function _formatDate(theDate, func) {
        if (isFunction(theDate[func])) {
          return theDate[func]();
        }
        return null;
      }
      function _formatCookieValue(value, values) {
        var cookieValue = value || STR_EMPTY$2;
        objForEachKey(values, function(name, theValue) {
          cookieValue += "; " + name + (!/* @__PURE__ */ isNullOrUndefined(theValue) ? "=" + theValue : STR_EMPTY$2);
        });
        return cookieValue;
      }
      function _getCookieValue(name) {
        var cookieValue = STR_EMPTY$2;
        !_doc && _getDoc();
        if (_doc.v) {
          var theCookie = _doc.v[strCookie] || STR_EMPTY$2;
          if (_parsedCookieValue !== theCookie) {
            _cookieCache = _extractParts(theCookie);
            _parsedCookieValue = theCookie;
          }
          cookieValue = strTrim(_cookieCache[name] || STR_EMPTY$2);
        }
        return cookieValue;
      }
      function _setCookieValue(name, cookieValue) {
        !_doc && _getDoc();
        if (_doc.v) {
          _doc.v[strCookie] = name + "=" + cookieValue;
        }
      }
      function uaDisallowsSameSiteNone(userAgent) {
        if (!isString(userAgent)) {
          return false;
        }
        if (strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12")) {
          return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari")) {
          return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
          return true;
        }
        if (strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6")) {
          return true;
        }
        if (strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome")) {
          return true;
        }
        if (strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) {
          return true;
        }
        return false;
      }
      var defaultValues$1 = {
        perfEvtsSendAll: false
      };
      function _runScheduledListeners(asyncNotifications) {
        asyncNotifications.h = null;
        var callbacks = asyncNotifications.cb;
        asyncNotifications.cb = [];
        arrForEach(callbacks, function(cb) {
          safe(cb.fn, [cb.arg]);
        });
      }
      function _runListeners(listeners, name, asyncNotifications, callback) {
        arrForEach(listeners, function(listener) {
          if (listener && listener[name]) {
            if (asyncNotifications) {
              asyncNotifications.cb[_DYN_PUSH]({
                fn: callback,
                arg: listener
              });
              asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications);
            } else {
              safe(callback, [listener]);
            }
          }
        });
      }
      var NotificationManager = (
        /** @class */
        function() {
          function NotificationManager2(config) {
            this.listeners = [];
            var perfEvtsSendAll;
            var unloadHandler;
            var _listeners = [];
            var _asyncNotifications = {
              h: null,
              cb: []
            };
            var cfgHandler = createDynamicConfig(config, defaultValues$1);
            unloadHandler = cfgHandler[_DYN_WATCH](function(details) {
              perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
            });
            dynamicProto(NotificationManager2, this, function(_self) {
              objDefine(_self, "listeners", {
                g: function() {
                  return _listeners;
                }
              });
              _self[_DYN_ADD_NOTIFICATION_LIS1] = function(listener) {
                _listeners[_DYN_PUSH](listener);
              };
              _self[_DYN_REMOVE_NOTIFICATION_0] = function(listener) {
                var index = arrIndexOf(_listeners, listener);
                while (index > -1) {
                  _listeners[_DYN_SPLICE](index, 1);
                  index = arrIndexOf(_listeners, listener);
                }
              };
              _self[STR_EVENTS_SENT] = function(events) {
                _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function(listener) {
                  listener[STR_EVENTS_SENT](events);
                });
              };
              _self[STR_EVENTS_DISCARDED] = function(events, reason) {
                _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function(listener) {
                  listener[STR_EVENTS_DISCARDED](events, reason);
                });
              };
              _self[STR_EVENTS_SEND_REQUEST] = function(sendReason, isAsync) {
                _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function(listener) {
                  listener[STR_EVENTS_SEND_REQUEST](sendReason, isAsync);
                });
              };
              _self[STR_PERF_EVENT] = function(perfEvent) {
                if (perfEvent) {
                  if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT]()) {
                    _runListeners(_listeners, STR_PERF_EVENT, null, function(listener) {
                      if (perfEvent.isAsync) {
                        scheduleTimeout(function() {
                          return listener[STR_PERF_EVENT](perfEvent);
                        }, 0);
                      } else {
                        listener[STR_PERF_EVENT](perfEvent);
                      }
                    });
                  }
                }
              };
              _self[STR_OFFLINE_STORE] = function(events) {
                if (events && events[_DYN_LENGTH$1]) {
                  _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function(listener) {
                    listener[STR_OFFLINE_STORE](events);
                  });
                }
              };
              _self[STR_OFFLINE_SENT] = function(batch) {
                if (batch && batch[_DYN_DATA]) {
                  _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function(listener) {
                    listener[STR_OFFLINE_SENT](batch);
                  });
                }
              };
              _self[STR_OFFLINE_DROP] = function(cnt, reason) {
                if (cnt > 0) {
                  var rn_1 = reason || 0;
                  _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function(listener) {
                    listener[STR_OFFLINE_DROP](cnt, rn_1);
                  });
                }
              };
              _self[_DYN_UNLOAD] = function(isAsync) {
                var _finishUnload = function() {
                  unloadHandler && unloadHandler.rm();
                  unloadHandler = null;
                  _listeners = [];
                  _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL]();
                  _asyncNotifications.h = null;
                  _asyncNotifications.cb = [];
                };
                var waiting;
                _runListeners(_listeners, "unload", null, function(listener) {
                  var asyncUnload = listener[_DYN_UNLOAD](isAsync);
                  if (asyncUnload) {
                    if (!waiting) {
                      waiting = [];
                    }
                    waiting[_DYN_PUSH](asyncUnload);
                  }
                });
                if (waiting) {
                  return createPromise(function(resolve3) {
                    return doAwaitResponse(createAllPromise(waiting), function() {
                      _finishUnload();
                      resolve3();
                    });
                  });
                } else {
                  _finishUnload();
                }
              };
            });
          }
          NotificationManager2.__ieDyn = 1;
          return NotificationManager2;
        }()
      );
      var strExecutionContextKey = "ctx";
      var strParentContextKey = "ParentContextKey";
      var strChildrenContextKey = "ChildrenContextKey";
      var _defaultPerfManager = null;
      var PerfEvent = (
        /** @class */
        function() {
          function PerfEvent2(name, payloadDetails, isAsync) {
            var _self = this;
            _self.start = /* @__PURE__ */ utcNow();
            _self[_DYN_NAME] = name;
            _self.isAsync = isAsync;
            _self[_DYN_IS_CHILD_EVT] = function() {
              return false;
            };
            if (isFunction(payloadDetails)) {
              var theDetails_1;
              objDefine(_self, "payload", {
                g: function() {
                  if (!theDetails_1 && isFunction(payloadDetails)) {
                    theDetails_1 = payloadDetails();
                    payloadDetails = null;
                  }
                  return theDetails_1;
                }
              });
            }
            _self[_DYN_GET_CTX] = function(key) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey] || key === PerfEvent2[strChildrenContextKey]) {
                  return _self[key];
                }
                return (_self[strExecutionContextKey] || {})[key];
              }
              return null;
            };
            _self[_DYN_SET_CTX] = function(key, value) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey]) {
                  if (!_self[key]) {
                    _self[_DYN_IS_CHILD_EVT] = function() {
                      return true;
                    };
                  }
                  _self[key] = value;
                } else if (key === PerfEvent2[strChildrenContextKey]) {
                  _self[key] = value;
                } else {
                  var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                  ctx[key] = value;
                }
              }
            };
            _self.complete = function() {
              var childTime = 0;
              var childEvts = _self[_DYN_GET_CTX](PerfEvent2[strChildrenContextKey]);
              if (isArray(childEvts)) {
                for (var lp = 0; lp < childEvts[_DYN_LENGTH$1]; lp++) {
                  var childEvt = childEvts[lp];
                  if (childEvt) {
                    childTime += childEvt.time;
                  }
                }
              }
              _self.time = /* @__PURE__ */ utcNow() - _self.start;
              _self.exTime = _self.time - childTime;
              _self.complete = function() {
              };
            };
          }
          PerfEvent2.ParentContextKey = "parent";
          PerfEvent2.ChildrenContextKey = "childEvts";
          return PerfEvent2;
        }()
      );
      var PerfManager = (
        /** @class */
        function() {
          function PerfManager2(manager) {
            this.ctx = {};
            dynamicProto(PerfManager2, this, function(_self) {
              _self.create = function(src, payloadDetails, isAsync) {
                return new PerfEvent(src, payloadDetails, isAsync);
              };
              _self.fire = function(perfEvent) {
                if (perfEvent) {
                  perfEvent.complete();
                  if (manager && isFunction(manager[STR_PERF_EVENT])) {
                    manager[STR_PERF_EVENT](perfEvent);
                  }
                }
              };
              _self[_DYN_SET_CTX] = function(key, value) {
                if (key) {
                  var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                  ctx[key] = value;
                }
              };
              _self[_DYN_GET_CTX] = function(key) {
                return (_self[strExecutionContextKey] || {})[key];
              };
            });
          }
          PerfManager2.__ieDyn = 1;
          return PerfManager2;
        }()
      );
      var doPerfActiveKey = "CoreUtils.doPerf";
      function doPerf(mgrSource, getSource, func, details, isAsync) {
        if (mgrSource) {
          var perfMgr = mgrSource;
          if (perfMgr[STR_GET_PERF_MGR]) {
            perfMgr = perfMgr[STR_GET_PERF_MGR]();
          }
          if (perfMgr) {
            var perfEvt = void 0;
            var currentActive = perfMgr[_DYN_GET_CTX](doPerfActiveKey);
            try {
              perfEvt = perfMgr.create(getSource(), details, isAsync);
              if (perfEvt) {
                if (currentActive && perfEvt[_DYN_SET_CTX]) {
                  perfEvt[_DYN_SET_CTX](PerfEvent[strParentContextKey], currentActive);
                  if (currentActive[_DYN_GET_CTX] && currentActive[_DYN_SET_CTX]) {
                    var children = currentActive[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
                    if (!children) {
                      children = [];
                      currentActive[_DYN_SET_CTX](PerfEvent[strChildrenContextKey], children);
                    }
                    children[_DYN_PUSH](perfEvt);
                  }
                }
                perfMgr[_DYN_SET_CTX](doPerfActiveKey, perfEvt);
                return func(perfEvt);
              }
            } catch (ex) {
              if (perfEvt && perfEvt[_DYN_SET_CTX]) {
                perfEvt[_DYN_SET_CTX]("exception", ex);
              }
            } finally {
              if (perfEvt) {
                perfMgr.fire(perfEvt);
              }
              perfMgr[_DYN_SET_CTX](doPerfActiveKey, currentActive);
            }
          }
        }
        return func();
      }
      function getGblPerfMgr() {
        return _defaultPerfManager;
      }
      function newGuid() {
        var uuid = generateW3CId();
        return strSubstring(uuid, 0, 8) + "-" + strSubstring(uuid, 8, 12) + "-" + strSubstring(uuid, 12, 16) + "-" + strSubstring(uuid, 16, 20) + "-" + strSubstring(uuid, 20);
      }
      function generateW3CId() {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        var oct = STR_EMPTY$2, tmp;
        for (var a = 0; a < 4; a++) {
          tmp = random32();
          oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
        }
        var clockSequenceHi = hexValues[8 + (random32() & 3) | 0];
        return strSubstr(oct, 0, 8) + strSubstr(oct, 9, 4) + "4" + strSubstr(oct, 13, 3) + clockSequenceHi + strSubstr(oct, 16, 3) + strSubstr(oct, 19, 12);
      }
      var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i;
      var DEFAULT_VERSION = "00";
      var INVALID_VERSION = "ff";
      var INVALID_TRACE_ID = "00000000000000000000000000000000";
      var INVALID_SPAN_ID = "0000000000000000";
      var SAMPLED_FLAG = 1;
      function _isValid(value, len, invalidValue) {
        if (value && value[_DYN_LENGTH$1] === len && value !== invalidValue) {
          return !!value.match(/^[\da-f]*$/i);
        }
        return false;
      }
      function _formatValue(value, len, defValue) {
        if (_isValid(value, len)) {
          return value;
        }
        return defValue;
      }
      function _formatFlags(value) {
        if (isNaN(value) || value < 0 || value > 255) {
          value = 1;
        }
        var result = value.toString(16);
        while (result[_DYN_LENGTH$1] < 2) {
          result = "0" + result;
        }
        return result;
      }
      function createTraceParent(traceId, spanId, flags, version2) {
        return {
          version: _isValid(version2, 2, INVALID_VERSION) ? version2 : DEFAULT_VERSION,
          traceId: isValidTraceId(traceId) ? traceId : generateW3CId(),
          spanId: isValidSpanId(spanId) ? spanId : /* @__PURE__ */ strLeft(generateW3CId(), 16),
          traceFlags: flags >= 0 && flags <= 255 ? flags : 1
        };
      }
      function parseTraceParent(value, selectIdx) {
        if (!value) {
          return null;
        }
        if (isArray(value)) {
          value = value[0] || "";
        }
        if (!value || !isString(value) || value[_DYN_LENGTH$1] > 8192) {
          return null;
        }
        if (value[_DYN_INDEX_OF$1](",") !== -1) {
          var values = value[_DYN_SPLIT](",");
          value = values[selectIdx > 0 && values[_DYN_LENGTH$1] > selectIdx ? selectIdx : 0];
        }
        var match = TRACE_PARENT_REGEX.exec(strTrim(value));
        if (!match || match[1] === INVALID_VERSION || match[2] === INVALID_TRACE_ID || match[3] === INVALID_SPAN_ID) {
          return null;
        }
        return {
          version: (match[1] || STR_EMPTY$2)[_DYN_TO_LOWER_CASE](),
          traceId: (match[2] || STR_EMPTY$2)[_DYN_TO_LOWER_CASE](),
          spanId: (match[3] || STR_EMPTY$2)[_DYN_TO_LOWER_CASE](),
          traceFlags: parseInt(match[4], 16)
        };
      }
      function isValidTraceId(value) {
        return _isValid(value, 32, INVALID_TRACE_ID);
      }
      function isValidSpanId(value) {
        return _isValid(value, 16, INVALID_SPAN_ID);
      }
      function isValidTraceParent(value) {
        if (!value || !_isValid(value[_DYN_VERSION], 2, INVALID_VERSION) || !_isValid(value.traceId, 32, INVALID_TRACE_ID) || !_isValid(value.spanId, 16, INVALID_SPAN_ID) || !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS]), 2)) {
          return false;
        }
        return true;
      }
      function isSampledFlag(value) {
        if (isValidTraceParent(value)) {
          return (value[_DYN_TRACE_FLAGS] & SAMPLED_FLAG) === SAMPLED_FLAG;
        }
        return false;
      }
      function formatTraceParent(value) {
        if (value) {
          var flags = _formatFlags(value[_DYN_TRACE_FLAGS]);
          if (!_isValid(flags, 2)) {
            flags = "01";
          }
          var version2 = value[_DYN_VERSION] || DEFAULT_VERSION;
          if (version2 !== "00" && version2 !== "ff") {
            version2 = DEFAULT_VERSION;
          }
          return "".concat(version2.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
        }
        return "";
      }
      function findW3cTraceParent(selectIdx) {
        var name = "traceparent";
        var traceParent = parseTraceParent(findMetaTag(name), selectIdx);
        if (!traceParent) {
          traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx);
        }
        return traceParent;
      }
      var pluginStateData = createElmNodeData("plugin");
      function _getPluginState(plugin) {
        return pluginStateData.get(plugin, "state", {}, true);
      }
      function initializePlugins(processContext, extensions3) {
        var initPlugins = [];
        var lastPlugin = null;
        var proxy = processContext[_DYN_GET_NEXT]();
        var pluginState;
        while (proxy) {
          var thePlugin = proxy[_DYN_GET_PLUGIN]();
          if (thePlugin) {
            if (lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN] && thePlugin[STR_PROCESS_TELEMETRY]) {
              lastPlugin[_DYN_SET_NEXT_PLUGIN](thePlugin);
            }
            pluginState = _getPluginState(thePlugin);
            var isInitialized = !!pluginState[_DYN_IS_INITIALIZED];
            if (thePlugin[_DYN_IS_INITIALIZED]) {
              isInitialized = thePlugin[_DYN_IS_INITIALIZED]();
            }
            if (!isInitialized) {
              initPlugins[_DYN_PUSH](thePlugin);
            }
            lastPlugin = thePlugin;
            proxy = proxy[_DYN_GET_NEXT]();
          }
        }
        arrForEach(initPlugins, function(thePlugin2) {
          var core = processContext[STR_CORE]();
          thePlugin2[_DYN_INITIALIZE$1](processContext.getCfg(), core, extensions3, processContext[_DYN_GET_NEXT]());
          pluginState = _getPluginState(thePlugin2);
          if (!thePlugin2[STR_CORE] && !pluginState[STR_CORE]) {
            pluginState[STR_CORE] = core;
          }
          pluginState[_DYN_IS_INITIALIZED] = true;
          delete pluginState[_DYN_TEARDOWN];
        });
      }
      function sortPlugins(plugins) {
        return plugins.sort(function(extA, extB) {
          var result = 0;
          if (extB) {
            var bHasProcess = extB[STR_PROCESS_TELEMETRY];
            if (extA[STR_PROCESS_TELEMETRY]) {
              result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;
            } else if (bHasProcess) {
              result = -1;
            }
          } else {
            result = extA ? 1 : -1;
          }
          return result;
        });
      }
      function createDistributedTraceContext(parentCtx) {
        var trace = {};
        return {
          getName: function() {
            return trace[_DYN_NAME];
          },
          setName: function(newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DYN_NAME] = newValue;
          },
          getTraceId: function() {
            return trace.traceId;
          },
          setTraceId: function(newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if (isValidTraceId(newValue)) {
              trace.traceId = newValue;
            }
          },
          getSpanId: function() {
            return trace.spanId;
          },
          setSpanId: function(newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if (isValidSpanId(newValue)) {
              trace.spanId = newValue;
            }
          },
          getTraceFlags: function() {
            return trace[_DYN_TRACE_FLAGS];
          },
          setTraceFlags: function(newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace[_DYN_TRACE_FLAGS] = newTraceFlags;
          }
        };
      }
      var strTelemetryPluginChain = "TelemetryPluginChain";
      var strHasRunFlags = "_hasRun";
      var strGetTelCtx = "_getTelCtx";
      var _chainId = 0;
      function _getNextProxyStart(proxy, core, startAt) {
        while (proxy) {
          if (proxy[_DYN_GET_PLUGIN]() === startAt) {
            return proxy;
          }
          proxy = proxy[_DYN_GET_NEXT]();
        }
        return createTelemetryProxyChain([startAt], core.config || {}, core);
      }
      function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
        var _nextProxy = null;
        var _onComplete = [];
        if (!dynamicHandler) {
          dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER]);
        }
        if (startAt !== null) {
          _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
        }
        var context = {
          _next: _moveNext,
          ctx: {
            core: function() {
              return core;
            },
            diagLog: function() {
              return safeGetLogger(core, dynamicHandler.cfg);
            },
            getCfg: function() {
              return dynamicHandler.cfg;
            },
            getExtCfg: _resolveExtCfg,
            getConfig: _getConfig,
            hasNext: function() {
              return !!_nextProxy;
            },
            getNext: function() {
              return _nextProxy;
            },
            setNext: function(nextPlugin) {
              _nextProxy = nextPlugin;
            },
            iterate: _iterateChain,
            onComplete: _addOnComplete
          }
        };
        function _addOnComplete(onComplete, that) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          if (onComplete) {
            _onComplete[_DYN_PUSH]({
              func: onComplete,
              self: !/* @__PURE__ */ isUndefined(that) ? that : context.ctx,
              args
            });
          }
        }
        function _moveNext() {
          var nextProxy = _nextProxy;
          _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT]() : null;
          if (!nextProxy) {
            var onComplete = _onComplete;
            if (onComplete && onComplete[_DYN_LENGTH$1] > 0) {
              arrForEach(onComplete, function(completeDetails) {
                try {
                  completeDetails.func.call(completeDetails.self, completeDetails.args);
                } catch (e) {
                  _throwInternal(core[_DYN_LOGGER], 2, 73, "Unexpected Exception during onComplete - " + /* @__PURE__ */ dumpObj(e));
                }
              });
              _onComplete = [];
            }
          }
          return nextProxy;
        }
        function _getExtCfg(identifier, createIfMissing) {
          var idCfg = null;
          var cfg = dynamicHandler.cfg;
          if (cfg && identifier) {
            var extCfg = cfg[STR_EXTENSION_CONFIG];
            if (!extCfg && createIfMissing) {
              extCfg = {};
            }
            cfg[STR_EXTENSION_CONFIG] = extCfg;
            extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);
            if (extCfg) {
              idCfg = extCfg[identifier];
              if (!idCfg && createIfMissing) {
                idCfg = {};
              }
              extCfg[identifier] = idCfg;
              idCfg = dynamicHandler.ref(extCfg, identifier);
            }
          }
          return idCfg;
        }
        function _resolveExtCfg(identifier, defaultValues2) {
          var newConfig = _getExtCfg(identifier, true);
          if (defaultValues2) {
            objForEachKey(defaultValues2, function(field, defaultValue) {
              if (/* @__PURE__ */ isNullOrUndefined(newConfig[field])) {
                var cfgValue = dynamicHandler.cfg[field];
                if (cfgValue || !/* @__PURE__ */ isNullOrUndefined(cfgValue)) {
                  newConfig[field] = cfgValue;
                }
              }
              _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
            });
          }
          return dynamicHandler.setDf(newConfig, defaultValues2);
        }
        function _getConfig(identifier, field, defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = false;
          }
          var theValue;
          var extConfig = _getExtCfg(identifier, false);
          var rootConfig = dynamicHandler.cfg;
          if (extConfig && (extConfig[field] || !/* @__PURE__ */ isNullOrUndefined(extConfig[field]))) {
            theValue = extConfig[field];
          } else if (rootConfig[field] || !/* @__PURE__ */ isNullOrUndefined(rootConfig[field])) {
            theValue = rootConfig[field];
          }
          return theValue || !/* @__PURE__ */ isNullOrUndefined(theValue) ? theValue : defaultValue;
        }
        function _iterateChain(cb) {
          var nextPlugin;
          while (!!(nextPlugin = context._next())) {
            var plugin = nextPlugin[_DYN_GET_PLUGIN]();
            if (plugin) {
              cb(plugin);
            }
          }
        }
        return context;
      }
      function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
        var config = createDynamicConfig(cfg);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(env2) {
          var nextPlugin = internalContext._next();
          if (nextPlugin) {
            nextPlugin[STR_PROCESS_TELEMETRY](env2, context);
          }
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT](), config.cfg, core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(unloadState) {
          var nextPlugin = internalContext._next();
          nextPlugin && nextPlugin[_DYN_UNLOAD](context, unloadState);
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(updateState) {
          return context.iterate(function(plugin) {
            if (isFunction(plugin[_DYN_UPDATE])) {
              plugin[_DYN_UPDATE](context, updateState);
            }
          });
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createTelemetryProxyChain(plugins, config, core, startAt) {
        var firstProxy = null;
        var add = startAt ? false : true;
        if (isArray(plugins) && plugins[_DYN_LENGTH$1] > 0) {
          var lastProxy_1 = null;
          arrForEach(plugins, function(thePlugin) {
            if (!add && startAt === thePlugin) {
              add = true;
            }
            if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY])) {
              var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
              if (!firstProxy) {
                firstProxy = newProxy;
              }
              if (lastProxy_1) {
                lastProxy_1._setNext(newProxy);
              }
              lastProxy_1 = newProxy;
            }
          });
        }
        if (startAt && !firstProxy) {
          return createTelemetryProxyChain([startAt], config, core);
        }
        return firstProxy;
      }
      function createTelemetryPluginProxy(plugin, config, core) {
        var nextProxy = null;
        var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY]);
        var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN]);
        var chainId;
        if (plugin) {
          chainId = plugin[_DYN_IDENTIFIER] + "-" + plugin[STR_PRIORITY] + "-" + _chainId++;
        } else {
          chainId = "Unknown-0-" + _chainId++;
        }
        var proxyChain = {
          getPlugin: function() {
            return plugin;
          },
          getNext: function() {
            return nextProxy;
          },
          processTelemetry: _processTelemetry,
          unload: _unloadPlugin,
          update: _updatePlugin,
          _id: chainId,
          _setNext: function(nextPlugin) {
            nextProxy = nextPlugin;
          }
        };
        function _getTelCtx() {
          var itemCtx;
          if (plugin && isFunction(plugin[strGetTelCtx])) {
            itemCtx = plugin[strGetTelCtx]();
          }
          if (!itemCtx) {
            itemCtx = createProcessTelemetryContext(proxyChain, config, core);
          }
          return itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
          var hasRun = false;
          var identifier = plugin ? plugin[_DYN_IDENTIFIER] : strTelemetryPluginChain;
          var hasRunContext = itemCtx[strHasRunFlags];
          if (!hasRunContext) {
            hasRunContext = itemCtx[strHasRunFlags] = {};
          }
          itemCtx.setNext(nextProxy);
          if (plugin) {
            doPerf(itemCtx[STR_CORE](), function() {
              return identifier + ":" + name;
            }, function() {
              hasRunContext[chainId] = true;
              try {
                var nextId = nextProxy ? nextProxy._id : STR_EMPTY$2;
                if (nextId) {
                  hasRunContext[nextId] = false;
                }
                hasRun = processPluginFn(itemCtx);
              } catch (error) {
                var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                if (hasNextRun) {
                  hasRun = true;
                }
                if (!nextProxy || !hasNextRun) {
                  _throwInternal(itemCtx[_DYN_DIAG_LOG](), 1, 73, "Plugin [" + identifier + "] failed during " + name + " - " + /* @__PURE__ */ dumpObj(error) + ", run flags: " + /* @__PURE__ */ dumpObj(hasRunContext));
                }
              }
            }, details, isAsync);
          }
          return hasRun;
        }
        function _processTelemetry(env2, itemCtx) {
          itemCtx = itemCtx || _getTelCtx();
          function _callProcessTelemetry(itemCtx2) {
            if (!plugin || !hasProcessTelemetry) {
              return false;
            }
            var pluginState = _getPluginState(plugin);
            if (pluginState[_DYN_TEARDOWN] || pluginState[STR_DISABLED]) {
              return false;
            }
            if (hasSetNext) {
              plugin[_DYN_SET_NEXT_PLUGIN](nextProxy);
            }
            plugin[STR_PROCESS_TELEMETRY](env2, itemCtx2);
            return true;
          }
          if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function() {
            return { item: env2 };
          }, !env2.sync)) {
            itemCtx[_DYN_PROCESS_NEXT](env2);
          }
        }
        function _unloadPlugin(unloadCtx, unloadState) {
          function _callTeardown() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                pluginState[STR_CORE] = null;
                pluginState[_DYN_TEARDOWN] = true;
                pluginState[_DYN_IS_INITIALIZED] = false;
                if (plugin[_DYN_TEARDOWN] && plugin[_DYN_TEARDOWN](unloadCtx, unloadState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(unloadCtx, _callTeardown, "unload", function() {
          }, unloadState.isAsync)) {
            unloadCtx[_DYN_PROCESS_NEXT](unloadState);
          }
        }
        function _updatePlugin(updateCtx, updateState) {
          function _callUpdate() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                if (plugin[_DYN_UPDATE] && plugin[_DYN_UPDATE](updateCtx, updateState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(updateCtx, _callUpdate, "update", function() {
          }, false)) {
            updateCtx[_DYN_PROCESS_NEXT](updateState);
          }
        }
        return objFreeze(proxyChain);
      }
      var ProcessTelemetryContext = (
        /** @class */
        /* @__PURE__ */ function() {
          function ProcessTelemetryContext2(pluginChain, config, core, startAt) {
            var _self = this;
            var context = createProcessTelemetryContext(pluginChain, config, core, startAt);
            proxyFunctions(_self, context, objKeys(context));
          }
          return ProcessTelemetryContext2;
        }()
      );
      function createUnloadHandlerContainer() {
        var handlers = [];
        function _addHandler(handler) {
          if (handler) {
            handlers[_DYN_PUSH](handler);
          }
        }
        function _runHandlers(unloadCtx, unloadState) {
          arrForEach(handlers, function(handler) {
            try {
              handler(unloadCtx, unloadState);
            } catch (e) {
              _throwInternal(unloadCtx[_DYN_DIAG_LOG](), 2, 73, "Unexpected error calling unload handler - " + /* @__PURE__ */ dumpObj(e));
            }
          });
          handlers = [];
        }
        return {
          add: _addHandler,
          run: _runHandlers
        };
      }
      var _maxHooks;
      var _hookAddMonitor;
      function _testHookMaxUnloadHooksCb(maxHooks, addMonitor) {
        _maxHooks = maxHooks;
        _hookAddMonitor = addMonitor;
      }
      function createUnloadHookContainer() {
        var _hooks = [];
        function _doUnload(logger2) {
          var oldHooks = _hooks;
          _hooks = [];
          arrForEach(oldHooks, function(fn) {
            try {
              (fn.rm || fn.remove).call(fn);
            } catch (e) {
              _throwInternal(logger2, 2, 73, "Unloading:" + /* @__PURE__ */ dumpObj(e));
            }
          });
          if (_maxHooks && oldHooks[_DYN_LENGTH$1] > _maxHooks) {
            _hookAddMonitor ? _hookAddMonitor("doUnload", oldHooks) : _throwInternal(null, 1, 48, "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
          }
        }
        function _addHook(hooks) {
          if (hooks) {
            arrAppend(_hooks, hooks);
            if (_maxHooks && _hooks[_DYN_LENGTH$1] > _maxHooks) {
              _hookAddMonitor ? _hookAddMonitor("Add", _hooks) : _throwInternal(null, 1, 48, "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
            }
          }
        }
        return {
          run: _doUnload,
          add: _addHook
        };
      }
      var _a$2;
      var strGetPlugin = "getPlugin";
      var defaultValues = (_a$2 = {}, _a$2[STR_EXTENSION_CONFIG] = { isVal: isNotNullOrUndefined, v: {} }, _a$2);
      var BaseTelemetryPlugin = (
        /** @class */
        function() {
          function BaseTelemetryPlugin2() {
            var _self = this;
            var _isinitialized;
            var _rootCtx;
            var _nextPlugin;
            var _unloadHandlerContainer;
            var _hookContainer;
            _initDefaults();
            dynamicProto(BaseTelemetryPlugin2, _self, function(_self2) {
              _self2[_DYN_INITIALIZE$1] = function(config, core, extensions3, pluginChain) {
                _setDefaults(config, core, pluginChain);
                _isinitialized = true;
              };
              _self2[_DYN_TEARDOWN] = function(unloadCtx, unloadState) {
                var core = _self2[STR_CORE];
                if (!core || unloadCtx && core !== unloadCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var unloadDone = false;
                var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUnloadState = unloadState || {
                  reason: 0,
                  isAsync: false
                };
                function _unloadCallback() {
                  if (!unloadDone) {
                    unloadDone = true;
                    _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                    _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG]());
                    if (result === true) {
                      theUnloadCtx[_DYN_PROCESS_NEXT](theUnloadState);
                    }
                    _initDefaults();
                  }
                }
                if (!_self2[_DYN__DO_TEARDOWN] || _self2[_DYN__DO_TEARDOWN](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                  _unloadCallback();
                } else {
                  result = true;
                }
                return result;
              };
              _self2[_DYN_UPDATE] = function(updateCtx, updateState) {
                var core = _self2[STR_CORE];
                if (!core || updateCtx && core !== updateCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var updateDone = false;
                var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUpdateState = updateState || {
                  reason: 0
                };
                function _updateCallback() {
                  if (!updateDone) {
                    updateDone = true;
                    _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT]());
                  }
                }
                if (!_self2._doUpdate || _self2._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                  _updateCallback();
                } else {
                  result = true;
                }
                return result;
              };
              proxyFunctionAs(_self2, "_addUnloadCb", function() {
                return _unloadHandlerContainer;
              }, "add");
              proxyFunctionAs(_self2, "_addHook", function() {
                return _hookContainer;
              }, "add");
              objDefine(_self2, "_unloadHooks", { g: function() {
                return _hookContainer;
              } });
            });
            _self[_DYN_DIAG_LOG] = function(itemCtx) {
              return _getTelCtx(itemCtx)[_DYN_DIAG_LOG]();
            };
            _self[_DYN_IS_INITIALIZED] = function() {
              return _isinitialized;
            };
            _self.setInitialized = function(isInitialized) {
              _isinitialized = isInitialized;
            };
            _self[_DYN_SET_NEXT_PLUGIN] = function(next) {
              _nextPlugin = next;
            };
            _self[_DYN_PROCESS_NEXT] = function(env2, itemCtx) {
              if (itemCtx) {
                itemCtx[_DYN_PROCESS_NEXT](env2);
              } else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY])) {
                _nextPlugin[STR_PROCESS_TELEMETRY](env2, null);
              }
            };
            _self._getTelCtx = _getTelCtx;
            function _getTelCtx(currentCtx) {
              if (currentCtx === void 0) {
                currentCtx = null;
              }
              var itemCtx = currentCtx;
              if (!itemCtx) {
                var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE]);
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin[strGetPlugin]);
                } else {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin);
                }
              }
              return itemCtx;
            }
            function _setDefaults(config, core, pluginChain) {
              createDynamicConfig(config, defaultValues, safeGetLogger(core));
              if (!pluginChain && core) {
                pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2]()[_DYN_GET_NEXT]();
              }
              var nextPlugin = _nextPlugin;
              if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                nextPlugin = _nextPlugin[strGetPlugin]();
              }
              _self[STR_CORE] = core;
              _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
            }
            function _initDefaults() {
              _isinitialized = false;
              _self[STR_CORE] = null;
              _rootCtx = null;
              _nextPlugin = null;
              _hookContainer = createUnloadHookContainer();
              _unloadHandlerContainer = createUnloadHandlerContainer();
            }
          }
          BaseTelemetryPlugin2.__ieDyn = 1;
          return BaseTelemetryPlugin2;
        }()
      );
      function _addInitializer(_initializers, id, telemetryInitializer) {
        var theInitializer = {
          id,
          fn: telemetryInitializer
        };
        arrAppend(_initializers, theInitializer);
        var handler = {
          remove: function() {
            arrForEach(_initializers, function(initializer, idx) {
              if (initializer.id === theInitializer.id) {
                _initializers[_DYN_SPLICE](idx, 1);
                return -1;
              }
            });
          }
        };
        return handler;
      }
      function _runInitializers(_initializers, item, logger2) {
        var doNotSendItem = false;
        var telemetryInitializersCount = _initializers[_DYN_LENGTH$1];
        for (var i = 0; i < telemetryInitializersCount; ++i) {
          var telemetryInitializer = _initializers[i];
          if (telemetryInitializer) {
            try {
              if (telemetryInitializer.fn[_DYN_APPLY](null, [item]) === false) {
                doNotSendItem = true;
                break;
              }
            } catch (e) {
              _throwInternal(logger2, 2, 64, "Telemetry initializer failed: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) }, true);
            }
          }
        }
        return !doNotSendItem;
      }
      var TelemetryInitializerPlugin = (
        /** @class */
        function(_super) {
          __extendsFn(TelemetryInitializerPlugin2, _super);
          function TelemetryInitializerPlugin2() {
            var _this = _super.call(this) || this;
            _this.identifier = "TelemetryInitializerPlugin";
            _this.priority = 199;
            var _id;
            var _initializers;
            _initDefaults();
            dynamicProto(TelemetryInitializerPlugin2, _this, function(_self, _base) {
              _self.addTelemetryInitializer = function(telemetryInitializer) {
                return _addInitializer(_initializers, _id++, telemetryInitializer);
              };
              _self[STR_PROCESS_TELEMETRY] = function(item, itemCtx) {
                if (_runInitializers(_initializers, item, itemCtx ? itemCtx[_DYN_DIAG_LOG]() : _self[_DYN_DIAG_LOG]())) {
                  _self[_DYN_PROCESS_NEXT](item, itemCtx);
                }
              };
              _self[_DYN__DO_TEARDOWN] = function() {
                _initDefaults();
              };
            });
            function _initDefaults() {
              _id = 0;
              _initializers = [];
            }
            return _this;
          }
          TelemetryInitializerPlugin2.__ieDyn = 1;
          return TelemetryInitializerPlugin2;
        }(BaseTelemetryPlugin)
      );
      var _a$1;
      var strValidationError = "Plugins must provide initialize method";
      var strNotificationManager = "_notificationManager";
      var strSdkUnloadingError = "SDK is still unloading...";
      var strSdkNotInitialized = "SDK is not initialized";
      var maxInitQueueSize = 100;
      var maxInitTimeout = 5e4;
      var defaultConfig$1 = objDeepFreeze((_a$1 = {
        cookieCfg: {}
      }, _a$1[STR_EXTENSIONS] = { rdOnly: true, ref: true, v: [] }, _a$1[STR_CHANNELS] = { rdOnly: true, ref: true, v: [] }, _a$1[STR_EXTENSION_CONFIG] = { ref: true, v: {} }, _a$1[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE, _a$1.loggingLevelConsole = 0, _a$1.diagnosticLogInterval = UNDEFINED_VALUE, _a$1));
      function _createPerfManager(core, notificationMgr) {
        return new PerfManager(notificationMgr);
      }
      function _validateExtensions(logger2, channelPriority, allExtensions) {
        var coreExtensions = [];
        var channels = [];
        var extPriorities = {};
        arrForEach(allExtensions, function(ext) {
          if (/* @__PURE__ */ isNullOrUndefined(ext) || /* @__PURE__ */ isNullOrUndefined(ext[_DYN_INITIALIZE$1])) {
            throwError(strValidationError);
          }
          var extPriority = ext[STR_PRIORITY];
          var identifier = ext[_DYN_IDENTIFIER];
          if (ext && extPriority) {
            if (!/* @__PURE__ */ isNullOrUndefined(extPriorities[extPriority])) {
              _warnToConsole(logger2, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
            } else {
              extPriorities[extPriority] = identifier;
            }
          }
          if (!extPriority || extPriority < channelPriority) {
            coreExtensions[_DYN_PUSH](ext);
          } else {
            channels[_DYN_PUSH](ext);
          }
        });
        return {
          core: coreExtensions,
          channels
        };
      }
      function _isPluginPresent(thePlugin, plugins) {
        var exists = false;
        arrForEach(plugins, function(plugin) {
          if (plugin === thePlugin) {
            exists = true;
            return -1;
          }
        });
        return exists;
      }
      function _deepMergeConfig(details, target, newValues, merge) {
        if (newValues) {
          objForEachKey(newValues, function(key, value) {
            if (merge) {
              if (/* @__PURE__ */ isPlainObject(value) && /* @__PURE__ */ isPlainObject(target[key])) {
                _deepMergeConfig(details, target[key], value, merge);
              }
            }
            if (merge && /* @__PURE__ */ isPlainObject(value) && /* @__PURE__ */ isPlainObject(target[key])) {
              _deepMergeConfig(details, target[key], value, merge);
            } else {
              details.set(target, key, value);
            }
          });
        }
      }
      function _findWatcher(listeners, newWatcher) {
        var theListener = null;
        var idx = -1;
        arrForEach(listeners, function(listener, lp) {
          if (listener.w === newWatcher) {
            theListener = listener;
            idx = lp;
            return -1;
          }
        });
        return { i: idx, l: theListener };
      }
      function _addDelayedCfgListener(listeners, newWatcher) {
        var theListener = _findWatcher(listeners, newWatcher).l;
        if (!theListener) {
          theListener = {
            w: newWatcher,
            rm: function() {
              var fnd = _findWatcher(listeners, newWatcher);
              if (fnd.i !== -1) {
                listeners[_DYN_SPLICE](fnd.i, 1);
              }
            }
          };
          listeners[_DYN_PUSH](theListener);
        }
        return theListener;
      }
      function _registerDelayedCfgListener(config, listeners, logger2) {
        arrForEach(listeners, function(listener) {
          var unloadHdl = onConfigChange(config, listener.w, logger2);
          delete listener.w;
          listener.rm = function() {
            unloadHdl.rm();
          };
        });
      }
      function _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {
        unloadContainer.add(configHandler[_DYN_WATCH](function(details) {
          var disableDbgExt = details.cfg.disableDbgExt;
          if (disableDbgExt === true && debugListener) {
            notificationManager[_DYN_REMOVE_NOTIFICATION_0](debugListener);
            debugListener = null;
          }
          if (notificationManager && !debugListener && disableDbgExt !== true) {
            debugListener = getDebugListener(details.cfg);
            notificationManager[_DYN_ADD_NOTIFICATION_LIS1](debugListener);
          }
        }));
        return debugListener;
      }
      function _createUnloadHook(unloadHook) {
        return objDefine({
          rm: function() {
            unloadHook.rm();
          }
        }, "toJSON", { v: function() {
          return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">";
        } });
      }
      var AppInsightsCore$1 = (
        /** @class */
        function() {
          function AppInsightsCore2() {
            var _configHandler;
            var _isInitialized;
            var _logger;
            var _eventQueue;
            var _notificationManager;
            var _perfManager;
            var _cfgPerfManager;
            var _cookieManager;
            var _pluginChain;
            var _configExtensions;
            var _channelConfig;
            var _channels;
            var _isUnloading;
            var _telemetryInitializerPlugin;
            var _internalLogsEventName;
            var _evtNamespace;
            var _unloadHandlers;
            var _hookContainer;
            var _debugListener2;
            var _traceCtx;
            var _instrumentationKey;
            var _cfgListeners;
            var _extensions;
            var _pluginVersionStringArr;
            var _pluginVersionString;
            var _activeStatus;
            var _endpoint;
            var _initInMemoMaxSize;
            var _isStatusSet;
            var _initTimer;
            var _internalLogPoller;
            var _internalLogPollerListening;
            var _forceStopInternalLogPoller;
            dynamicProto(AppInsightsCore2, this, function(_self) {
              _initDefaults();
              _self["_getDbgPlgTargets"] = function() {
                return [_extensions, _eventQueue];
              };
              _self[_DYN_IS_INITIALIZED] = function() {
                return _isInitialized;
              };
              _self.activeStatus = function() {
                return _activeStatus;
              };
              _self._setPendingStatus = function() {
                _activeStatus = 3;
              };
              _self[_DYN_INITIALIZE$1] = function(config, extensions3, logger2, notificationManager) {
                if (_isUnloading) {
                  throwError(strSdkUnloadingError);
                }
                if (_self[_DYN_IS_INITIALIZED]()) {
                  throwError("Core cannot be initialized more than once");
                }
                _configHandler = createDynamicConfig(config, defaultConfig$1, logger2 || _self[_DYN_LOGGER], false);
                config = _configHandler.cfg;
                _addUnloadHook(_configHandler[_DYN_WATCH](function(details) {
                  var rootCfg = details.cfg;
                  _initInMemoMaxSize = rootCfg.initInMemoMaxSize || maxInitQueueSize;
                  _handleIKeyEndpointPromises(rootCfg);
                  var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);
                  objForEachKey(extCfg, function(key) {
                    details.ref(extCfg, key);
                  });
                }));
                _notificationManager = notificationManager;
                _debugListener2 = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DYN_GET_NOTIFY_MGR](), _debugListener2);
                _initPerfManager();
                _self[_DYN_LOGGER] = logger2;
                var cfgExtensions = config[STR_EXTENSIONS];
                _configExtensions = [];
                _configExtensions[_DYN_PUSH].apply(_configExtensions, __spreadArrayFn(__spreadArrayFn([], extensions3, false), cfgExtensions));
                _channelConfig = config[STR_CHANNELS];
                _initPluginChain(null);
                if (!_channels || _channels[_DYN_LENGTH$1] === 0) {
                  throwError("No " + STR_CHANNELS + " available");
                }
                if (_channelConfig && _channelConfig[_DYN_LENGTH$1] > 1) {
                  var teeController = _self[_DYN_GET_PLUGIN]("TeeChannelController");
                  if (!teeController || !teeController.plugin) {
                    _throwInternal(_logger, 1, 28, "TeeChannel required");
                  }
                }
                _registerDelayedCfgListener(config, _cfgListeners, _logger);
                _cfgListeners = null;
                _isInitialized = true;
                if (_activeStatus === ActiveStatus.ACTIVE) {
                  _releaseQueues();
                }
              };
              _self.getChannels = function() {
                var controls = [];
                if (_channels) {
                  arrForEach(_channels, function(channel) {
                    controls[_DYN_PUSH](channel);
                  });
                }
                return objFreeze(controls);
              };
              _self.track = function(telemetryItem) {
                doPerf(_self[STR_GET_PERF_MGR](), function() {
                  return "AppInsightsCore:track";
                }, function() {
                  if (telemetryItem === null) {
                    _notifyInvalidEvent(telemetryItem);
                    throwError("Invalid telemetry item");
                  }
                  if (!telemetryItem[_DYN_NAME] && /* @__PURE__ */ isNullOrUndefined(telemetryItem[_DYN_NAME])) {
                    _notifyInvalidEvent(telemetryItem);
                    throwError("telemetry name required");
                  }
                  telemetryItem.iKey = telemetryItem.iKey || _instrumentationKey;
                  telemetryItem.time = telemetryItem.time || toISOString(/* @__PURE__ */ new Date());
                  telemetryItem.ver = telemetryItem.ver || "4.0";
                  if (!_isUnloading && _self[_DYN_IS_INITIALIZED]() && _activeStatus === ActiveStatus.ACTIVE) {
                    _createTelCtx()[_DYN_PROCESS_NEXT](telemetryItem);
                  } else if (_activeStatus !== ActiveStatus.INACTIVE) {
                    if (_eventQueue[_DYN_LENGTH$1] <= _initInMemoMaxSize) {
                      _eventQueue[_DYN_PUSH](telemetryItem);
                    }
                  }
                }, function() {
                  return { item: telemetryItem };
                }, !telemetryItem.sync);
              };
              _self[_DYN_GET_PROCESS_TEL_CONT2] = _createTelCtx;
              _self[_DYN_GET_NOTIFY_MGR] = function() {
                if (!_notificationManager) {
                  _notificationManager = new NotificationManager(_configHandler.cfg);
                  _self[strNotificationManager] = _notificationManager;
                }
                return _notificationManager;
              };
              _self[_DYN_ADD_NOTIFICATION_LIS1] = function(listener) {
                _self.getNotifyMgr()[_DYN_ADD_NOTIFICATION_LIS1](listener);
              };
              _self[_DYN_REMOVE_NOTIFICATION_0] = function(listener) {
                if (_notificationManager) {
                  _notificationManager[_DYN_REMOVE_NOTIFICATION_0](listener);
                }
              };
              _self.getCookieMgr = function() {
                if (!_cookieManager) {
                  _cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER]);
                }
                return _cookieManager;
              };
              _self.setCookieMgr = function(cookieMgr) {
                if (_cookieManager !== cookieMgr) {
                  runTargetUnload(_cookieManager, false);
                  _cookieManager = cookieMgr;
                }
              };
              _self[STR_GET_PERF_MGR] = function() {
                return _perfManager || _cfgPerfManager || getGblPerfMgr();
              };
              _self.setPerfMgr = function(perfMgr) {
                _perfManager = perfMgr;
              };
              _self.eventCnt = function() {
                return _eventQueue[_DYN_LENGTH$1];
              };
              _self.releaseQueue = function() {
                if (_isInitialized && _eventQueue[_DYN_LENGTH$1] > 0) {
                  var eventQueue = _eventQueue;
                  _eventQueue = [];
                  if (_activeStatus === 2) {
                    arrForEach(eventQueue, function(event) {
                      event.iKey = event.iKey || _instrumentationKey;
                      _createTelCtx()[_DYN_PROCESS_NEXT](event);
                    });
                  } else {
                    _throwInternal(_logger, 2, 20, "core init status is not active");
                  }
                }
              };
              _self.pollInternalLogs = function(eventName) {
                _internalLogsEventName = eventName || null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller && _internalLogPoller[_DYN_CANCEL]();
                return _startLogPoller(true);
              };
              function _handleIKeyEndpointPromises(theConfig) {
                var ikey = theConfig.instrumentationKey;
                var endpointUrl = theConfig.endpointUrl;
                if (_activeStatus !== 3) {
                  if (/* @__PURE__ */ isNullOrUndefined(ikey)) {
                    _instrumentationKey = null;
                    _activeStatus = ActiveStatus.INACTIVE;
                    var msg = "Please provide instrumentation key";
                    if (!_isInitialized) {
                      throwError(msg);
                    } else {
                      _throwInternal(_logger, 1, 100, msg);
                      _releaseQueues();
                    }
                    return;
                  }
                  var promises = [];
                  if (/* @__PURE__ */ isPromiseLike(ikey)) {
                    promises[_DYN_PUSH](ikey);
                    _instrumentationKey = null;
                  } else {
                    _instrumentationKey = ikey;
                  }
                  if (/* @__PURE__ */ isPromiseLike(endpointUrl)) {
                    promises[_DYN_PUSH](endpointUrl);
                    _endpoint = null;
                  } else {
                    _endpoint = endpointUrl;
                  }
                  if (promises[_DYN_LENGTH$1]) {
                    _waitForInitPromises(theConfig, promises);
                  } else {
                    _setStatus();
                  }
                }
              }
              function _waitForInitPromises(theConfig, promises) {
                _isStatusSet = false;
                _activeStatus = 3;
                var initTimeout = isNotNullOrUndefined(theConfig.initTimeOut) ? theConfig.initTimeOut : maxInitTimeout;
                var allPromises = createSyncAllSettledPromise(promises);
                if (_initTimer) {
                  _initTimer[_DYN_CANCEL]();
                }
                _initTimer = scheduleTimeout(function() {
                  _initTimer = null;
                  if (!_isStatusSet) {
                    _setStatus();
                  }
                }, initTimeout);
                doAwaitResponse(allPromises, function(response) {
                  try {
                    if (_isStatusSet) {
                      return;
                    }
                    if (!response.rejected) {
                      var values = response[_DYN_VALUE$1];
                      if (values && values[_DYN_LENGTH$1]) {
                        var ikeyRes = values[0];
                        _instrumentationKey = ikeyRes && ikeyRes[_DYN_VALUE$1];
                        if (values[_DYN_LENGTH$1] > 1) {
                          var endpointRes = values[1];
                          _endpoint = endpointRes && endpointRes[_DYN_VALUE$1];
                        }
                      }
                      if (_instrumentationKey) {
                        theConfig.instrumentationKey = _instrumentationKey;
                        theConfig.endpointUrl = _endpoint;
                      }
                    }
                    _setStatus();
                  } catch (e) {
                    if (!_isStatusSet) {
                      _setStatus();
                    }
                  }
                });
              }
              function _setStatus() {
                _isStatusSet = true;
                if (/* @__PURE__ */ isNullOrUndefined(_instrumentationKey)) {
                  _activeStatus = ActiveStatus.INACTIVE;
                  _throwInternal(_logger, 1, 112, "ikey can't be resolved from promises");
                } else {
                  _activeStatus = ActiveStatus.ACTIVE;
                }
                _releaseQueues();
              }
              function _releaseQueues() {
                if (_isInitialized) {
                  _self.releaseQueue();
                  _self.pollInternalLogs();
                }
              }
              function _startLogPoller(alwaysStart) {
                if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED]) && !_forceStopInternalLogPoller) {
                  var shouldStart = alwaysStart || _logger && _logger.queue[_DYN_LENGTH$1] > 0;
                  if (shouldStart) {
                    if (!_internalLogPollerListening) {
                      _internalLogPollerListening = true;
                      _addUnloadHook(_configHandler[_DYN_WATCH](function(details) {
                        var interval = details.cfg.diagnosticLogInterval;
                        if (!interval || !(interval > 0)) {
                          interval = 1e4;
                        }
                        var isRunning = false;
                        if (_internalLogPoller) {
                          isRunning = _internalLogPoller[_DYN_ENABLED];
                          _internalLogPoller[_DYN_CANCEL]();
                        }
                        _internalLogPoller = createTimeout(_flushInternalLogs, interval);
                        _internalLogPoller.unref();
                        _internalLogPoller[_DYN_ENABLED] = isRunning;
                      }));
                    }
                    _internalLogPoller[_DYN_ENABLED] = true;
                  }
                }
                return _internalLogPoller;
              }
              _self[_DYN_STOP_POLLING_INTERNA3] = function() {
                _forceStopInternalLogPoller = true;
                _internalLogPoller && _internalLogPoller[_DYN_CANCEL]();
                _flushInternalLogs();
              };
              proxyFunctions(_self, function() {
                return _telemetryInitializerPlugin;
              }, ["addTelemetryInitializer"]);
              _self[_DYN_UNLOAD] = function(isAsync, unloadComplete, cbTimeout) {
                if (isAsync === void 0) {
                  isAsync = true;
                }
                if (!_isInitialized) {
                  throwError(strSdkNotInitialized);
                }
                if (_isUnloading) {
                  throwError(strSdkUnloadingError);
                }
                var unloadState = {
                  reason: 50,
                  isAsync,
                  flushComplete: false
                };
                var result;
                if (isAsync && !unloadComplete) {
                  result = createPromise(function(resolve3) {
                    unloadComplete = resolve3;
                  });
                }
                var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);
                processUnloadCtx[_DYN_ON_COMPLETE](function() {
                  _hookContainer.run(_self[_DYN_LOGGER]);
                  doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function() {
                    _initDefaults();
                    unloadComplete && unloadComplete(unloadState);
                  });
                }, _self);
                function _doUnload(flushComplete) {
                  unloadState.flushComplete = flushComplete;
                  _isUnloading = true;
                  _unloadHandlers.run(processUnloadCtx, unloadState);
                  _self[_DYN_STOP_POLLING_INTERNA3]();
                  processUnloadCtx[_DYN_PROCESS_NEXT](unloadState);
                }
                _flushInternalLogs();
                if (!_flushChannels(isAsync, _doUnload, 6, cbTimeout)) ;
                return result;
              };
              _self[_DYN_GET_PLUGIN] = _getPlugin;
              _self.addPlugin = function(plugin, replaceExisting, isAsync, addCb) {
                if (!plugin) {
                  addCb && addCb(false);
                  _logOrThrowError(strValidationError);
                  return;
                }
                var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER]);
                if (existingPlugin && !replaceExisting) {
                  addCb && addCb(false);
                  _logOrThrowError("Plugin [" + plugin[_DYN_IDENTIFIER] + "] is already loaded!");
                  return;
                }
                var updateState = {
                  reason: 16
                };
                function _addPlugin(removed) {
                  _configExtensions[_DYN_PUSH](plugin);
                  updateState.added = [plugin];
                  _initPluginChain(updateState);
                  addCb && addCb(true);
                }
                if (existingPlugin) {
                  var removedPlugins_1 = [existingPlugin.plugin];
                  var unloadState = {
                    reason: 2,
                    isAsync: !!isAsync
                  };
                  _removePlugins(removedPlugins_1, unloadState, function(removed) {
                    if (!removed) {
                      addCb && addCb(false);
                    } else {
                      updateState.removed = removedPlugins_1;
                      updateState.reason |= 32;
                      _addPlugin();
                    }
                  });
                } else {
                  _addPlugin();
                }
              };
              _self.updateCfg = function(newConfig, mergeExisting) {
                if (mergeExisting === void 0) {
                  mergeExisting = true;
                }
                var updateState;
                if (_self[_DYN_IS_INITIALIZED]()) {
                  updateState = {
                    reason: 1,
                    cfg: _configHandler.cfg,
                    oldCfg: deepExtend({}, _configHandler.cfg),
                    newConfig: deepExtend({}, newConfig),
                    merge: mergeExisting
                  };
                  newConfig = updateState.newConfig;
                  var cfg = _configHandler.cfg;
                  newConfig[STR_EXTENSIONS] = cfg[STR_EXTENSIONS];
                  newConfig[STR_CHANNELS] = cfg[STR_CHANNELS];
                }
                _configHandler._block(function(details) {
                  var theConfig = details.cfg;
                  _deepMergeConfig(details, theConfig, newConfig, mergeExisting);
                  if (!mergeExisting) {
                    objForEachKey(theConfig, function(key) {
                      if (!objHasOwn(newConfig, key)) {
                        details.set(theConfig, key, UNDEFINED_VALUE);
                      }
                    });
                  }
                  details.setDf(theConfig, defaultConfig$1);
                }, true);
                _configHandler.notify();
                if (updateState) {
                  _doUpdate(updateState);
                }
              };
              _self.evtNamespace = function() {
                return _evtNamespace;
              };
              _self.flush = _flushChannels;
              _self.getTraceCtx = function(createNew) {
                if (!_traceCtx) {
                  _traceCtx = createDistributedTraceContext();
                }
                return _traceCtx;
              };
              _self.setTraceCtx = function(traceCtx) {
                _traceCtx = traceCtx || null;
              };
              _self.addUnloadHook = _addUnloadHook;
              proxyFunctionAs(_self, "addUnloadCb", function() {
                return _unloadHandlers;
              }, "add");
              _self.onCfgChange = function(handler) {
                var unloadHook;
                if (!_isInitialized) {
                  unloadHook = _addDelayedCfgListener(_cfgListeners, handler);
                } else {
                  unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER]);
                }
                return _createUnloadHook(unloadHook);
              };
              _self.getWParam = function() {
                return /* @__PURE__ */ hasDocument() || !!_configHandler.cfg.enableWParam ? 0 : -1;
              };
              function _setPluginVersions() {
                var thePlugins = {};
                _pluginVersionStringArr = [];
                var _addPluginVersions = function(plugins) {
                  if (plugins) {
                    arrForEach(plugins, function(plugin) {
                      if (plugin[_DYN_IDENTIFIER] && plugin[_DYN_VERSION] && !thePlugins[plugin.identifier]) {
                        var ver = plugin[_DYN_IDENTIFIER] + "=" + plugin[_DYN_VERSION];
                        _pluginVersionStringArr[_DYN_PUSH](ver);
                        thePlugins[plugin.identifier] = plugin;
                      }
                    });
                  }
                };
                _addPluginVersions(_channels);
                if (_channelConfig) {
                  arrForEach(_channelConfig, function(channels) {
                    _addPluginVersions(channels);
                  });
                }
                _addPluginVersions(_configExtensions);
              }
              function _initDefaults() {
                _isInitialized = false;
                _configHandler = createDynamicConfig({}, defaultConfig$1, _self[_DYN_LOGGER]);
                _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4] = 1;
                objDefine(_self, "config", {
                  g: function() {
                    return _configHandler.cfg;
                  },
                  s: function(newValue) {
                    _self.updateCfg(newValue, false);
                  }
                });
                objDefine(_self, "pluginVersionStringArr", {
                  g: function() {
                    if (!_pluginVersionStringArr) {
                      _setPluginVersions();
                    }
                    return _pluginVersionStringArr;
                  }
                });
                objDefine(_self, "pluginVersionString", {
                  g: function() {
                    if (!_pluginVersionString) {
                      if (!_pluginVersionStringArr) {
                        _setPluginVersions();
                      }
                      _pluginVersionString = _pluginVersionStringArr.join(";");
                    }
                    return _pluginVersionString || STR_EMPTY$2;
                  }
                });
                objDefine(_self, "logger", {
                  g: function() {
                    if (!_logger) {
                      _logger = new DiagnosticLogger(_configHandler.cfg);
                      _configHandler[_DYN_LOGGER] = _logger;
                    }
                    return _logger;
                  },
                  s: function(newLogger) {
                    _configHandler[_DYN_LOGGER] = newLogger;
                    if (_logger !== newLogger) {
                      runTargetUnload(_logger, false);
                      _logger = newLogger;
                    }
                  }
                });
                _self[_DYN_LOGGER] = new DiagnosticLogger(_configHandler.cfg);
                _extensions = [];
                var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
                cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$1]);
                arrAppend(cfgExtensions, _extensions);
                _telemetryInitializerPlugin = new TelemetryInitializerPlugin();
                _eventQueue = [];
                runTargetUnload(_notificationManager, false);
                _notificationManager = null;
                _perfManager = null;
                _cfgPerfManager = null;
                runTargetUnload(_cookieManager, false);
                _cookieManager = null;
                _pluginChain = null;
                _configExtensions = [];
                _channelConfig = null;
                _channels = null;
                _isUnloading = false;
                _internalLogsEventName = null;
                _evtNamespace = createUniqueNamespace("AIBaseCore", true);
                _unloadHandlers = createUnloadHandlerContainer();
                _traceCtx = null;
                _instrumentationKey = null;
                _hookContainer = createUnloadHookContainer();
                _cfgListeners = [];
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller = null;
                _internalLogPollerListening = false;
                _activeStatus = 0;
                _endpoint = null;
                _initInMemoMaxSize = null;
                _isStatusSet = false;
                _initTimer = null;
              }
              function _createTelCtx() {
                var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);
                theCtx[_DYN_ON_COMPLETE](_startLogPoller);
                return theCtx;
              }
              function _initPluginChain(updateState) {
                var theExtensions = _validateExtensions(_self[_DYN_LOGGER], ChannelControllerPriority, _configExtensions);
                _pluginChain = null;
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                _channels = (_channelConfig || [])[0] || [];
                _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS]));
                var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE]), _channels);
                _extensions = objFreeze(allExtensions);
                var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
                cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$1]);
                arrAppend(cfgExtensions, _extensions);
                var rootCtx = _createTelCtx();
                if (_channels && _channels[_DYN_LENGTH$1] > 0) {
                  initializePlugins(rootCtx[_DYN_CREATE_NEW](_channels), allExtensions);
                }
                initializePlugins(rootCtx, allExtensions);
                if (updateState) {
                  _doUpdate(updateState);
                }
              }
              function _getPlugin(pluginIdentifier) {
                var theExt = null;
                var thePlugin = null;
                var channelHosts = [];
                arrForEach(_extensions, function(ext) {
                  if (ext[_DYN_IDENTIFIER] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {
                    thePlugin = ext;
                    return -1;
                  }
                  if (ext.getChannel) {
                    channelHosts[_DYN_PUSH](ext);
                  }
                });
                if (!thePlugin && channelHosts[_DYN_LENGTH$1] > 0) {
                  arrForEach(channelHosts, function(host) {
                    thePlugin = host.getChannel(pluginIdentifier);
                    if (!thePlugin) {
                      return -1;
                    }
                  });
                }
                if (thePlugin) {
                  theExt = {
                    plugin: thePlugin,
                    setEnabled: function(enabled) {
                      _getPluginState(thePlugin)[STR_DISABLED] = !enabled;
                    },
                    isEnabled: function() {
                      var pluginState = _getPluginState(thePlugin);
                      return !pluginState[_DYN_TEARDOWN] && !pluginState[STR_DISABLED];
                    },
                    remove: function(isAsync, removeCb) {
                      if (isAsync === void 0) {
                        isAsync = true;
                      }
                      var pluginsToRemove = [thePlugin];
                      var unloadState = {
                        reason: 1,
                        isAsync
                      };
                      _removePlugins(pluginsToRemove, unloadState, function(removed) {
                        if (removed) {
                          _initPluginChain({
                            reason: 32,
                            removed: pluginsToRemove
                          });
                        }
                        removeCb && removeCb(removed);
                      });
                    }
                  };
                }
                return theExt;
              }
              function _getPluginChain() {
                if (!_pluginChain) {
                  var extensions3 = (_extensions || []).slice();
                  if (arrIndexOf(extensions3, _telemetryInitializerPlugin) === -1) {
                    extensions3[_DYN_PUSH](_telemetryInitializerPlugin);
                  }
                  _pluginChain = createTelemetryProxyChain(sortPlugins(extensions3), _configHandler.cfg, _self);
                }
                return _pluginChain;
              }
              function _removePlugins(thePlugins, unloadState, removeComplete) {
                if (thePlugins && thePlugins[_DYN_LENGTH$1] > 0) {
                  var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self);
                  var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);
                  unloadCtx[_DYN_ON_COMPLETE](function() {
                    var removed = false;
                    var newConfigExtensions = [];
                    arrForEach(_configExtensions, function(plugin, idx) {
                      if (!_isPluginPresent(plugin, thePlugins)) {
                        newConfigExtensions[_DYN_PUSH](plugin);
                      } else {
                        removed = true;
                      }
                    });
                    _configExtensions = newConfigExtensions;
                    _pluginVersionString = null;
                    _pluginVersionStringArr = null;
                    var newChannelConfig = [];
                    if (_channelConfig) {
                      arrForEach(_channelConfig, function(queue, idx) {
                        var newQueue = [];
                        arrForEach(queue, function(channel) {
                          if (!_isPluginPresent(channel, thePlugins)) {
                            newQueue[_DYN_PUSH](channel);
                          } else {
                            removed = true;
                          }
                        });
                        newChannelConfig[_DYN_PUSH](newQueue);
                      });
                      _channelConfig = newChannelConfig;
                    }
                    removeComplete && removeComplete(removed);
                    _startLogPoller();
                  });
                  unloadCtx[_DYN_PROCESS_NEXT](unloadState);
                } else {
                  removeComplete(false);
                }
              }
              function _flushInternalLogs() {
                if (_logger && _logger.queue) {
                  var queue = _logger.queue.slice(0);
                  _logger.queue[_DYN_LENGTH$1] = 0;
                  arrForEach(queue, function(logMessage) {
                    var item = {
                      name: _internalLogsEventName ? _internalLogsEventName : "InternalMessageId: " + logMessage[_DYN_MESSAGE_ID],
                      iKey: _instrumentationKey,
                      time: toISOString(/* @__PURE__ */ new Date()),
                      baseType: _InternalLogMessage.dataType,
                      baseData: { message: logMessage[_DYN_MESSAGE] }
                    };
                    _self.track(item);
                  });
                }
              }
              function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
                var waiting = 1;
                var doneIterating = false;
                var cbTimer = null;
                cbTimeout = cbTimeout || 5e3;
                function doCallback() {
                  waiting--;
                  if (doneIterating && waiting === 0) {
                    cbTimer && cbTimer[_DYN_CANCEL]();
                    cbTimer = null;
                    callBack && callBack(doneIterating);
                    callBack = null;
                  }
                }
                if (_channels && _channels[_DYN_LENGTH$1] > 0) {
                  var flushCtx = _createTelCtx()[_DYN_CREATE_NEW](_channels);
                  flushCtx.iterate(function(plugin) {
                    if (plugin.flush) {
                      waiting++;
                      var handled_1 = false;
                      if (!plugin.flush(isAsync, function() {
                        handled_1 = true;
                        doCallback();
                      }, sendReason)) {
                        if (!handled_1) {
                          if (isAsync && cbTimer == null) {
                            cbTimer = scheduleTimeout(function() {
                              cbTimer = null;
                              doCallback();
                            }, cbTimeout);
                          } else {
                            doCallback();
                          }
                        }
                      }
                    }
                  });
                }
                doneIterating = true;
                doCallback();
                return true;
              }
              function _initPerfManager() {
                var prevCfgPerfMgr;
                _addUnloadHook(_configHandler[_DYN_WATCH](function(details) {
                  var enablePerfMgr = details.cfg.enablePerfMgr;
                  if (enablePerfMgr) {
                    var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR];
                    if (prevCfgPerfMgr !== createPerfMgr || !prevCfgPerfMgr) {
                      if (!createPerfMgr) {
                        createPerfMgr = _createPerfManager;
                      }
                      getSetValue(details.cfg, STR_CREATE_PERF_MGR, createPerfMgr);
                      prevCfgPerfMgr = createPerfMgr;
                      _cfgPerfManager = null;
                    }
                    if (!_perfManager && !_cfgPerfManager && isFunction(createPerfMgr)) {
                      _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR]());
                    }
                  } else {
                    _cfgPerfManager = null;
                    prevCfgPerfMgr = null;
                  }
                }));
              }
              function _doUpdate(updateState) {
                var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);
                updateCtx[_DYN_ON_COMPLETE](_startLogPoller);
                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {
                  updateCtx[_DYN_PROCESS_NEXT](updateState);
                }
              }
              function _logOrThrowError(message) {
                var logger2 = _self[_DYN_LOGGER];
                if (logger2) {
                  _throwInternal(logger2, 2, 73, message);
                  _startLogPoller();
                } else {
                  throwError(message);
                }
              }
              function _notifyInvalidEvent(telemetryItem) {
                var manager = _self[_DYN_GET_NOTIFY_MGR]();
                if (manager) {
                  manager[STR_EVENTS_DISCARDED]([telemetryItem], 2);
                }
              }
              function _addUnloadHook(hooks) {
                _hookContainer.add(hooks);
              }
            });
          }
          AppInsightsCore2.__ieDyn = 1;
          return AppInsightsCore2;
        }()
      );
      function parseResponse(response, diagLog) {
        try {
          if (response && response !== "") {
            var result = getJSON().parse(response);
            if (result && result[_DYN_ITEMS_RECEIVED] && result[_DYN_ITEMS_RECEIVED] >= result.itemsAccepted && result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH$1]) {
              return result;
            }
          }
        } catch (e) {
          _throwInternal(diagLog, 1, 43, "Cannot parse the response. " + (e[_DYN_NAME] || /* @__PURE__ */ dumpObj(e)), {
            response
          });
        }
        return null;
      }
      var STR_EMPTY$1 = "";
      var STR_NO_RESPONSE_BODY = "NoResponseBody";
      var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
      var STR_POST_METHOD = "POST";
      var SenderPostManager = (
        /** @class */
        function() {
          function SenderPostManager2() {
            var _syncFetchPayload = 0;
            var _enableSendPromise;
            var _isInitialized;
            var _diagLog;
            var _isOneDs;
            var _onCompleteFuncs;
            var _disableCredentials;
            var _fetchCredentials;
            var _fallbackInst;
            var _disableXhr;
            var _disableBeacon;
            var _disableBeaconSync;
            var _disableFetchKeepAlive;
            var _addNoResponse;
            var _timeoutWrapper;
            dynamicProto(SenderPostManager2, this, function(_self, _base) {
              var _sendCredentials = true;
              _initDefaults();
              _self[_DYN_INITIALIZE$1] = function(config, diagLog) {
                _diagLog = diagLog;
                if (_isInitialized) {
                  _throwInternal(_diagLog, 1, 28, "Sender is already initialized");
                }
                _self.SetConfig(config);
                _isInitialized = true;
              };
              _self["_getDbgPlgTargets"] = function() {
                return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
              };
              _self.SetConfig = function(config) {
                try {
                  _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                  _disableCredentials = !!config.disableCredentials;
                  _fetchCredentials = config.fetchCredentials;
                  _isOneDs = !!config.isOneDs;
                  _enableSendPromise = !!config.enableSendPromise;
                  _disableXhr = !!config.disableXhr;
                  _disableBeacon = !!config.disableBeacon;
                  _disableBeaconSync = !!config.disableBeaconSync;
                  _timeoutWrapper = config.timeWrapper;
                  _addNoResponse = !!config.addNoResponse;
                  _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                  _fallbackInst = { sendPOST: _xhrSender };
                  if (!_isOneDs) {
                    _sendCredentials = false;
                  }
                  if (_disableCredentials) {
                    var location_1 = getLocation();
                    if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE]() === "file:") {
                      _sendCredentials = false;
                    }
                  }
                  return true;
                } catch (e) {
                }
                return false;
              };
              _self.getSyncFetchPayload = function() {
                return _syncFetchPayload;
              };
              _self.getSenderInst = function(transports, sync) {
                if (transports && transports[_DYN_LENGTH$1]) {
                  return _getSenderInterface(transports, sync);
                }
                return null;
              };
              _self.getFallbackInst = function() {
                return _fallbackInst;
              };
              _self[_DYN__DO_TEARDOWN] = function(unloadCtx, unloadState) {
                _initDefaults();
              };
              _self.preparePayload = function(callback, zipPayload, payload, isSync) {
                if (!zipPayload || isSync || !payload[_DYN_DATA]) {
                  callback(payload);
                  return;
                }
                try {
                  var csStream = /* @__PURE__ */ getInst("CompressionStream");
                  if (!isFunction(csStream)) {
                    callback(payload);
                    return;
                  }
                  var body = new ReadableStream({
                    start: function(controller) {
                      controller.enqueue(isString(payload[_DYN_DATA]) ? new TextEncoder().encode(payload[_DYN_DATA]) : payload[_DYN_DATA]);
                      controller.close();
                    }
                  });
                  var compressedStream = body.pipeThrough(new csStream("gzip"));
                  var reader_1 = compressedStream.getReader();
                  var chunks_1 = [];
                  var totalLength_1 = 0;
                  var callbackCalled_1 = false;
                  doAwaitResponse(reader_1.read(), function processChunk(response) {
                    if (!callbackCalled_1 && !response.rejected) {
                      var result = response[_DYN_VALUE$1];
                      if (!result.done) {
                        chunks_1[_DYN_PUSH](result[_DYN_VALUE$1]);
                        totalLength_1 += result.value[_DYN_LENGTH$1];
                        return doAwaitResponse(reader_1.read(), processChunk);
                      }
                      var combined = new Uint8Array(totalLength_1);
                      var offset = 0;
                      for (var _i = 0, chunks_2 = chunks_1; _i < chunks_2.length; _i++) {
                        var chunk = chunks_2[_i];
                        combined.set(chunk, offset);
                        offset += chunk[_DYN_LENGTH$1];
                      }
                      payload[_DYN_DATA] = combined;
                      payload[_DYN_HEADERS]["Content-Encoding"] = "gzip";
                      payload._chunkCount = chunks_1[_DYN_LENGTH$1];
                    }
                    if (!callbackCalled_1) {
                      callbackCalled_1 = true;
                      callback(payload);
                    }
                  });
                  return reader_1;
                } catch (error) {
                  callback(payload);
                  return;
                }
              };
              function _onSuccess(res, onComplete) {
                _doOnComplete(onComplete, 200, {}, res);
              }
              function _onError(message, onComplete) {
                _throwInternal(_diagLog, 2, 26, "Failed to send telemetry.", { message });
                _doOnComplete(onComplete, 400, {});
              }
              function _onNoPayloadUrl(onComplete) {
                _onError("No endpoint url is provided for the batch", onComplete);
              }
              function _getSenderInterface(transports, syncSupport) {
                var transportType = 0;
                var sendPostFunc = null;
                var lp = 0;
                while (sendPostFunc == null && lp < transports[_DYN_LENGTH$1]) {
                  transportType = transports[lp];
                  if (!_disableXhr && transportType === 1) {
                    if (useXDomainRequest()) {
                      sendPostFunc = _xdrSender;
                    } else if (isXhrSupported()) {
                      sendPostFunc = _xhrSender;
                    }
                  } else if (transportType === 2 && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                    sendPostFunc = _doFetchSender;
                  } else if (transportType === 3 && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                    sendPostFunc = _beaconSender;
                  }
                  lp++;
                }
                if (sendPostFunc) {
                  return {
                    _transport: transportType,
                    _isSync: syncSupport,
                    sendPOST: sendPostFunc
                  };
                }
                return null;
              }
              function _doOnComplete(oncomplete, status, headers, response) {
                try {
                  oncomplete && oncomplete(status, headers, response);
                } catch (e) {
                }
              }
              function _doBeaconSend(payload, oncomplete) {
                var nav = getNavigator();
                var url = payload[_DYN_URL_STRING];
                if (!url) {
                  _onNoPayloadUrl(oncomplete);
                  return true;
                }
                url = payload[_DYN_URL_STRING] + (_addNoResponse ? _noResponseQs : STR_EMPTY$1);
                var data = payload[_DYN_DATA];
                var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                var queued = nav.sendBeacon(url, plainTextBatch);
                return queued;
              }
              function _beaconSender(payload, oncomplete, sync) {
                var data = payload[_DYN_DATA];
                try {
                  if (data) {
                    if (!_doBeaconSend(payload, oncomplete)) {
                      var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                      if (onRetry && isFunction(onRetry)) {
                        onRetry(payload, oncomplete, _doBeaconSend);
                      } else {
                        _fallbackInst && _fallbackInst.sendPOST(payload, oncomplete, true);
                        _throwInternal(_diagLog, 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");
                      }
                    } else {
                      _onSuccess(STR_EMPTY$1, oncomplete);
                    }
                  }
                } catch (e) {
                  _isOneDs && _warnToConsole(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + /* @__PURE__ */ dumpObj(e));
                  _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY$1);
                }
                return;
              }
              function _xhrSender(payload, oncomplete, sync) {
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var headers = payload[_DYN_HEADERS] || {};
                if (!sync && _enableSendPromise) {
                  thePromise = createPromise(function(resolve3, reject) {
                    resolveFunc = resolve3;
                    rejectFunc = reject;
                  });
                }
                if (_isOneDs && sync && payload.disableXhrSync) {
                  sync = false;
                }
                var endPointUrl = payload[_DYN_URL_STRING];
                if (!endPointUrl) {
                  _onNoPayloadUrl(oncomplete);
                  resolveFunc && resolveFunc(false);
                  return;
                }
                var xhr = openXhr$1(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT]);
                if (!_isOneDs) {
                  xhr.setRequestHeader("Content-type", "application/json");
                }
                arrForEach(objKeys(headers), function(headerName) {
                  xhr.setRequestHeader(headerName, headers[headerName]);
                });
                xhr.onreadystatechange = function() {
                  if (!_isOneDs) {
                    _doOnReadyFunc(xhr);
                    if (xhr.readyState === 4) {
                      resolveFunc && resolveFunc(true);
                    }
                  }
                };
                xhr.onload = function() {
                  if (_isOneDs) {
                    _doOnReadyFunc(xhr);
                  }
                };
                function _doOnReadyFunc(xhr2) {
                  var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                  var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);
                  if (onReadyFuncExist) {
                    onReadyFunc(xhr2, oncomplete, payload);
                  } else {
                    var response = getResponseText(xhr2);
                    _doOnComplete(oncomplete, xhr2[_DYN_STATUS], _getAllResponseHeaders(xhr2, _isOneDs), response);
                  }
                }
                xhr.onerror = function(event) {
                  _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$1 : formatErrorMessageXhr(xhr));
                  rejectFunc && rejectFunc(event);
                };
                xhr.ontimeout = function() {
                  _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$1 : formatErrorMessageXhr(xhr));
                  resolveFunc && resolveFunc(false);
                };
                xhr.send(payload[_DYN_DATA]);
                return thePromise;
              }
              function _doFetchSender(payload, oncomplete, sync) {
                var _a2;
                var endPointUrl = payload[_DYN_URL_STRING];
                var batch = payload[_DYN_DATA];
                var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var requestHeaders = new Headers();
                var batchLength = batch[_DYN_LENGTH$1];
                var ignoreResponse = false;
                var responseHandled = false;
                var headers = payload[_DYN_HEADERS] || {};
                var init = (_a2 = {
                  method: STR_POST_METHOD,
                  body: plainTextBatch
                }, _a2[DisabledPropertyName] = true, _a2);
                if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH$1] > 0) {
                  arrForEach(objKeys(headers), function(headerName) {
                    requestHeaders.append(headerName, headers[headerName]);
                  });
                  init[_DYN_HEADERS] = requestHeaders;
                }
                if (_fetchCredentials) {
                  init.credentials = _fetchCredentials;
                } else if (_sendCredentials && _isOneDs) {
                  init.credentials = "include";
                }
                if (sync) {
                  init.keepalive = true;
                  _syncFetchPayload += batchLength;
                  if (_isOneDs) {
                    if (payload["_sendReason"] === 2) {
                      ignoreResponse = true;
                      if (_addNoResponse) {
                        endPointUrl += _noResponseQs;
                      }
                    }
                  } else {
                    ignoreResponse = true;
                  }
                }
                var request = new Request(endPointUrl, init);
                try {
                  request[DisabledPropertyName] = true;
                } catch (e) {
                }
                if (!sync && _enableSendPromise) {
                  thePromise = createPromise(function(resolve3, reject) {
                    resolveFunc = resolve3;
                    rejectFunc = reject;
                  });
                }
                if (!endPointUrl) {
                  _onNoPayloadUrl(oncomplete);
                  resolveFunc && resolveFunc(false);
                  return;
                }
                function _handleError(res, statusCode) {
                  if (statusCode) {
                    _doOnComplete(oncomplete, _isOneDs ? 0 : statusCode, {}, _isOneDs ? STR_EMPTY$1 : res);
                  } else {
                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY$1 : res);
                  }
                }
                function _onFetchComplete(response, payload2, value) {
                  var status = response[_DYN_STATUS];
                  var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                  if (onCompleteFunc && isFunction(onCompleteFunc)) {
                    onCompleteFunc(response, oncomplete, value || STR_EMPTY$1, payload2);
                  } else {
                    _doOnComplete(oncomplete, status, {}, value || STR_EMPTY$1);
                  }
                }
                try {
                  doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function(result) {
                    if (sync) {
                      _syncFetchPayload -= batchLength;
                      batchLength = 0;
                    }
                    if (!responseHandled) {
                      responseHandled = true;
                      if (!result.rejected) {
                        var response_1 = result[_DYN_VALUE$1];
                        try {
                          if (!_isOneDs && !response_1.ok) {
                            if (response_1[_DYN_STATUS]) {
                              _handleError(response_1.statusText, response_1[_DYN_STATUS]);
                            } else {
                              _handleError(response_1.statusText, 499);
                            }
                            resolveFunc && resolveFunc(false);
                          } else {
                            if (_isOneDs && !response_1.body) {
                              _onFetchComplete(response_1, null, STR_EMPTY$1);
                              resolveFunc && resolveFunc(true);
                            } else {
                              doAwaitResponse(response_1.text(), function(resp) {
                                _onFetchComplete(response_1, payload, resp[_DYN_VALUE$1]);
                                resolveFunc && resolveFunc(true);
                              });
                            }
                          }
                        } catch (e) {
                          if (response_1 && response_1[_DYN_STATUS]) {
                            _handleError(/* @__PURE__ */ dumpObj(e), response_1[_DYN_STATUS]);
                          } else {
                            _handleError(/* @__PURE__ */ dumpObj(e), 499);
                          }
                          rejectFunc && rejectFunc(e);
                        }
                      } else {
                        _handleError(result.reason && result.reason[_DYN_MESSAGE], 499);
                        rejectFunc && rejectFunc(result.reason);
                      }
                    }
                  });
                } catch (e) {
                  if (!responseHandled) {
                    _handleError(/* @__PURE__ */ dumpObj(e), 499);
                    rejectFunc && rejectFunc(e);
                  }
                }
                if (ignoreResponse && !responseHandled) {
                  responseHandled = true;
                  _doOnComplete(oncomplete, 200, {});
                  resolveFunc && resolveFunc(true);
                }
                if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT] > 0) {
                  _timeoutWrapper && _timeoutWrapper.set(function() {
                    if (!responseHandled) {
                      responseHandled = true;
                      _doOnComplete(oncomplete, 500, {});
                      resolveFunc && resolveFunc(true);
                    }
                  }, payload[_DYN_TIMEOUT]);
                }
                return thePromise;
              }
              function _xdrSender(payload, oncomplete, sync) {
                var _window = getWindow();
                var xdr = new XDomainRequest();
                var data = payload[_DYN_DATA];
                xdr.onload = function() {
                  var response = getResponseText(xdr);
                  var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                  if (onloadFunc && isFunction(onloadFunc)) {
                    onloadFunc(xdr, oncomplete, payload);
                  } else {
                    _doOnComplete(oncomplete, 200, {}, response);
                  }
                };
                xdr.onerror = function() {
                  _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY$1 : formatErrorMessageXdr(xdr));
                };
                xdr.ontimeout = function() {
                  _doOnComplete(oncomplete, 500, {});
                };
                xdr.onprogress = function() {
                };
                var hostingProtocol = _window && _window.location && _window.location.protocol || "";
                var endpoint = payload[_DYN_URL_STRING];
                if (!endpoint) {
                  _onNoPayloadUrl(oncomplete);
                  return;
                }
                if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                  var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                  _throwInternal(_diagLog, 2, 40, ". " + msg);
                  _onError(msg, oncomplete);
                  return;
                }
                var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE](/^(https?:)/, "");
                xdr.open(STR_POST_METHOD, endpointUrl);
                if (payload[_DYN_TIMEOUT]) {
                  xdr[_DYN_TIMEOUT] = payload[_DYN_TIMEOUT];
                }
                xdr.send(data);
                if (_isOneDs && sync) {
                  _timeoutWrapper && _timeoutWrapper.set(function() {
                    xdr.send(data);
                  }, 0);
                } else {
                  xdr.send(data);
                }
              }
              function _initDefaults() {
                _syncFetchPayload = 0;
                _isInitialized = false;
                _enableSendPromise = false;
                _diagLog = null;
                _isOneDs = null;
                _onCompleteFuncs = null;
                _disableCredentials = null;
                _fetchCredentials = null;
                _fallbackInst = null;
                _disableXhr = false;
                _disableBeacon = false;
                _disableBeaconSync = false;
                _disableFetchKeepAlive = false;
                _addNoResponse = false;
                _timeoutWrapper = null;
              }
            });
          }
          SenderPostManager2.__ieDyn = 1;
          return SenderPostManager2;
        }()
      );
      var strOnPrefix = "on";
      var strAttachEvent = "attachEvent";
      var strAddEventHelper = "addEventListener";
      var strDetachEvent = "detachEvent";
      var strRemoveEventListener = "removeEventListener";
      var strEvents = "events";
      var strVisibilityChangeEvt = "visibilitychange";
      var strPageHide = "pagehide";
      var strPageShow = "pageshow";
      var strUnload = "unload";
      var strBeforeUnload = "beforeunload";
      var strPageHideNamespace = createUniqueNamespace("aiEvtPageHide");
      var strPageShowNamespace = createUniqueNamespace("aiEvtPageShow");
      var rRemoveEmptyNs = /\.[\.]+/g;
      var rRemoveTrailingEmptyNs = /[\.]+$/;
      var _guid = 1;
      var elmNodeData = createElmNodeData("events");
      var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
      function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE]) {
          return name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY$2);
        }
        return name;
      }
      function _getEvtNamespace(eventName, evtNamespace) {
        if (evtNamespace) {
          var theNamespace_1 = STR_EMPTY$2;
          if (isArray(evtNamespace)) {
            theNamespace_1 = STR_EMPTY$2;
            arrForEach(evtNamespace, function(name) {
              name = _normalizeNamespace(name);
              if (name) {
                if (name[0] !== ".") {
                  name = "." + name;
                }
                theNamespace_1 += name;
              }
            });
          } else {
            theNamespace_1 = _normalizeNamespace(evtNamespace);
          }
          if (theNamespace_1) {
            if (theNamespace_1[0] !== ".") {
              theNamespace_1 = "." + theNamespace_1;
            }
            eventName = (eventName || STR_EMPTY$2) + theNamespace_1;
          }
        }
        var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY$2) || [];
        return {
          type: parsedEvent[1],
          ns: (parsedEvent[2] || STR_EMPTY$2).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY$2)[_DYN_SPLIT](".").sort().join(".")
        };
      }
      function __getRegisteredEvents(target, eventName, evtNamespace) {
        var theEvents = [];
        var eventCache = elmNodeData.get(target, strEvents, {}, false);
        var evtName = _getEvtNamespace(eventName, evtNamespace);
        objForEachKey(eventCache, function(evtType, registeredEvents) {
          arrForEach(registeredEvents, function(value) {
            if (!evtName[_DYN_TYPE] || evtName[_DYN_TYPE] === value[_DYN_EVT_NAME][_DYN_TYPE]) {
              if (!evtName.ns || evtName.ns === evtName.ns) {
                theEvents[_DYN_PUSH]({
                  name: value.evtName[_DYN_TYPE] + (value[_DYN_EVT_NAME].ns ? "." + value[_DYN_EVT_NAME].ns : STR_EMPTY$2),
                  handler: value.handler
                });
              }
            }
          });
        });
        return theEvents;
      }
      function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) {
          addDefault = true;
        }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
          registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
      }
      function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE]) {
          if (obj[strRemoveEventListener]) {
            obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture);
          } else if (obj[strDetachEvent]) {
            obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
          }
        }
      }
      function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE] && handlerRef) {
          if (obj[strAddEventHelper]) {
            obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture);
            result = true;
          } else if (obj[strAttachEvent]) {
            obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
            result = true;
          }
        }
        return result;
      }
      function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$1];
        while (idx--) {
          var theEvent = events[idx];
          if (theEvent) {
            if (!evtName.ns || evtName.ns === theEvent[_DYN_EVT_NAME].ns) {
              if (!unRegFn || unRegFn(theEvent)) {
                _doDetach(target, theEvent[_DYN_EVT_NAME], theEvent.handler, theEvent.capture);
                events[_DYN_SPLICE](idx, 1);
              }
            }
          }
        }
      }
      function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE]) {
          _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);
        } else {
          var eventCache = elmNodeData.get(target, strEvents, {});
          objForEachKey(eventCache, function(evtType, events) {
            _doUnregister(target, events, evtName, unRegFn);
          });
          if (objKeys(eventCache)[_DYN_LENGTH$1] === 0) {
            elmNodeData.kill(target, strEvents);
          }
        }
      }
      function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
          if (isArray(namespaces)) {
            newNamespaces = [theNamespace].concat(namespaces);
          } else {
            newNamespaces = [theNamespace, namespaces];
          }
          newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT](".");
        } else {
          newNamespaces = theNamespace;
        }
        return newNamespaces;
      }
      function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        var result = false;
        if (target) {
          try {
            var evtName = _getEvtNamespace(eventName, evtNamespace);
            result = _doAttach(target, evtName, handlerRef, useCapture);
            if (result && elmNodeData.accept(target)) {
              var registeredEvent = {
                guid: _guid++,
                evtName,
                handler: handlerRef,
                capture: useCapture
              };
              _getRegisteredEvents(target, evtName.type)[_DYN_PUSH](registeredEvent);
            }
          } catch (e) {
          }
        }
        return result;
      }
      function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        if (target) {
          try {
            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
            var found_1 = false;
            _unregisterEvents(target, evtName_1, function(regEvent) {
              if (evtName_1.ns && !handlerRef || regEvent.handler === handlerRef) {
                found_1 = true;
                return true;
              }
              return false;
            });
            if (!found_1) {
              _doDetach(target, evtName_1, handlerRef, useCapture);
            }
          } catch (e) {
          }
        }
      }
      function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        return eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);
      }
      function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);
      }
      function addEventHandler(eventName, callback, evtNamespace) {
        var result = false;
        var w = getWindow();
        if (w) {
          result = eventOn(w, eventName, callback, evtNamespace);
          result = eventOn(w["body"], eventName, callback, evtNamespace) || result;
        }
        var doc = getDocument();
        if (doc) {
          result = eventOn(doc, eventName, callback, evtNamespace) || result;
        }
        return result;
      }
      function removeEventHandler(eventName, callback, evtNamespace) {
        var w = getWindow();
        if (w) {
          eventOff(w, eventName, callback, evtNamespace);
          eventOff(w["body"], eventName, callback, evtNamespace);
        }
        var doc = getDocument();
        if (doc) {
          eventOff(doc, eventName, callback, evtNamespace);
        }
      }
      function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && events[_DYN_LENGTH$1] > 0) {
          arrForEach(events, function(name) {
            if (name) {
              if (!excludeEvents || arrIndexOf(excludeEvents, name) === -1) {
                added = addEventHandler(name, listener, evtNamespace) || added;
              }
            }
          });
        }
        return added;
      }
      function addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && isArray(events)) {
          added = _addEventListeners(events, listener, excludeEvents, evtNamespace);
          if (!added && excludeEvents && excludeEvents[_DYN_LENGTH$1] > 0) {
            added = _addEventListeners(events, listener, null, evtNamespace);
          }
        }
        return added;
      }
      function removeEventListeners(events, listener, evtNamespace) {
        if (events && isArray(events)) {
          arrForEach(events, function(name) {
            if (name) {
              removeEventHandler(name, listener, evtNamespace);
            }
          });
        }
      }
      function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
        return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);
      }
      function removePageUnloadEventListener(listener, evtNamespace) {
        removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);
      }
      function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
          var doc = getDocument();
          if (listener && doc && doc.visibilityState === "hidden") {
            listener(evt);
          }
        }
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);
        if (!excludeEvents || arrIndexOf(excludeEvents, strVisibilityChangeEvt) === -1) {
          pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;
        }
        if (!pageUnloadAdded && excludeEvents) {
          pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);
        }
        return pageUnloadAdded;
      }
      function removePageHideEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        removeEventListeners([strPageHide], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
      }
      function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
          var doc = getDocument();
          if (listener && doc && doc.visibilityState === "visible") {
            listener(evt);
          }
        }
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);
        pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;
        if (!pageShowAdded && excludeEvents) {
          pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);
        }
        return pageShowAdded;
      }
      function removePageShowEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        removeEventListeners([strPageShow], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
      }
      var LoggingSeverity = createEnumStyle({
        DISABLED: 0,
        CRITICAL: 1,
        WARNING: 2,
        DEBUG: 3
      });
      var STR_EMPTY = "";
      var STR_DEFAULT_ENDPOINT_URL = "https://browser.events.data.microsoft.com/OneCollector/1.0/";
      var STR_VERSION = "version";
      var STR_PROPERTIES = "properties";
      var _DYN_INITIALIZE = "initialize";
      var _DYN_INDEX_OF = "indexOf";
      var _DYN_TIMINGS = "timings";
      var _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs";
      var _DYN_VALUE = "value";
      var _DYN_LENGTH = "length";
      var _DYN_PROCESS_TELEMETRY_ST0 = "processTelemetryStart";
      var _DYN_HANDLE_FIELD = "handleField";
      var _DYN_RM_SANITIZER = "rmSanitizer";
      var _DYN_RM_FIELD_SANITIZER = "rmFieldSanitizer";
      var _DYN_CAN_HANDLE = "canHandle";
      var _a;
      var Version = "4.3.7";
      var FullVersionString = "1DS-Web-JS-" + Version;
      var ObjHasOwnProperty = ObjProto$1.hasOwnProperty;
      var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var strWithCredentials = "withCredentials";
      var strTimeout = "timeout";
      var _fieldTypeEventPropMap = (_a = {}, _a[0] = 0, _a[2] = 6, _a[1] = 1, _a[3] = 7, _a[4096 | 2] = 6, _a[4096 | 1] = 1, _a[4096 | 3] = 7, _a);
      var uInt8ArraySupported = null;
      var isDocumentObjectAvailable = /* @__PURE__ */ hasDocument();
      var isWindowObjectAvailable = /* @__PURE__ */ hasWindow();
      function isValueAssigned(value) {
        return !(value === STR_EMPTY || /* @__PURE__ */ isNullOrUndefined(value));
      }
      function getTenantId(apiKey) {
        if (apiKey) {
          var indexTenantId = strIndexOf(apiKey, "-");
          if (indexTenantId > -1) {
            return /* @__PURE__ */ strLeft(apiKey, indexTenantId);
          }
        }
        return STR_EMPTY;
      }
      function isUint8ArrayAvailable() {
        if (uInt8ArraySupported === null) {
          uInt8ArraySupported = !/* @__PURE__ */ isUndefined(Uint8Array) && !isSafariOrFirefox() && !isReactNative();
        }
        return uInt8ArraySupported;
      }
      function isLatency(value) {
        if (value && isNumber(value) && value >= 1 && value <= 4) {
          return true;
        }
        return false;
      }
      function sanitizeProperty(name, property, stringifyObjects) {
        if (!property && !isValueAssigned(property) || typeof name !== "string") {
          return null;
        }
        var propType = typeof property;
        if (propType === "string" || propType === "number" || propType === "boolean" || isArray(property)) {
          property = { value: property };
        } else if (propType === "object" && !ObjHasOwnProperty.call(property, "value")) {
          property = { value: stringifyObjects ? JSON.stringify(property) : property };
        } else if (/* @__PURE__ */ isNullOrUndefined(property[_DYN_VALUE]) || property[_DYN_VALUE] === STR_EMPTY || !isString(property[_DYN_VALUE]) && !isNumber(property[_DYN_VALUE]) && !isBoolean(property[_DYN_VALUE]) && !isArray(property[_DYN_VALUE])) {
          return null;
        }
        if (isArray(property[_DYN_VALUE]) && !isArrayValid(property[_DYN_VALUE])) {
          return null;
        }
        if (!/* @__PURE__ */ isNullOrUndefined(property.kind)) {
          if (isArray(property[_DYN_VALUE]) || !isValueKind(property.kind)) {
            return null;
          }
          property[_DYN_VALUE] = property[_DYN_VALUE].toString();
        }
        return property;
      }
      function getCommonSchemaMetaData(value, kind, type) {
        var encodedTypeValue = -1;
        if (!/* @__PURE__ */ isUndefined(value)) {
          if (kind > 0) {
            if (kind === 32) {
              encodedTypeValue = 1 << 13;
            } else if (kind <= 13) {
              encodedTypeValue = kind << 5;
            }
          }
          if (isDataType(type)) {
            if (encodedTypeValue === -1) {
              encodedTypeValue = 0;
            }
            encodedTypeValue |= type;
          } else {
            var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
            if (encodedTypeValue !== -1 && propType !== -1) {
              encodedTypeValue |= propType;
            } else if (propType === 6) {
              encodedTypeValue = propType;
            }
          }
        }
        return encodedTypeValue;
      }
      function getCookieValue(cookieMgr, name, decode) {
        if (decode === void 0) {
          decode = true;
        }
        var cookieValue;
        if (cookieMgr) {
          cookieValue = cookieMgr.get(name);
          if (decode && cookieValue && decodeURIComponent) {
            cookieValue = decodeURIComponent(cookieValue);
          }
        }
        return cookieValue || STR_EMPTY;
      }
      function createGuid(style) {
        if (style === void 0) {
          style = "D";
        }
        var theGuid = newGuid();
        if (style === "B") {
          theGuid = "{" + theGuid + "}";
        } else if (style === "P") {
          theGuid = "(" + theGuid + ")";
        } else if (style === "N") {
          theGuid = theGuid.replace(/-/g, STR_EMPTY);
        }
        return theGuid;
      }
      function extend(obj, obj2, obj3, obj4, obj5) {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments[_DYN_LENGTH];
        var theArgs = arguments;
        if (isBoolean(theArgs[0])) {
          deep = theArgs[0];
          i++;
        }
        for (; i < length; i++) {
          var obj = theArgs[i];
          objForEachKey(obj, function(prop, value) {
            if (deep && value && /* @__PURE__ */ isObject(value)) {
              if (isArray(value)) {
                extended[prop] = extended[prop] || [];
                arrForEach(value, function(arrayValue, arrayIndex) {
                  if (arrayValue && /* @__PURE__ */ isObject(arrayValue)) {
                    extended[prop][arrayIndex] = extend(true, extended[prop][arrayIndex], arrayValue);
                  } else {
                    extended[prop][arrayIndex] = arrayValue;
                  }
                });
              } else {
                extended[prop] = extend(true, extended[prop], value);
              }
            } else {
              extended[prop] = value;
            }
          });
        }
        return extended;
      }
      var getTime = perfNow;
      function isValueKind(value) {
        if (value === 0 || (value > 0 && value <= 13 || value === 32)) {
          return true;
        }
        return false;
      }
      function isDataType(value) {
        if (value >= 0 && value <= 9) {
          return true;
        }
        return false;
      }
      function isSafariOrFirefox() {
        var nav = getNavigator();
        if (!/* @__PURE__ */ isUndefined(nav) && nav.userAgent) {
          var ua = nav.userAgent.toLowerCase();
          if ((ua[_DYN_INDEX_OF]("safari") >= 0 || ua[_DYN_INDEX_OF]("firefox") >= 0) && ua[_DYN_INDEX_OF]("chrome") < 0) {
            return true;
          }
        }
        return false;
      }
      function isArrayValid(value) {
        return value[_DYN_LENGTH] > 0;
      }
      function setProcessTelemetryTimings(event, identifier) {
        var evt = event;
        evt[_DYN_TIMINGS] = evt[_DYN_TIMINGS] || {};
        evt[_DYN_TIMINGS][_DYN_PROCESS_TELEMETRY_ST0] = evt[_DYN_TIMINGS][_DYN_PROCESS_TELEMETRY_ST0] || {};
        evt[_DYN_TIMINGS][_DYN_PROCESS_TELEMETRY_ST0][identifier] = getTime();
      }
      function getFieldValueType(value) {
        var theType = 0;
        if (value !== null && value !== void 0) {
          var objType = typeof value;
          if (objType === "string") {
            theType = 1;
          } else if (objType === "number") {
            theType = 2;
          } else if (objType === "boolean") {
            theType = 3;
          } else if (objType === strShimObject) {
            theType = 4;
            if (isArray(value)) {
              theType = 4096;
              if (value[_DYN_LENGTH] > 0) {
                theType |= getFieldValueType(value[0]);
              }
            } else if (ObjHasOwnProperty.call(value, "value")) {
              theType = 8192 | getFieldValueType(value[_DYN_VALUE]);
            }
          }
        }
        return theType;
      }
      function isChromium() {
        return !!/* @__PURE__ */ getInst("chrome");
      }
      function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) {
          disabled = false;
        }
        if (isSync === void 0) {
          isSync = false;
        }
        function _wrapSetXhrProp(xhr2, prop, value) {
          try {
            xhr2[prop] = value;
          } catch (e) {
          }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
          _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
        }
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        if (!isSync && timeout) {
          _wrapSetXhrProp(xhr, strTimeout, timeout);
        }
        return xhr;
      }
      function isGreaterThanZero(value) {
        return value > 0;
      }
      var defaultConfig = objDeepFreeze({
        endpointUrl: STR_DEFAULT_ENDPOINT_URL,
        propertyStorageOverride: { isVal: _chkPropOverride }
      });
      function _chkPropOverride(propertyStorageOverride) {
        if (propertyStorageOverride && (!propertyStorageOverride.getProperty || !propertyStorageOverride.setProperty)) {
          throwError("Invalid property storage override passed.");
        }
        return true;
      }
      var AppInsightsCore = (
        /** @class */
        function(_super) {
          __extendsFn(AppInsightsCore2, _super);
          function AppInsightsCore2() {
            var _this = _super.call(this) || this;
            dynamicProto(AppInsightsCore2, _this, function(_self, _base) {
              _self[_DYN_INITIALIZE] = function(config, extensions3, logger2, notificationManager) {
                doPerf(_self, function() {
                  return "AppInsightsCore.initialize";
                }, function() {
                  try {
                    _base[_DYN_INITIALIZE](createDynamicConfig(config, defaultConfig, logger2 || _self.logger, false).cfg, extensions3, logger2, notificationManager);
                  } catch (e) {
                    var logger_1 = _self.logger;
                    var message = /* @__PURE__ */ dumpObj(e);
                    if (message[_DYN_INDEX_OF]("channels") !== -1) {
                      message += "\n - Channels must be provided through config.channels only!";
                    }
                    _throwInternal(logger_1, 1, 514, "SDK Initialization Failed - no telemetry will be sent: " + message);
                  }
                }, function() {
                  return { config, extensions: extensions3, logger: logger2, notificationManager };
                });
              };
              _self.track = function(item) {
                doPerf(_self, function() {
                  return "AppInsightsCore.track";
                }, function() {
                  var telemetryItem = item;
                  if (telemetryItem) {
                    telemetryItem[_DYN_TIMINGS] = telemetryItem[_DYN_TIMINGS] || {};
                    telemetryItem[_DYN_TIMINGS].trackStart = getTime();
                    if (!isLatency(telemetryItem.latency)) {
                      telemetryItem.latency = 1;
                    }
                    var itemExt = telemetryItem.ext = telemetryItem.ext || {};
                    itemExt.sdk = itemExt.sdk || {};
                    itemExt.sdk.ver = FullVersionString;
                    var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
                    baseData[STR_PROPERTIES] = baseData[STR_PROPERTIES] || {};
                    var itemProperties = baseData[STR_PROPERTIES];
                    itemProperties[STR_VERSION] = itemProperties[STR_VERSION] || _self.pluginVersionString || STR_EMPTY;
                  }
                  _base.track(telemetryItem);
                }, function() {
                  return { item };
                }, !item.sync);
              };
              _self[_DYN_POLL_INTERNAL_LOGS] = function(eventName) {
                return _base[_DYN_POLL_INTERNAL_LOGS](eventName || "InternalLog");
              };
            });
            return _this;
          }
          AppInsightsCore2.__ieDyn = 1;
          return AppInsightsCore2;
        }(AppInsightsCore$1)
      );
      var ValueKind = createEnumStyle({
        NotSet: 0,
        Pii_DistinguishedName: 1,
        Pii_GenericData: 2,
        Pii_IPV4Address: 3,
        Pii_IPv6Address: 4,
        Pii_MailSubject: 5,
        Pii_PhoneNumber: 6,
        Pii_QueryString: 7,
        Pii_SipAddress: 8,
        Pii_SmtpAddress: 9,
        Pii_Identity: 10,
        Pii_Uri: 11,
        Pii_Fqdn: 12,
        Pii_IPV4AddressLegacy: 13,
        Pii_IPv6ScrubLastHextets: 14,
        Pii_DropValue: 15,
        CustomerContent_GenericContent: 32
      });
      var EventLatency = createEnumStyle({
        Normal: 1,
        CostDeferred: 2,
        RealTime: 3,
        Immediate: 4
      });
      var EventPropertyType = createEnumStyle({
        Unspecified: 0,
        String: 1,
        Int32: 2,
        UInt32: 3,
        Int64: 4,
        UInt64: 5,
        Double: 6,
        Bool: 7,
        Guid: 8,
        DateTime: 9
      });
      var EventPersistence = createEnumStyle({
        Normal: 1,
        Critical: 2
      });
      var TraceLevel = createEnumStyle({
        NONE: 0,
        ERROR: 1,
        WARNING: 2,
        INFORMATION: 3
      });
      function _isSpecialName(name) {
        return name == "__proto__" || name == "constructor" || name == "prototype";
      }
      var ValueSanitizer = (
        /** @class */
        function() {
          function ValueSanitizer2(fieldSanitizerProvider) {
            var _self = this;
            var _sanitizerMap = {};
            var _sanitizers = [];
            var _fieldSanitizers = [];
            if (fieldSanitizerProvider) {
              _fieldSanitizers.push(fieldSanitizerProvider);
            }
            function _getFieldSanitizer(path11, name) {
              var result;
              var fieldLookup = _sanitizerMap[path11];
              if (fieldLookup) {
                result = fieldLookup[name];
              }
              if (!result && result !== null) {
                if (isString(path11) && isString(name)) {
                  if (_fieldSanitizers[_DYN_LENGTH] > 0) {
                    for (var lp = 0; lp < _fieldSanitizers[_DYN_LENGTH]; lp++) {
                      if (_fieldSanitizers[lp][_DYN_HANDLE_FIELD](path11, name)) {
                        result = {
                          canHandle: true,
                          fieldHandler: _fieldSanitizers[lp]
                        };
                        break;
                      }
                    }
                  } else if (_sanitizers[_DYN_LENGTH] === 0) {
                    result = {
                      canHandle: true
                    };
                  }
                }
                if (!result && result !== null) {
                  result = null;
                  for (var lp = 0; lp < _sanitizers[_DYN_LENGTH]; lp++) {
                    if (_sanitizers[lp][_DYN_HANDLE_FIELD](path11, name)) {
                      result = {
                        canHandle: true,
                        handler: _sanitizers[lp],
                        fieldHandler: null
                      };
                      break;
                    }
                  }
                }
                if (!fieldLookup) {
                  if (_isSpecialName(path11)) {
                    return null;
                  }
                  fieldLookup = _sanitizerMap[path11] = {};
                }
                if (_isSpecialName(name)) {
                  return null;
                }
                fieldLookup[name] = result;
              }
              return result;
            }
            _self.clearCache = function() {
              _sanitizerMap = {};
            };
            _self.addSanitizer = function(newSanitizer) {
              if (newSanitizer) {
                if (!arrIncludes(_sanitizers, newSanitizer)) {
                  _sanitizers.push(newSanitizer);
                }
                _sanitizerMap = {};
              }
            };
            _self.addFieldSanitizer = function(fieldSanitizer) {
              if (fieldSanitizer) {
                if (!arrIncludes(_fieldSanitizers, fieldSanitizer)) {
                  _fieldSanitizers.push(fieldSanitizer);
                }
                _sanitizerMap = {};
              }
            };
            _self[_DYN_RM_SANITIZER] = function(theSanitizer) {
              if (theSanitizer) {
                var idx = arrIndexOf(_sanitizers, theSanitizer);
                if (idx !== -1) {
                  _sanitizers.splice(idx, 1);
                  _sanitizerMap = {};
                }
                arrForEach(_sanitizers, function(sanitizer) {
                  sanitizer && sanitizer[_DYN_RM_SANITIZER] && sanitizer[_DYN_RM_SANITIZER](theSanitizer);
                });
              }
            };
            _self[_DYN_RM_FIELD_SANITIZER] = function(theFieldSanitizer) {
              if (theFieldSanitizer) {
                var idx = arrIndexOf(_fieldSanitizers, theFieldSanitizer);
                if (idx !== -1) {
                  _fieldSanitizers.splice(idx, 1);
                  _sanitizerMap = {};
                }
                arrForEach(_sanitizers, function(sanitizer) {
                  sanitizer && sanitizer[_DYN_RM_FIELD_SANITIZER] && sanitizer[_DYN_RM_FIELD_SANITIZER](theFieldSanitizer);
                });
              }
            };
            _self.isEmpty = function() {
              return getLength(_sanitizers) + getLength(_fieldSanitizers) === 0;
            };
            _self[_DYN_HANDLE_FIELD] = function(path11, name) {
              var mapValue = _getFieldSanitizer(path11, name);
              return mapValue ? mapValue[_DYN_CAN_HANDLE] : false;
            };
            _self[_DYN_VALUE] = function(path11, name, value, stringifyObjects) {
              var mapValue = _getFieldSanitizer(path11, name);
              if (mapValue && mapValue[_DYN_CAN_HANDLE]) {
                if (!mapValue[_DYN_CAN_HANDLE]) {
                  return null;
                }
                if (mapValue.handler) {
                  return mapValue.handler[_DYN_VALUE](path11, name, value, stringifyObjects);
                }
                if (!isString(name) || /* @__PURE__ */ isNullOrUndefined(value) || value === STR_EMPTY) {
                  return null;
                }
                var property = null;
                var fieldType = getFieldValueType(value);
                if ((fieldType & 8192) === 8192) {
                  var subType = fieldType & ~8192;
                  property = value;
                  if (!isValueAssigned(property[_DYN_VALUE]) || subType !== 1 && subType !== 2 && subType !== 3 && (subType & 4096) !== 4096) {
                    return null;
                  }
                } else if (fieldType === 1 || fieldType === 2 || fieldType === 3 || (fieldType & 4096) === 4096) {
                  property = _convertToProperty(path11, name, value);
                } else if (fieldType === 4) {
                  property = _convertToProperty(path11, name, !!stringifyObjects ? JSON.stringify(value) : value);
                }
                if (property) {
                  return _handleProperty(mapValue, path11, name, fieldType, property, stringifyObjects);
                }
              }
              return null;
            };
            _self.property = function(path11, name, property, stringifyObjects) {
              var mapValue = _getFieldSanitizer(path11, name);
              if (!mapValue || !mapValue[_DYN_CAN_HANDLE]) {
                return null;
              }
              if (!isString(name) || /* @__PURE__ */ isNullOrUndefined(property) || !isValueAssigned(property[_DYN_VALUE])) {
                return null;
              }
              var fieldType = getFieldValueType(property[_DYN_VALUE]);
              if (fieldType === 0) {
                return null;
              }
              return _handleProperty(mapValue, path11, name, fieldType, property, stringifyObjects);
            };
            function _handleProperty(mapValue, path11, name, fieldType, property, stringifyObjects) {
              if (mapValue.handler) {
                return mapValue.handler.property(path11, name, property, stringifyObjects);
              }
              if (!/* @__PURE__ */ isNullOrUndefined(property.kind)) {
                if ((fieldType & 4096) === 4096 || !isValueKind(property.kind)) {
                  return null;
                }
                property[_DYN_VALUE] = property[_DYN_VALUE].toString();
              }
              return _callFieldSanitizer(mapValue.fieldHandler, path11, name, fieldType, property);
            }
            function _convertToProperty(path11, name, value) {
              if (isValueAssigned(value)) {
                return { value };
              }
              return null;
            }
            function _callFieldSanitizer(fieldProvider, path11, name, theType, property) {
              if (property && fieldProvider) {
                var sanitizer = fieldProvider.getSanitizer(path11, name, theType, property.kind, property.propertyType);
                if (sanitizer) {
                  if (theType === 4) {
                    var newValue_1 = {};
                    var propValue = property[_DYN_VALUE];
                    objForEachKey(propValue, function(propKey, theValue) {
                      var newPath = path11 + "." + name;
                      if (isValueAssigned(theValue)) {
                        var newProp = _convertToProperty(newPath, propKey, theValue);
                        newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, getFieldValueType(theValue), newProp);
                        if (newProp) {
                          newValue_1[propKey] = newProp[_DYN_VALUE];
                        }
                      }
                    });
                    property[_DYN_VALUE] = newValue_1;
                  } else {
                    var details = {
                      path: path11,
                      name,
                      type: theType,
                      prop: property,
                      sanitizer: _self
                    };
                    property = sanitizer.call(_self, details);
                  }
                }
              }
              return property;
            }
          }
          ValueSanitizer2.getFieldType = getFieldValueType;
          return ValueSanitizer2;
        }()
      );
      exports3.ActiveStatus = ActiveStatus;
      exports3.AppInsightsCore = AppInsightsCore;
      exports3.BaseTelemetryPlugin = BaseTelemetryPlugin;
      exports3.DiagnosticLogger = DiagnosticLogger;
      exports3.EventLatency = EventLatency;
      exports3.EventPersistence = EventPersistence;
      exports3.EventPropertyType = EventPropertyType;
      exports3.EventsDiscardedReason = EventsDiscardedReason;
      exports3.FullVersionString = FullVersionString;
      exports3.InternalAppInsightsCore = AppInsightsCore$1;
      exports3.LoggingSeverity = LoggingSeverity;
      exports3.MinChannelPriorty = MinChannelPriorty;
      exports3.NotificationManager = NotificationManager;
      exports3.PerfEvent = PerfEvent;
      exports3.PerfManager = PerfManager;
      exports3.ProcessTelemetryContext = ProcessTelemetryContext;
      exports3.SenderPostManager = SenderPostManager;
      exports3.TraceLevel = TraceLevel;
      exports3.Undefined = strShimUndefined;
      exports3.ValueKind = ValueKind;
      exports3.ValueSanitizer = ValueSanitizer;
      exports3.Version = Version;
      exports3._InternalLogMessage = _InternalLogMessage;
      exports3.__getRegisteredEvents = __getRegisteredEvents;
      exports3._appendHeader = _appendHeader;
      exports3._getAllResponseHeaders = _getAllResponseHeaders;
      exports3._logInternalMessage = _logInternalMessage;
      exports3._testHookMaxUnloadHooksCb = _testHookMaxUnloadHooksCb;
      exports3._throwInternal = _throwInternal;
      exports3._warnToConsole = _warnToConsole;
      exports3.addEventHandler = addEventHandler;
      exports3.addEventListeners = addEventListeners;
      exports3.addPageHideEventListener = addPageHideEventListener;
      exports3.addPageShowEventListener = addPageShowEventListener;
      exports3.addPageUnloadEventListener = addPageUnloadEventListener;
      exports3.areCookiesSupported = areCookiesSupported;
      exports3.arrForEach = arrForEach;
      exports3.arrIndexOf = arrIndexOf;
      exports3.arrMap = arrMap;
      exports3.arrReduce = arrReduce;
      exports3.attachEvent = attachEvent;
      exports3.blockDynamicConversion = blockDynamicConversion;
      exports3.convertAllHeadersToMap = convertAllHeadersToMap;
      exports3.cookieAvailable = areCookiesSupported;
      exports3.createCookieMgr = createCookieMgr;
      exports3.createDynamicConfig = createDynamicConfig;
      exports3.createEnumStyle = createEnumStyle;
      exports3.createGuid = createGuid;
      exports3.createProcessTelemetryContext = createProcessTelemetryContext;
      exports3.createTraceParent = createTraceParent;
      exports3.createUniqueNamespace = createUniqueNamespace;
      exports3.createUnloadHandlerContainer = createUnloadHandlerContainer;
      exports3.dateNow = utcNow;
      exports3.detachEvent = detachEvent;
      exports3.disallowsSameSiteNone = uaDisallowsSameSiteNone;
      exports3.doPerf = doPerf;
      exports3.dumpObj = dumpObj;
      exports3.eventOff = eventOff;
      exports3.eventOn = eventOn;
      exports3.extend = extend;
      exports3.findW3cTraceParent = findW3cTraceParent;
      exports3.forceDynamicConversion = forceDynamicConversion;
      exports3.formatErrorMessageXdr = formatErrorMessageXdr;
      exports3.formatErrorMessageXhr = formatErrorMessageXhr;
      exports3.formatTraceParent = formatTraceParent;
      exports3.generateW3CId = generateW3CId;
      exports3.getCommonSchemaMetaData = getCommonSchemaMetaData;
      exports3.getConsole = getConsole;
      exports3.getCookieValue = getCookieValue;
      exports3.getCrypto = getCrypto;
      exports3.getDocument = getDocument;
      exports3.getDynamicConfigHandler = getDynamicConfigHandler;
      exports3.getExceptionName = getExceptionName;
      exports3.getFieldValueType = getFieldValueType;
      exports3.getGlobal = getGlobal;
      exports3.getGlobalInst = getInst;
      exports3.getHistory = getHistory;
      exports3.getIEVersion = getIEVersion;
      exports3.getISOString = toISOString;
      exports3.getJSON = getJSON;
      exports3.getLocation = getLocation;
      exports3.getMsCrypto = getMsCrypto;
      exports3.getNavigator = getNavigator;
      exports3.getPerformance = getPerformance;
      exports3.getResponseText = getResponseText;
      exports3.getSetValue = getSetValue;
      exports3.getTenantId = getTenantId;
      exports3.getTime = getTime;
      exports3.getWindow = getWindow;
      exports3.hasDocument = hasDocument;
      exports3.hasHistory = hasHistory;
      exports3.hasJSON = hasJSON;
      exports3.hasNavigator = hasNavigator;
      exports3.hasOwnProperty = objHasOwnProperty;
      exports3.hasWindow = hasWindow;
      exports3.isArray = isArray;
      exports3.isArrayValid = isArrayValid;
      exports3.isBeaconsSupported = isBeaconsSupported;
      exports3.isBoolean = isBoolean;
      exports3.isChromium = isChromium;
      exports3.isDate = isDate;
      exports3.isDocumentObjectAvailable = isDocumentObjectAvailable;
      exports3.isError = isError;
      exports3.isFeatureEnabled = isFeatureEnabled;
      exports3.isFetchSupported = isFetchSupported;
      exports3.isFunction = isFunction;
      exports3.isGreaterThanZero = isGreaterThanZero;
      exports3.isIE = isIE;
      exports3.isLatency = isLatency;
      exports3.isNotTruthy = isNotTruthy;
      exports3.isNullOrUndefined = isNullOrUndefined;
      exports3.isNumber = isNumber;
      exports3.isObject = isObject;
      exports3.isReactNative = isReactNative;
      exports3.isSampledFlag = isSampledFlag;
      exports3.isString = isString;
      exports3.isTruthy = isTruthy;
      exports3.isTypeof = isTypeof;
      exports3.isUint8ArrayAvailable = isUint8ArrayAvailable;
      exports3.isUndefined = isUndefined;
      exports3.isValidSpanId = isValidSpanId;
      exports3.isValidTraceId = isValidTraceId;
      exports3.isValidTraceParent = isValidTraceParent;
      exports3.isValueAssigned = isValueAssigned;
      exports3.isValueKind = isValueKind;
      exports3.isWindowObjectAvailable = isWindowObjectAvailable;
      exports3.isXhrSupported = isXhrSupported;
      exports3.mergeEvtNamespace = mergeEvtNamespace;
      exports3.newGuid = newGuid;
      exports3.newId = newId;
      exports3.normalizeJsName = normalizeJsName;
      exports3.objDefineAccessors = objDefineAccessors;
      exports3.objForEachKey = objForEachKey;
      exports3.objFreeze = objFreeze;
      exports3.objKeys = objKeys;
      exports3.objSeal = objSeal;
      exports3.onConfigChange = onConfigChange;
      exports3.openXhr = openXhr;
      exports3.optimizeObject = optimizeObject;
      exports3.parseResponse = parseResponse;
      exports3.parseTraceParent = parseTraceParent;
      exports3.perfNow = perfNow;
      exports3.prependTransports = prependTransports;
      exports3.proxyAssign = proxyAssign;
      exports3.proxyFunctionAs = proxyFunctionAs;
      exports3.proxyFunctions = proxyFunctions;
      exports3.random32 = random32;
      exports3.randomValue = randomValue;
      exports3.removeEventHandler = removeEventHandler;
      exports3.removeEventListeners = removeEventListeners;
      exports3.removePageHideEventListener = removePageHideEventListener;
      exports3.removePageShowEventListener = removePageShowEventListener;
      exports3.removePageUnloadEventListener = removePageUnloadEventListener;
      exports3.safeGetCookieMgr = safeGetCookieMgr;
      exports3.safeGetLogger = safeGetLogger;
      exports3.sanitizeProperty = sanitizeProperty;
      exports3.setEnableEnvMocks = setEnableEnvMocks;
      exports3.setProcessTelemetryTimings = setProcessTelemetryTimings;
      exports3.setValue = setValue;
      exports3.strContains = strContains;
      exports3.strEndsWith = strEndsWith;
      exports3.strFunction = strShimFunction;
      exports3.strObject = strShimObject;
      exports3.strPrototype = strShimPrototype;
      exports3.strStartsWith = strStartsWith;
      exports3.strTrim = strTrim;
      exports3.strUndefined = strShimUndefined;
      exports3.throwError = throwError;
      exports3.toISOString = toISOString;
      exports3.useXDomainRequest = useXDomainRequest;
    });
  }
});

// node_modules/@microsoft/1ds-post-js/dist/es5/ms.post.js
var require_ms_post = __commonJS({
  "node_modules/@microsoft/1ds-post-js/dist/es5/ms.post.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.oneDS = global2.oneDS || {}));
    })(exports2, function(exports3) {
      "use strict";
      var RT_PROFILE = "REAL_TIME";
      var NRT_PROFILE = "NEAR_REAL_TIME";
      var BE_PROFILE = "BEST_EFFORT";
      var strShimFunction = "function";
      var strShimObject = "object";
      var strShimUndefined = "undefined";
      var strShimPrototype = "prototype";
      var ObjClass$1 = Object;
      var ObjProto$1 = ObjClass$1[strShimPrototype];
      // @__NO_SIDE_EFFECTS__
      function _pureAssign(func1, func2) {
        return func1 || func2;
      }
      // @__NO_SIDE_EFFECTS__
      function _pureRef(value, name) {
        return value[name];
      }
      var UNDEF_VALUE = void 0;
      var NULL_VALUE = null;
      var EMPTY = "";
      var FUNCTION = "function";
      var OBJECT = "object";
      var PROTOTYPE = "prototype";
      var __PROTO__ = "__proto__";
      var UNDEFINED = "undefined";
      var CONSTRUCTOR = "constructor";
      var SYMBOL = "Symbol";
      var LENGTH = "length";
      var NAME = "name";
      var CALL = "call";
      var TO_STRING = "toString";
      var GET_OWN_PROPERTY_DESCRIPTOR = "getOwnPropertyDescriptor";
      var ObjClass = /* @__PURE__ */ _pureAssign(Object);
      var ObjProto = /* @__PURE__ */ _pureRef(ObjClass, PROTOTYPE);
      var StrCls = /* @__PURE__ */ _pureAssign(String);
      var StrProto = /* @__PURE__ */ _pureRef(StrCls, PROTOTYPE);
      var MathCls = /* @__PURE__ */ _pureAssign(Math);
      var ArrCls = /* @__PURE__ */ _pureAssign(Array);
      var ArrProto = /* @__PURE__ */ _pureRef(ArrCls, PROTOTYPE);
      var ArrSlice = /* @__PURE__ */ _pureRef(ArrProto, "slice");
      var POLYFILL_TAG = "_polyfill";
      var POLYFILL_TYPE_NAME = "__nw21$polytype__";
      function safe(func, argArray) {
        try {
          return {
            v: func.apply(this, argArray)
          };
        } catch (e) {
          return { e };
        }
      }
      // @__NO_SIDE_EFFECTS__
      function _createIs(theType) {
        return function(value) {
          return typeof value === theType;
        };
      }
      // @__NO_SIDE_EFFECTS__
      function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictUndefined(arg) {
        return arg === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isNullOrUndefined(value) {
        return value === NULL_VALUE || /* @__PURE__ */ isUndefined(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || value === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
      }
      var isString = /* @__PURE__ */ _createIs("string");
      var isFunction = /* @__PURE__ */ _createIs(FUNCTION);
      // @__NO_SIDE_EFFECTS__
      function isObject(value) {
        if (!value && /* @__PURE__ */ isNullOrUndefined(value)) {
          return false;
        }
        return !!value && typeof value === OBJECT;
      }
      var isArray = /* @__PURE__ */ _pureRef(ArrCls, "isArray");
      var isNumber = /* @__PURE__ */ _createIs("number");
      var isBoolean = /* @__PURE__ */ _createIs("boolean");
      // @__NO_SIDE_EFFECTS__
      function isPromiseLike(value) {
        return !!(value && value.then && isFunction(value.then));
      }
      function _returnNothing() {
        return;
      }
      function _returnFalse() {
        return false;
      }
      var asString = /* @__PURE__ */ _pureAssign(StrCls);
      var ERROR_TYPE = "[object Error]";
      // @__NO_SIDE_EFFECTS__
      function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
          object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
          propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format === "number" ? format : 4 : UNDEF_VALUE);
          propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
        } catch (e) {
          propertyValueDump = " - " + /* @__PURE__ */ dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
      }
      function throwTypeError(message) {
        throw new TypeError(message);
      }
      function _throwIfNullOrUndefined(obj) {
        if (/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          throwTypeError("Cannot convert undefined or null to object");
        }
      }
      function _throwIfNotString(value) {
        if (!isString(value)) {
          throwTypeError("'" + /* @__PURE__ */ dumpObj(value) + "' is not a string");
        }
      }
      // @__NO_SIDE_EFFECTS__
      function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
      }
      var _objGetOwnPropertyDescriptor$2 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var objHasOwn = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "hasOwn"), polyObjHasOwn);
      // @__NO_SIDE_EFFECTS__
      function polyObjHasOwn(obj, prop) {
        _throwIfNullOrUndefined(obj);
        return /* @__PURE__ */ objHasOwnProperty(obj, prop) || !!_objGetOwnPropertyDescriptor$2(obj, prop);
      }
      function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && (/* @__PURE__ */ isObject(theObject) || isFunction(theObject))) {
          for (var prop in theObject) {
            if (objHasOwn(theObject, prop)) {
              if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                break;
              }
            }
          }
        }
      }
      function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
          var len = theArray[LENGTH] >>> 0;
          for (var idx = 0; idx < len; idx++) {
            if (idx in theArray) {
              if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                break;
              }
            }
          }
        }
      }
      var _unwrapFunction = _unwrapFunctionWithPoly;
      // @__NO_SIDE_EFFECTS__
      function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
        return function(thisArg) {
          var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
          if (theFunc || polyFunc) {
            var theArgs = arguments;
            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
          }
          throwTypeError('"' + asString(funcName) + '" not defined for ' + /* @__PURE__ */ dumpObj(thisArg));
        };
      }
      var _objGetOwnPropertyDescriptor$1 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
      };
      // @__NO_SIDE_EFFECTS__
      function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
          prop.get = function() {
            return value.l.v;
          };
          var desc = _objGetOwnPropertyDescriptor$1(value.l, "v");
          if (desc && desc.set) {
            prop.set = function(newValue) {
              value.l.v = newValue;
            };
          }
        }
        objForEachKey(value, function(key, value2) {
          prop[propMap[key]] = /* @__PURE__ */ isStrictUndefined(value2) ? prop[propMap[key]] : value2;
        });
        return prop;
      }
      var objDefineProp = /* @__PURE__ */ _pureRef(ObjClass, "defineProperty");
      var objDefineProperties = /* @__PURE__ */ _pureRef(ObjClass, "defineProperties");
      function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, /* @__PURE__ */ _createProp(propDesc));
      }
      // @__NO_SIDE_EFFECTS__
      function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
        var theMap = {};
        objForEachKey(values, function(key, value) {
          _assignMapValue(theMap, key, keyType ? value : key);
          _assignMapValue(theMap, value, valueType ? value : key);
        });
        return completeFn ? completeFn(theMap) : theMap;
      }
      function _assignMapValue(theMap, key, value, writable) {
        objDefineProp(theMap, key, {
          value,
          enumerable: true,
          writable: false
        });
      }
      var objIsFrozen = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "isFrozen"), _returnFalse);
      var _objFreeze = /* @__PURE__ */ _pureRef(ObjClass, "freeze");
      function _doNothing(value) {
        return value;
      }
      // @__NO_SIDE_EFFECTS__
      function _getProto(value) {
        _throwIfNullOrUndefined(value);
        return value[__PROTO__] || NULL_VALUE;
      }
      var objAssign = /* @__PURE__ */ _pureRef(ObjClass, "assign");
      var objKeys = /* @__PURE__ */ _pureRef(ObjClass, "keys");
      function _deepFreeze(val, visited) {
        if ((isArray(val) || /* @__PURE__ */ isObject(val) || isFunction(val)) && !objIsFrozen(val)) {
          for (var lp = 0; lp < visited.length; lp++) {
            if (visited[lp] === val) {
              return val;
            }
          }
          visited.push(val);
          objForEachKey(val, function(_key, propValue) {
            _deepFreeze(propValue, visited);
          });
          objFreeze(val);
        }
        return val;
      }
      function objDeepFreeze(value) {
        return _objFreeze ? _deepFreeze(value, []) : value;
      }
      var objFreeze = /* @__PURE__ */ _pureAssign(_objFreeze, _doNothing);
      var objGetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "getPrototypeOf"), _getProto);
      // @__NO_SIDE_EFFECTS__
      function createEnum(values) {
        return /* @__PURE__ */ _createKeyValueMap(values, 1, 0, objFreeze);
      }
      // @__NO_SIDE_EFFECTS__
      function createEnumKeyMap(values) {
        return /* @__PURE__ */ _createKeyValueMap(values, 0, 0, objFreeze);
      }
      var _wellKnownSymbolMap = /* @__PURE__ */ createEnumKeyMap({
        asyncIterator: 0,
        hasInstance: 1,
        isConcatSpreadable: 2,
        iterator: 3,
        match: 4,
        matchAll: 5,
        replace: 6,
        search: 7,
        species: 8,
        split: 9,
        toPrimitive: 10,
        toStringTag: 11,
        unscopables: 12
      });
      var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
      var _globalCfg;
      // @__NO_SIDE_EFFECTS__
      function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
          result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
          result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
          result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
          result = global;
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function _getGlobalConfig() {
        if (!_globalCfg) {
          var gbl = safe(_getGlobalValue).v || {};
          _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
      }
      var mathMin = /* @__PURE__ */ _pureRef(MathCls, "min");
      var mathMax = /* @__PURE__ */ _pureRef(MathCls, "max");
      var strSlice = /* @__PURE__ */ _unwrapFunction("slice", StrProto);
      var strSubstring = /* @__PURE__ */ _unwrapFunction("substring", StrProto);
      var strSubstr = /* @__PURE__ */ _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
      // @__NO_SIDE_EFFECTS__
      function polyStrSubstr(value, start, length) {
        _throwIfNullOrUndefined(value);
        if (length < 0) {
          return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
          start = mathMax(start + value[LENGTH], 0);
        }
        if (/* @__PURE__ */ isUndefined(length)) {
          return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
      }
      // @__NO_SIDE_EFFECTS__
      function strLeft(value, count) {
        return strSubstring(value, 0, count);
      }
      function _tagAsPolyfill(target, polyfillTypeName) {
        if (target) {
          safe(function() {
            target[POLYFILL_TAG] = true;
            target[POLYFILL_TYPE_NAME] = polyfillTypeName;
          });
          safe(objDefine, [target, POLYFILL_TAG, {
            v: true,
            w: false,
            e: false
          }]);
          safe(objDefine, [target, POLYFILL_TYPE_NAME, {
            v: polyfillTypeName,
            w: false,
            e: false
          }]);
        }
        return target;
      }
      var objCreate = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "create"), polyObjCreate);
      // @__NO_SIDE_EFFECTS__
      function polyObjCreate(obj, properties) {
        var newObj = null;
        function tempFunc() {
        }
        if (!/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          var type = typeof obj;
          if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + /* @__PURE__ */ dumpObj(obj));
          }
          tempFunc[PROTOTYPE] = obj;
          safe(function() {
            tempFunc[__PROTO__] = obj;
          });
          newObj = new tempFunc();
        } else {
          newObj = {};
        }
        if (properties) {
          safe(objDefineProperties, [newObj, properties]);
        }
        return newObj;
      }
      // @__NO_SIDE_EFFECTS__
      function utcNow() {
        return (Date.now || polyUtcNow)();
      }
      // @__NO_SIDE_EFFECTS__
      function polyUtcNow() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
      function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
      }
      var _globalLazyTestHooks;
      function _initTestHooks() {
        _globalLazyTestHooks = /* @__PURE__ */ _getGlobalConfig();
      }
      // @__NO_SIDE_EFFECTS__
      function getLazy(cb, argArray) {
        var lazyValue = {};
        !_globalLazyTestHooks && _initTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
          configurable: true,
          get: function() {
            var result = fnApply(cb, null, argArray);
            if (!_globalLazyTestHooks.lzy) {
              objDefineProp(lazyValue, "v", {
                value: result
              });
            }
            lazyValue.b = _globalLazyTestHooks.lzy;
            return result;
          }
        });
        return lazyValue;
      }
      var mathRandom = /* @__PURE__ */ _pureRef(MathCls, "random");
      var _uniqueInstanceId = /* @__PURE__ */ getLazy(function() {
        var value = (/* @__PURE__ */ utcNow()).toString(36).slice(2);
        while (value.length < 16) {
          value += mathRandom().toString(36).slice(2);
        }
        value = value.substring(0, 16);
        return value;
      });
      var UNIQUE_REGISTRY_ID = "_urid";
      var POLY_SYM = "$nw21sym";
      var _polySymbols;
      var _polyId = 0;
      // @__NO_SIDE_EFFECTS__
      function _globalSymbolRegistry() {
        if (!_polySymbols) {
          var gblCfg = /* @__PURE__ */ _getGlobalConfig();
          _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
      }
      var _wellKnownSymbolCache;
      // @__NO_SIDE_EFFECTS__
      function polyNewSymbol(description) {
        var uniqueId = "_" + _polyId++ + "_" + _uniqueInstanceId.v;
        var symString = SYMBOL + "(" + description + ")";
        function _setProp(name, value) {
          objDefine(theSymbol, name, {
            v: value,
            e: false,
            w: false
          });
        }
        var theSymbol = objCreate(null);
        _setProp("description", asString(description));
        _setProp(TO_STRING, function() {
          return symString + POLY_SYM + uniqueId;
        });
        _setProp("valueOf", function() {
          return theSymbol;
        });
        _setProp("v", symString);
        _setProp("_uid", uniqueId);
        return _tagAsPolyfill(theSymbol, "symbol");
      }
      // @__NO_SIDE_EFFECTS__
      function polySymbolFor(key) {
        var registry = /* @__PURE__ */ _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
          var newSymbol_1 = /* @__PURE__ */ polyNewSymbol(key);
          var regId_1 = objKeys(registry.s).length;
          newSymbol_1[UNIQUE_REGISTRY_ID] = function() {
            return regId_1 + "_" + newSymbol_1[TO_STRING]();
          };
          registry.k[key] = newSymbol_1;
          registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
      }
      // @__NO_SIDE_EFFECTS__
      function polyGetKnownSymbol(name) {
        !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
          result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || /* @__PURE__ */ polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function createCachedValue(value) {
        return objDefineProp({
          toJSON: function() {
            return value;
          }
        }, "v", { value });
      }
      var WINDOW = "window";
      var _cachedGlobal;
      function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function() {
          !_globalLazyTestHooks && _initTestHooks();
          if (!cachedValue || _globalLazyTestHooks.lzy) {
            cachedValue = /* @__PURE__ */ createCachedValue(safe(getFn, theArgs).v);
          }
          return cachedValue.v;
        };
      }
      function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        if (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) {
          _cachedGlobal = /* @__PURE__ */ createCachedValue(safe(_getGlobalValue).v || NULL_VALUE);
        }
        return _cachedGlobal.v;
      }
      // @__NO_SIDE_EFFECTS__
      function getInst(name, useCached) {
        var gbl;
        if (!_cachedGlobal || useCached === false) {
          gbl = getGlobal(useCached);
        } else {
          gbl = _cachedGlobal.v;
        }
        if (gbl && gbl[name]) {
          return gbl[name];
        }
        if (name === WINDOW) {
          try {
            return window;
          } catch (e) {
          }
        }
        return NULL_VALUE;
      }
      var getDocument = /* @__PURE__ */ _getGlobalInstFn(getInst, ["document"]);
      // @__NO_SIDE_EFFECTS__
      function hasWindow() {
        return !!/* @__PURE__ */ getWindow();
      }
      var getWindow = /* @__PURE__ */ _getGlobalInstFn(getInst, [WINDOW]);
      // @__NO_SIDE_EFFECTS__
      function hasNavigator() {
        return !!/* @__PURE__ */ getNavigator();
      }
      var getNavigator = /* @__PURE__ */ _getGlobalInstFn(getInst, ["navigator"]);
      var isNode = /* @__PURE__ */ _getGlobalInstFn(function() {
        return !!safe(function() {
          return process && (process.versions || {}).node;
        }).v;
      });
      var _symbol;
      var _symbolFor;
      // @__NO_SIDE_EFFECTS__
      function _initSymbol() {
        _symbol = /* @__PURE__ */ createCachedValue(safe(getInst, [SYMBOL]).v);
        return _symbol;
      }
      function _getSymbolKey(key) {
        var gblSym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return gblSym.v ? gblSym.v[key] : UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function hasSymbol() {
        return !!/* @__PURE__ */ getSymbol();
      }
      // @__NO_SIDE_EFFECTS__
      function getSymbol() {
        !_globalLazyTestHooks && _initTestHooks();
        return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol()).v;
      }
      // @__NO_SIDE_EFFECTS__
      function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        !_globalLazyTestHooks && _initTestHooks();
        var sym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return sym.v ? sym.v[knownName || name] : !noPoly ? /* @__PURE__ */ polyGetKnownSymbol(name) : UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return sym.v ? sym.v(description) : !noPoly ? /* @__PURE__ */ polyNewSymbol(description) : NULL_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = (!_globalLazyTestHooks.lzy ? _symbolFor : 0) || /* @__PURE__ */ createCachedValue(safe(_getSymbolKey, ["for"]).v);
        return (_symbolFor.v || polySymbolFor)(key);
      }
      // @__NO_SIDE_EFFECTS__
      function isIterator(value) {
        return !!value && isFunction(value.next);
      }
      // @__NO_SIDE_EFFECTS__
      function isIterable(value) {
        return !/* @__PURE__ */ isStrictNullOrUndefined(value) && isFunction(value[/* @__PURE__ */ getKnownSymbol(3)]);
      }
      var _iterSymbol$1;
      function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
          if (!/* @__PURE__ */ isIterator(iter)) {
            !_iterSymbol$1 && (_iterSymbol$1 = /* @__PURE__ */ createCachedValue(/* @__PURE__ */ getKnownSymbol(3)));
            iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : NULL_VALUE;
          }
          if (/* @__PURE__ */ isIterator(iter)) {
            var err = UNDEF_VALUE;
            var iterResult = UNDEF_VALUE;
            try {
              var count = 0;
              while (!(iterResult = iter.next()).done) {
                if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                  break;
                }
                count++;
              }
            } catch (failed) {
              err = { e: failed };
              if (iter.throw) {
                iterResult = NULL_VALUE;
                iter.throw(err);
              }
            } finally {
              try {
                if (iterResult && !iterResult.done) {
                  iter.return && iter.return(iterResult);
                }
              } finally {
                if (err) {
                  throw err.e;
                }
              }
            }
          }
        }
      }
      function arrAppend(target, elms) {
        if (!/* @__PURE__ */ isUndefined(elms) && target) {
          if (isArray(elms)) {
            fnApply(target.push, target, elms);
          } else if (/* @__PURE__ */ isIterator(elms) || /* @__PURE__ */ isIterable(elms)) {
            iterForOf(elms, function(elm) {
              target.push(elm);
            });
          } else {
            target.push(elms);
          }
        }
        return target;
      }
      var arrIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", ArrProto);
      function arrSlice(theArray, start, end) {
        return ((theArray ? theArray["slice"] : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
      }
      var _isProtoArray;
      var objSetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, "setPrototypeOf"), _polyObjSetPrototypeOf);
      function _polyObjSetPrototypeOf(obj, proto) {
        var _a2;
        !_isProtoArray && (_isProtoArray = /* @__PURE__ */ createCachedValue((_a2 = {}, _a2[__PROTO__] = [], _a2) instanceof Array));
        _isProtoArray.v ? obj[__PROTO__] = proto : objForEachKey(proto, function(key, value) {
          return obj[key] = value;
        });
        return obj;
      }
      // @__NO_SIDE_EFFECTS__
      function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
          this[CONSTRUCTOR] = d;
          safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
      }
      function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
      }
      // @__NO_SIDE_EFFECTS__
      function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return /* @__PURE__ */ _createCustomError(name, function() {
          var _this = this;
          var theArgs = arguments;
          try {
            safe(_setName, [theBaseClass, name]);
            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
            if (_self !== _this) {
              var orgProto = objGetPrototypeOf(_this);
              if (orgProto !== objGetPrototypeOf(_self)) {
                objSetPrototypeOf(_self, orgProto);
              }
            }
            captureFn && captureFn(_self, _this[CONSTRUCTOR]);
            constructCb && constructCb(_self, theArgs);
            return _self;
          } finally {
            safe(_setName, [theBaseClass, orgName]);
          }
        }, theBaseClass);
      }
      // @__NO_SIDE_EFFECTS__
      function _createTrimFn(exp) {
        return function _doTrim(value) {
          _throwIfNullOrUndefined(value);
          if (value && value.replace) {
            value = value.replace(exp, EMPTY);
          }
          return value;
        };
      }
      var polyStrTrim = /* @__PURE__ */ _createTrimFn(/^\s+|(?=\s)\s+$/g);
      var strTrim = /* @__PURE__ */ _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim);
      var mathFloor = /* @__PURE__ */ _pureRef(MathCls, "floor");
      var mathCeil = /* @__PURE__ */ _pureRef(MathCls, "ceil");
      var _fnToString;
      var _objCtrFnString;
      var _gblWindow;
      // @__NO_SIDE_EFFECTS__
      function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
          return false;
        }
        if (!_gblWindow) {
          _gblWindow = /* @__PURE__ */ hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
          if (!_objCtrFnString) {
            _fnToString = Function[PROTOTYPE][TO_STRING];
            _objCtrFnString = _fnToString[CALL](ObjClass);
          }
          try {
            var proto = objGetPrototypeOf(value);
            result = !proto;
            if (!result) {
              if (/* @__PURE__ */ objHasOwnProperty(proto, CONSTRUCTOR)) {
                proto = proto[CONSTRUCTOR];
              }
              result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);
            }
          } catch (ex) {
          }
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function perfNow() {
        return /* @__PURE__ */ utcNow();
      }
      var objGetOwnPropertyDescriptor = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var strIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", StrProto);
      var strStartsWith = /* @__PURE__ */ _unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith);
      // @__NO_SIDE_EFFECTS__
      function polyStrStartsWith(value, searchString, position) {
        _throwIfNotString(value);
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var pos = position > 0 ? position : 0;
        return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;
      }
      var REF = "ref";
      var UNREF = "unref";
      var HAS_REF = "hasRef";
      var ENABLED = "enabled";
      // @__NO_SIDE_EFFECTS__
      function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
          ref = false;
          timerId && timerId[UNREF] && timerId[UNREF]();
          return theTimerHandler;
        }
        function _cancel() {
          timerId && cancelFn(timerId);
          timerId = NULL_VALUE;
        }
        function _refresh() {
          timerId = refreshFn(timerId);
          if (!ref) {
            _unref();
          }
          return theTimerHandler;
        }
        function _setEnabled(value) {
          !value && timerId && _cancel();
          value && !timerId && _refresh();
        }
        theTimerHandler = {
          cancel: _cancel,
          refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function() {
          if (timerId && timerId[HAS_REF]) {
            return timerId[HAS_REF]();
          }
          return ref;
        };
        theTimerHandler[REF] = function() {
          ref = true;
          timerId && timerId[REF] && timerId[REF]();
          return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
          get: function() {
            return !!timerId;
          },
          set: _setEnabled
        });
        return {
          h: theTimerHandler,
          dn: function() {
            timerId = NULL_VALUE;
          }
        };
      }
      var _setTimeoutFn;
      var _clearTimeoutFn;
      function _resolveTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _setTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 0 && isFunction(globalOverrides[0])) {
            result = globalOverrides[0];
          }
        }
        return result || setTimeout;
      }
      function _resolveClearTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _clearTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 1 && isFunction(globalOverrides[1])) {
            result = globalOverrides[1];
          }
        }
        return result || clearTimeout;
      }
      function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = _resolveTimeoutFn(len > 0 ? overrideFn[0] : !isArr ? overrideFn : UNDEF_VALUE);
        var clearFn = _resolveClearTimeoutFn(len > 1 ? overrideFn[1] : UNDEF_VALUE);
        var timerFn = theArgs[0];
        theArgs[0] = function() {
          handler.dn();
          fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = /* @__PURE__ */ _createTimerHandler(startTimer, function(timerId) {
          if (timerId) {
            if (timerId.refresh) {
              timerId.refresh();
              return timerId;
            }
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
          }
          return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function(timerId) {
          fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
      }
      function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
      }
      function scheduleTimeoutWith(overrideFn, callback, timeout) {
        return _createTimeoutWith(true, overrideFn, ArrSlice[CALL](arguments, 1));
      }
      (getGlobal() || {})["Symbol"];
      (getGlobal() || {})["Reflect"];
      var strHasOwnProperty = "hasOwnProperty";
      var extendStaticsFn = function(d, b) {
        extendStaticsFn = ObjClass$1["setPrototypeOf"] || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2[strHasOwnProperty](p)) {
              d2[p] = b2[p];
            }
          }
        };
        return extendStaticsFn(d, b);
      };
      function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
          throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
          this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
      }
      var _a$4;
      var Constructor = "constructor";
      var Prototype = "prototype";
      var strFunction = "function";
      var DynInstFuncTable = "_dynInstFuncs";
      var DynProxyTag = "_isDynProxy";
      var DynClassName = "_dynClass";
      var DynClassNamePrefix = "_dynCls$";
      var DynInstChkTag = "_dynInstChk";
      var DynAllowInstChkTag = DynInstChkTag;
      var DynProtoDefaultOptions = "_dfOpts";
      var UnknownValue = "_unknown_";
      var str__Proto = "__proto__";
      var DynProtoBaseProto = "_dyn" + str__Proto;
      var DynProtoGlobalSettings = "__dynProto$Gbl";
      var DynProtoCurrent = "_dynInstProto";
      var strUseBaseInst = "useBaseInst";
      var strSetInstFuncs = "setInstFuncs";
      var Obj = Object;
      var _objGetPrototypeOf = Obj["getPrototypeOf"];
      var _objGetOwnProps = Obj["getOwnPropertyNames"];
      var _gbl = getGlobal();
      var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$4 = {}, _a$4[strSetInstFuncs] = true, _a$4[strUseBaseInst] = true, _a$4),
        n: 1e3
      });
      function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
      }
      function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
      }
      function _getObjProto(target) {
        var newProto;
        if (target) {
          if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
          }
          var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
          newProto = target[DynProtoBaseProto] || curProto;
          if (!/* @__PURE__ */ objHasOwnProperty(target, DynProtoBaseProto)) {
            delete target[DynProtoCurrent];
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
          }
        }
        return newProto;
      }
      function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
          props = _objGetOwnProps(target);
        } else {
          for (var name_1 in target) {
            if (typeof name_1 === "string" && /* @__PURE__ */ objHasOwnProperty(target, name_1)) {
              props.push(name_1);
            }
          }
        }
        if (props && props.length > 0) {
          for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
          }
        }
      }
      function _isDynamicCandidate(target, funcName, skipOwn) {
        return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || /* @__PURE__ */ objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
      }
      function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
      }
      function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function(name) {
          if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
            instFuncs[name] = thisTarget[name];
          }
        });
        return instFuncs;
      }
      function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
          if (values[lp] === value) {
            return true;
          }
        }
        return false;
      }
      function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
          var theFunc = funcHost[funcName];
          if (theFunc[DynProxyTag] && useBaseInst) {
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
          }
          return function() {
            return theFunc.apply(target, arguments);
          };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function(name) {
          baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
          _forEachProp(baseProto, function(name) {
            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
              baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
            }
          });
          visited.push(baseProto);
          baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
      }
      function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && /* @__PURE__ */ objHasOwnProperty(proto, DynClassName)) {
          var instFuncTable = target[DynInstFuncTable] || objCreate(null);
          instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
          if (!instFunc) {
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
          }
          if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            var canAddInst = !/* @__PURE__ */ objHasOwnProperty(target, funcName);
            var objProto = _getObjProto(target);
            var visited = [];
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
              var protoFunc = objProto[funcName];
              if (protoFunc) {
                canAddInst = protoFunc === currentDynProtoProxy;
                break;
              }
              visited.push(objProto);
              objProto = _getObjProto(objProto);
            }
            try {
              if (canAddInst) {
                target[funcName] = instFunc;
              }
              instFunc[DynInstChkTag] = 1;
            } catch (e) {
              instFuncTable[DynAllowInstChkTag] = false;
            }
          }
        }
        return instFunc;
      }
      function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
          protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
          _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
      }
      function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto2, funcName) {
          var dynProtoProxy = function() {
            var instFunc = _getInstFunc(this, funcName, proto2, dynProtoProxy) || _getProtoFunc(funcName, proto2, dynProtoProxy);
            return instFunc.apply(this, arguments);
          };
          dynProtoProxy[DynProxyTag] = 1;
          return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
          var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
          if (!_isObjectOrArrayPrototype(instFuncTable)) {
            var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
            }
            if (!_isObjectOrArrayPrototype(instFuncs_1)) {
              _forEachProp(target, function(name) {
                if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                  instFuncs_1[name] = target[name];
                  delete target[name];
                  if (!/* @__PURE__ */ objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) {
                    proto[name] = _createDynamicPrototype(proto, name);
                  }
                }
              });
            }
          }
        }
      }
      function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
          var visited = [];
          var thisProto = _getObjProto(thisTarget);
          while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
              return true;
            }
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
          }
          return false;
        }
        return true;
      }
      function _getObjName(target, unknownValue) {
        if (/* @__PURE__ */ objHasOwnProperty(target, Prototype)) {
          return target.name || unknownValue || UnknownValue;
        }
        return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
      }
      function dynamicProto(theClass, target, delegateFunc, options) {
        if (!/* @__PURE__ */ objHasOwnProperty(theClass, Prototype)) {
          _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
          _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (/* @__PURE__ */ objHasOwnProperty(classProto, DynClassName)) {
          className = classProto[DynClassName];
        } else {
          className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
          _gblInst.n++;
          classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== void 0) {
          useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
          setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
      }
      dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
      var createEnumStyle = createEnum;
      var EventsDiscardedReason = createEnumStyle({
        Unknown: 0,
        NonRetryableStatus: 1,
        InvalidEvent: 2,
        SizeLimitExceeded: 3,
        KillSwitch: 4,
        QueueFull: 5
      });
      var _DYN_TO_LOWER_CASE$1 = "toLowerCase";
      var _DYN_LENGTH$2 = "length";
      var _DYN_WARN_TO_CONSOLE = "warnToConsole";
      var _DYN_THROW_INTERNAL = "throwInternal";
      var _DYN_WATCH = "watch";
      var _DYN_APPLY = "apply";
      var _DYN_PUSH$1 = "push";
      var _DYN_SPLICE = "splice";
      var _DYN_LOGGER = "logger";
      var _DYN_CANCEL = "cancel";
      var _DYN_INITIALIZE$1 = "initialize";
      var _DYN_IDENTIFIER$1 = "identifier";
      var _DYN_IS_INITIALIZED = "isInitialized";
      var _DYN_GET_PLUGIN = "getPlugin";
      var _DYN_NAME = "name";
      var _DYN_PROCESS_NEXT = "processNext";
      var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext";
      var _DYN_VALUE$1 = "value";
      var _DYN_UNLOAD = "unload";
      var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
      var _DYN_CREATE_NEW = "createNew";
      var _DYN_TEARDOWN = "teardown";
      var _DYN_MESSAGE_ID = "messageId";
      var _DYN_MESSAGE = "message";
      var _DYN_DIAG_LOG = "diagLog";
      var _DYN__DO_TEARDOWN = "_doTeardown";
      var _DYN_UPDATE = "update";
      var _DYN_GET_NEXT = "getNext";
      var _DYN_SET_NEXT_PLUGIN = "setNextPlugin";
      var _DYN_USER_AGENT = "userAgent";
      var _DYN_SPLIT$1 = "split";
      var _DYN_REPLACE = "replace";
      var _DYN_TYPE = "type";
      var _DYN_EVT_NAME = "evtName";
      var _DYN_STATUS = "status";
      var _DYN_INDEX_OF = "indexOf";
      var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders";
      var _DYN_IS_CHILD_EVT = "isChildEvt";
      var _DYN_DATA = "data";
      var _DYN_GET_CTX = "getCtx";
      var _DYN_SET_CTX = "setCtx";
      var _DYN_HEADERS$1 = "headers";
      var _DYN_URL_STRING = "urlString";
      var _DYN_TIMEOUT = "timeout";
      var aggregationErrorType;
      function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
          aggregationErrorType = /* @__PURE__ */ createCustomError("AggregationError", function(self2, args) {
            if (args[_DYN_LENGTH$2] > 1) {
              self2.errors = args[1];
            }
          });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function(srcError, idx) {
          theMessage += "\n".concat(idx, " > ").concat(/* @__PURE__ */ dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
      }
      var STR_PROMISE = "Promise";
      var REJECTED = "rejected";
      function doAwaitResponse(value, cb) {
        return doAwait(value, function(value2) {
          return cb ? cb({
            status: "fulfilled",
            rejected: false,
            value: value2
          }) : value2;
        }, function(reason) {
          return cb ? cb({
            status: REJECTED,
            rejected: true,
            reason
          }) : reason;
        });
      }
      function doAwait(value, resolveFn, rejectFn, finallyFn) {
        var result = value;
        try {
          if (/* @__PURE__ */ isPromiseLike(value)) {
            if (resolveFn || rejectFn) {
              result = value.then(resolveFn, rejectFn);
            }
          } else {
            try {
              if (resolveFn) {
                result = resolveFn(value);
              }
            } catch (err) {
              if (rejectFn) {
                result = rejectFn(err);
              } else {
                throw err;
              }
            }
          }
        } finally {
          if (finallyFn) {
            doFinally(result, finallyFn);
          }
        }
        return result;
      }
      function doFinally(value, finallyFn) {
        var result = value;
        if (finallyFn) {
          if (/* @__PURE__ */ isPromiseLike(value)) {
            if (value.finally) {
              result = value.finally(finallyFn);
            } else {
              result = value.then(function(value2) {
                finallyFn();
                return value2;
              }, function(reason) {
                finallyFn();
                throw reason;
              });
            }
          } else {
            finallyFn();
          }
        }
        return result;
      }
      var STRING_STATES = [
        "pending",
        "resolving",
        "resolved",
        REJECTED
      ];
      var DISPATCH_EVENT = "dispatchEvent";
      var _hasInitEvent;
      function _hasInitEventFn(doc) {
        var evt;
        if (doc && doc.createEvent) {
          evt = doc.createEvent("Event");
        }
        return !!evt && evt.initEvent;
      }
      function emitEvent(target, evtName, populateEvent, useNewEvent) {
        var doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = /* @__PURE__ */ createCachedValue(!!safe(_hasInitEventFn, [doc]).v));
        var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : useNewEvent ? new Event(evtName) : {};
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
          theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
          target[DISPATCH_EVENT](theEvt);
        } else {
          var handler = target["on" + evtName];
          if (handler) {
            handler(theEvt);
          } else {
            var theConsole = /* @__PURE__ */ getInst("console");
            theConsole && (theConsole["error"] || theConsole["log"])(evtName, /* @__PURE__ */ dumpObj(theEvt));
          }
        }
      }
      var NODE_UNHANDLED_REJECTION = "unhandledRejection";
      var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
      var _unhandledRejectionTimeout = 10;
      var _hasPromiseRejectionEvent;
      function dumpFnObj(value) {
        if (isFunction(value)) {
          return value.toString();
        }
        return /* @__PURE__ */ dumpObj(value);
      }
      function _createPromise(newPromise, processor, executor) {
        var additionalArgs = arrSlice(arguments, 3);
        var _state = 0;
        var _hasResolved = false;
        var _settledValue;
        var _queue = [];
        var _handled = false;
        var _unHandledRejectionHandler = null;
        var _thePromise;
        function _then(onResolved, onRejected) {
          try {
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            var thenPromise = newPromise(function(resolve3, reject) {
              _queue.push(function() {
                try {
                  var handler = _state === 2 ? onResolved : onRejected;
                  var value = /* @__PURE__ */ isUndefined(handler) ? _settledValue : isFunction(handler) ? handler(_settledValue) : handler;
                  if (/* @__PURE__ */ isPromiseLike(value)) {
                    value.then(resolve3, reject);
                  } else if (handler) {
                    resolve3(value);
                  } else if (_state === 3) {
                    reject(value);
                  } else {
                    resolve3(value);
                  }
                } catch (e) {
                  reject(e);
                }
              });
              if (_hasResolved) {
                _processQueue();
              }
            }, additionalArgs);
            return thenPromise;
          } finally {
          }
        }
        function _catch(onRejected) {
          return _then(void 0, onRejected);
        }
        function _finally(onFinally) {
          var thenFinally = onFinally;
          var catchFinally = onFinally;
          if (isFunction(onFinally)) {
            thenFinally = function(value) {
              onFinally && onFinally();
              return value;
            };
            catchFinally = function(reason) {
              onFinally && onFinally();
              throw reason;
            };
          }
          return _then(thenFinally, catchFinally);
        }
        function _strState() {
          return STRING_STATES[_state];
        }
        function _processQueue() {
          if (_queue.length > 0) {
            var pending = _queue.slice();
            _queue = [];
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            processor(pending);
          }
        }
        function _createSettleIfFn(newState, allowState) {
          return function(theValue) {
            if (_state === allowState) {
              if (newState === 2 && /* @__PURE__ */ isPromiseLike(theValue)) {
                _state = 1;
                theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
                return;
              }
              _state = newState;
              _hasResolved = true;
              _settledValue = theValue;
              _processQueue();
              if (!_handled && newState === 3 && !_unHandledRejectionHandler) {
                _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
              }
            }
          };
        }
        function _notifyUnhandledRejection() {
          if (!_handled) {
            _handled = true;
            if (isNode()) {
              process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            } else {
              var gbl = getWindow() || getGlobal();
              !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = /* @__PURE__ */ createCachedValue(safe(getInst, [STR_PROMISE + "RejectionEvent"]).v));
              emitEvent(gbl, UNHANDLED_REJECTION, function(theEvt) {
                objDefine(theEvt, "promise", { g: function() {
                  return _thePromise;
                } });
                theEvt.reason = _settledValue;
                return theEvt;
              }, !!_hasPromiseRejectionEvent.v);
            }
          }
        }
        _thePromise = {
          then: _then,
          "catch": _catch,
          finally: _finally
        };
        objDefineProp(_thePromise, "state", {
          get: _strState
        });
        if (/* @__PURE__ */ hasSymbol()) {
          _thePromise[/* @__PURE__ */ getKnownSymbol(11)] = "IPromise";
        }
        function _toString() {
          return "IPromise " + _strState() + (_hasResolved ? " - " + dumpFnObj(_settledValue) : "");
        }
        _thePromise.toString = _toString;
        (function _initialize() {
          if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
          }
          var _rejectFn = _createSettleIfFn(3, 0);
          try {
            executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
          } catch (e) {
            _rejectFn(e);
          }
        })();
        return _thePromise;
      }
      function syncItemProcessor(pending) {
        arrForEach(pending, function(fn) {
          try {
            fn();
          } catch (e) {
          }
        });
      }
      function timeoutItemProcessor(timeout) {
        var callbackTimeout = isNumber(timeout) ? timeout : 0;
        return function(pending) {
          scheduleTimeout(function() {
            syncItemProcessor(pending);
          }, callbackTimeout);
        };
      }
      function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
      }
      var _promiseCls;
      function createNativePromise(executor, timeout) {
        !_promiseCls && (_promiseCls = /* @__PURE__ */ createCachedValue(safe(getInst, [STR_PROMISE]).v || null));
        var PrmCls = _promiseCls.v;
        if (!PrmCls) {
          return createAsyncPromise(executor);
        }
        if (!isFunction(executor)) {
          throwTypeError(STR_PROMISE + ": executor is not a function - " + /* @__PURE__ */ dumpObj(executor));
        }
        var _state = 0;
        function _strState() {
          return STRING_STATES[_state];
        }
        var thePromise = new PrmCls(function(resolve3, reject) {
          function _resolve(value) {
            _state = 2;
            resolve3(value);
          }
          function _reject(reason) {
            _state = 3;
            reject(reason);
          }
          executor(_resolve, _reject);
        });
        objDefineProp(thePromise, "state", {
          get: _strState
        });
        return thePromise;
      }
      var _promiseCreator;
      function createPromise(executor, timeout) {
        !_promiseCreator && (_promiseCreator = /* @__PURE__ */ createCachedValue(createNativePromise));
        return _promiseCreator.v.call(this, executor, timeout);
      }
      var UNDEFINED_VALUE = void 0;
      var STR_EMPTY$3 = "";
      var STR_CORE = "core";
      var STR_DISABLED = "disabled";
      var STR_EXTENSION_CONFIG = "extensionConfig";
      var STR_PROCESS_TELEMETRY = "processTelemetry";
      var STR_PRIORITY = "priority";
      var STR_GET_PERF_MGR = "getPerfMgr";
      var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";
      var rCamelCase = /-([a-z])/g;
      var rNormalizeInvalid = /([^\w\d_$])/g;
      var rLeadingNumeric = /^(\d+[\w\d_$])/;
      function isNotNullOrUndefined(value) {
        return !/* @__PURE__ */ isNullOrUndefined(value);
      }
      function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
          value = value[_DYN_REPLACE](rCamelCase, function(_all, letter) {
            return letter.toUpperCase();
          });
          value = value[_DYN_REPLACE](rNormalizeInvalid, "_");
          value = value[_DYN_REPLACE](rLeadingNumeric, function(_all, match) {
            return "_" + match;
          });
        }
        return value;
      }
      function strContains(value, search) {
        if (value && search) {
          return strIndexOf(value, search) !== -1;
        }
        return false;
      }
      function _createProxyFunction(source, funcName) {
        var srcFunc = null;
        var src = null;
        if (isFunction(source)) {
          srcFunc = source;
        } else {
          src = source;
        }
        return function() {
          var originalArguments = arguments;
          if (srcFunc) {
            src = srcFunc();
          }
          if (src) {
            return src[funcName][_DYN_APPLY](src, originalArguments);
          }
        };
      }
      function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
        if (target && name && source) {
          if (overwriteTarget !== false || /* @__PURE__ */ isUndefined(target[name])) {
            target[name] = _createProxyFunction(source, theFunc);
          }
        }
      }
      function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
        if (target && source && /* @__PURE__ */ isObject(target) && isArray(functionsToProxy)) {
          arrForEach(functionsToProxy, function(theFuncName) {
            if (isString(theFuncName)) {
              proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
            }
          });
        }
        return target;
      }
      function optimizeObject(theObject) {
        if (theObject && objAssign) {
          theObject = ObjClass$1(objAssign({}, theObject));
        }
        return theObject;
      }
      function isFeatureEnabled(feature, cfg, sdkDefaultState) {
        var ft = cfg && cfg.featureOptIn && cfg.featureOptIn[feature];
        if (feature && ft) {
          var mode = ft.mode;
          if (mode === 3) {
            return true;
          } else if (mode === 2) {
            return false;
          }
        }
        return sdkDefaultState;
      }
      function getResponseText(xhr) {
        try {
          return xhr.responseText;
        } catch (e) {
        }
        return null;
      }
      function formatErrorMessageXdr(xdr, message) {
        if (xdr) {
          return "XDomainRequest,Response:" + getResponseText(xdr) || "";
        }
        return message;
      }
      function formatErrorMessageXhr(xhr, message) {
        if (xhr) {
          return "XMLHttpRequest,Status:" + xhr[_DYN_STATUS] + ",Response:" + getResponseText(xhr) || xhr.response || "";
        }
        return message;
      }
      function prependTransports(theTransports, newTransports) {
        if (newTransports) {
          if (isNumber(newTransports)) {
            theTransports = [newTransports].concat(theTransports);
          } else if (isArray(newTransports)) {
            theTransports = newTransports.concat(theTransports);
          }
        }
        return theTransports;
      }
      var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var strWithCredentials = "withCredentials";
      var strTimeout = "timeout";
      function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) {
          disabled = false;
        }
        if (isSync === void 0) {
          isSync = false;
        }
        function _wrapSetXhrProp(xhr2, prop, value) {
          try {
            xhr2[prop] = value;
          } catch (e) {
          }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
          _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
        }
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        if (!isSync && timeout) {
          _wrapSetXhrProp(xhr, strTimeout, timeout);
        }
        return xhr;
      }
      function convertAllHeadersToMap(headersString) {
        var headers = {};
        if (isString(headersString)) {
          var headersArray = strTrim(headersString)[_DYN_SPLIT$1](/[\r\n]+/);
          arrForEach(headersArray, function(headerEntry) {
            if (headerEntry) {
              var idx = headerEntry[_DYN_INDEX_OF](": ");
              if (idx !== -1) {
                var header = strTrim(headerEntry.substring(0, idx))[_DYN_TO_LOWER_CASE$1]();
                var value = strTrim(headerEntry.substring(idx + 1));
                headers[header] = value;
              } else {
                headers[strTrim(headerEntry)] = 1;
              }
            }
          });
        }
        return headers;
      }
      function _appendHeader(theHeaders, xhr, name) {
        if (!theHeaders[name] && xhr && xhr.getResponseHeader) {
          var value = xhr.getResponseHeader(name);
          if (value) {
            theHeaders[name] = strTrim(value);
          }
        }
        return theHeaders;
      }
      var STR_KILL_DURATION_HEADER$1 = "kill-duration";
      var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
      var STR_TIME_DELTA_HEADER$1 = "time-delta-millis";
      function _getAllResponseHeaders(xhr, isOneDs) {
        var theHeaders = {};
        if (!xhr[_DYN_GET_ALL_RESPONSE_HEA5]) {
          if (!!isOneDs) {
            theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER$1);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER$1);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
          }
        } else {
          theHeaders = convertAllHeadersToMap(xhr[_DYN_GET_ALL_RESPONSE_HEA5]());
        }
        return theHeaders;
      }
      var strLocation = "location";
      var strConsole = "console";
      var strJSON = "JSON";
      var strCrypto = "crypto";
      var strMsCrypto = "msCrypto";
      var strReactNative = "ReactNative";
      var strMsie = "msie";
      var strTrident = "trident/";
      var strXMLHttpRequest = "XMLHttpRequest";
      var _isTrident = null;
      var _navUserAgentCheck = null;
      var _enableMocks = false;
      var _useXDomainRequest = null;
      var _beaconsSupported = null;
      function _hasProperty(theClass, property) {
        var supported = false;
        if (theClass) {
          try {
            supported = property in theClass;
            if (!supported) {
              var proto = theClass[strShimPrototype];
              if (proto) {
                supported = property in proto;
              }
            }
          } catch (e) {
          }
          if (!supported) {
            try {
              var tmp = new theClass();
              supported = !/* @__PURE__ */ isUndefined(tmp[property]);
            } catch (e) {
            }
          }
        }
        return supported;
      }
      function getLocation(checkForMock) {
        if (checkForMock && _enableMocks) {
          var mockLocation = /* @__PURE__ */ getInst("__mockLocation");
          if (mockLocation) {
            return mockLocation;
          }
        }
        if (typeof location === strShimObject && location) {
          return location;
        }
        return /* @__PURE__ */ getInst(strLocation);
      }
      function getConsole() {
        if (typeof console !== strShimUndefined) {
          return console;
        }
        return /* @__PURE__ */ getInst(strConsole);
      }
      function hasJSON() {
        return Boolean(typeof JSON === strShimObject && JSON || /* @__PURE__ */ getInst(strJSON) !== null);
      }
      function getJSON() {
        if (hasJSON()) {
          return JSON || /* @__PURE__ */ getInst(strJSON);
        }
        return null;
      }
      function getCrypto() {
        return /* @__PURE__ */ getInst(strCrypto);
      }
      function getMsCrypto() {
        return /* @__PURE__ */ getInst(strMsCrypto);
      }
      function isReactNative() {
        var nav = getNavigator();
        if (nav && nav.product) {
          return nav.product === strReactNative;
        }
        return false;
      }
      function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
          _navUserAgentCheck = nav[_DYN_USER_AGENT];
          var userAgent = (_navUserAgentCheck || STR_EMPTY$3)[_DYN_TO_LOWER_CASE$1]();
          _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
        }
        return _isTrident;
      }
      function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
          _beaconsSupported = /* @__PURE__ */ hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
      }
      function isFetchSupported(withKeepAlive) {
        var isSupported = false;
        try {
          isSupported = !!/* @__PURE__ */ getInst("fetch");
          var request = /* @__PURE__ */ getInst("Request");
          if (isSupported && withKeepAlive && request) {
            isSupported = _hasProperty(request, "keepalive");
          }
        } catch (e) {
        }
        return isSupported;
      }
      function useXDomainRequest() {
        if (_useXDomainRequest === null) {
          _useXDomainRequest = typeof XDomainRequest !== strShimUndefined;
          if (_useXDomainRequest && isXhrSupported()) {
            _useXDomainRequest = _useXDomainRequest && !_hasProperty(/* @__PURE__ */ getInst(strXMLHttpRequest), "withCredentials");
          }
        }
        return _useXDomainRequest;
      }
      function isXhrSupported() {
        var isSupported = false;
        try {
          var xmlHttpRequest = /* @__PURE__ */ getInst(strXMLHttpRequest);
          isSupported = !!xmlHttpRequest;
        } catch (e) {
        }
        return isSupported;
      }
      var UInt32Mask = 4294967296;
      var MaxUInt32 = 4294967295;
      var SEED1 = 123456789;
      var SEED2 = 987654321;
      var _mwcSeeded = false;
      var _mwcW = SEED1;
      var _mwcZ = SEED2;
      function _mwcSeed(seedValue) {
        if (seedValue < 0) {
          seedValue >>>= 0;
        }
        _mwcW = SEED1 + seedValue & MaxUInt32;
        _mwcZ = SEED2 - seedValue & MaxUInt32;
        _mwcSeeded = true;
      }
      function _autoSeedMwc() {
        try {
          var now = /* @__PURE__ */ utcNow() & 2147483647;
          _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
        } catch (e) {
        }
      }
      function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
          value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
          if (!_mwcSeeded) {
            _autoSeedMwc();
          }
          value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
          value = mathFloor(UInt32Mask * Math.random() | 0);
        }
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function mwcRandom32(signed) {
        _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32;
        _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
        var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function newId(maxLength) {
        if (maxLength === void 0) {
          maxLength = 22;
        }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY$3;
        while (result[_DYN_LENGTH$2] < maxLength) {
          chars++;
          result += base64chars.charAt(number & 63);
          number >>>= 6;
          if (chars === 5) {
            number = (random32() << 2 & 4294967295 | number & 3) >>> 0;
            chars = 0;
          }
        }
        return result;
      }
      var version = "3.3.7";
      var instanceName = "." + newId(6);
      var _dataUid = 0;
      function _canAcceptData(target) {
        return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
      }
      function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
          theCache = {};
          try {
            if (_canAcceptData(target)) {
              objDefine(target, data.id, {
                e: false,
                v: theCache
              });
            }
          } catch (e) {
          }
        }
        return theCache;
      }
      function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) {
          includeVersion = false;
        }
        return normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY$3) + instanceName);
      }
      function createElmNodeData(name) {
        var data = {
          id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY$3) + "." + version),
          accept: function(target) {
            return _canAcceptData(target);
          },
          get: function(target, name2, defValue, addDefault) {
            var theCache = target[data.id];
            if (!theCache) {
              if (addDefault) {
                theCache = _getCache(data, target);
                theCache[normalizeJsName(name2)] = defValue;
              }
              return defValue;
            }
            return theCache[normalizeJsName(name2)];
          },
          kill: function(target, name2) {
            if (target && target[name2]) {
              try {
                delete target[name2];
              } catch (e) {
              }
            }
          }
        };
        return data;
      }
      function _isConfigDefaults(value) {
        return value && /* @__PURE__ */ isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
      }
      function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
          var fallbacks = cfgDefaults.fb;
          if (!isArray(fallbacks)) {
            fallbacks = [fallbacks];
          }
          for (var lp = 0; lp < fallbacks[_DYN_LENGTH$2]; lp++) {
            var fallback = fallbacks[lp];
            var fbValue = theConfig[fallback];
            if (isDefaultValid(fbValue)) {
              defValue = fbValue;
            } else if (dynamicHandler) {
              fbValue = dynamicHandler.cfg[fallback];
              if (isDefaultValid(fbValue)) {
                defValue = fbValue;
              }
              dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
            }
            if (isDefaultValid(defValue)) {
              break;
            }
          }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
          defValue = cfgDefaults.v;
        }
        return defValue;
      }
      function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
          theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
          if (_isConfigDefaults(theValue)) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
          }
          var newValue_1;
          if (isArray(theValue)) {
            newValue_1 = [];
            newValue_1[_DYN_LENGTH$2] = theValue[_DYN_LENGTH$2];
          } else if (/* @__PURE__ */ isPlainObject(theValue)) {
            newValue_1 = {};
          }
          if (newValue_1) {
            objForEachKey(theValue, function(key, value) {
              if (value && _isConfigDefaults(value)) {
                value = _resolveDefaultValue(dynamicHandler, theConfig, value);
              }
              newValue_1[key] = value;
            });
            theValue = newValue_1;
          }
        }
        return theValue;
      }
      function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
          isValid = cfgDefaults.isVal;
          setFn = cfgDefaults.set;
          readOnly = cfgDefaults.rdOnly;
          blkDynamicValue = cfgDefaults.blkVal;
          mergeDf = cfgDefaults.mrg;
          reference = cfgDefaults.ref;
          if (!reference && /* @__PURE__ */ isUndefined(reference)) {
            reference = !!mergeDf;
          }
          defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        } else {
          defValue = defaultValue;
        }
        if (blkDynamicValue) {
          dynamicHandler.blkVal(theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !/* @__PURE__ */ isNullOrUndefined(cfgValue)) {
          theValue = cfgValue;
          usingDefault = false;
          if (isValid && theValue !== defValue && !isValid(theValue)) {
            theValue = defValue;
            usingDefault = true;
          }
          if (setFn) {
            theValue = setFn(theValue, defValue, theConfig);
            usingDefault = theValue === defValue;
          }
        }
        if (!usingDefault) {
          if (/* @__PURE__ */ isPlainObject(theValue) || isArray(defValue)) {
            if (mergeDf && defValue && (/* @__PURE__ */ isPlainObject(defValue) || isArray(defValue))) {
              objForEachKey(defValue, function(dfName, dfValue) {
                _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
              });
            }
          }
        } else if (defValue) {
          theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        } else {
          theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
          dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
          dynamicHandler.rdOnly(theConfig, name);
        }
      }
      var CFG_HANDLER_LINK = /* @__PURE__ */ symbolFor("[[ai_dynCfg_1]]");
      var BLOCK_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_blkDynCfg_1]]");
      var FORCE_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_frcDynCfg_1]]");
      function _cfgDeepCopy(source) {
        if (source) {
          var target_1;
          if (isArray(source)) {
            target_1 = [];
            target_1[_DYN_LENGTH$2] = source[_DYN_LENGTH$2];
          } else if (/* @__PURE__ */ isPlainObject(source)) {
            target_1 = {};
          }
          if (target_1) {
            objForEachKey(source, function(key, value) {
              target_1[key] = _cfgDeepCopy(value);
            });
            return target_1;
          }
        }
        return source;
      }
      function getDynamicConfigHandler(value) {
        if (value) {
          var handler = value[CFG_HANDLER_LINK] || value;
          if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler;
          }
        }
        return null;
      }
      function blockDynamicConversion(value) {
        if (value && (/* @__PURE__ */ isPlainObject(value) || isArray(value))) {
          try {
            value[BLOCK_DYNAMIC] = true;
          } catch (e) {
          }
        }
        return value;
      }
      function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
          result = value[FORCE_DYNAMIC];
          if (!result && !value[BLOCK_DYNAMIC]) {
            result = /* @__PURE__ */ isPlainObject(value) || isArray(value);
          }
        }
        return result;
      }
      function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
      }
      var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
      ];
      var _throwDynamicError = function(logger2, name, desc, e) {
        logger2 && logger2[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + /* @__PURE__ */ dumpObj(e));
      };
      function _patchArray(state, target, name) {
        if (isArray(target)) {
          arrForEach(arrayMethodsToPatch, function(method) {
            var orgMethod = target[method];
            target[method] = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var result = orgMethod[_DYN_APPLY](this, args);
              _makeDynamicObject(state, target, name, "Patching");
              return result;
            };
          });
        }
      }
      function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
      }
      function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
          n: name,
          h: [],
          trk: function(handler) {
            if (handler && handler.fn) {
              if (arrIndexOf(detail.h, handler) === -1) {
                detail.h[_DYN_PUSH$1](handler);
              }
              state.trk(handler, detail);
            }
          },
          clr: function(handler) {
            var idx = arrIndexOf(detail.h, handler);
            if (idx !== -1) {
              detail.h[_DYN_SPLICE](idx, 1);
            }
          }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
          if (checkDynamic) {
            isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
            if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
              value = _makeDynamicObject(state, value, name, "Converting");
            }
            checkDynamic = false;
          }
          var activeHandler = state.act;
          if (activeHandler) {
            detail.trk(activeHandler);
          }
          return value;
        }
        _getProperty[state.prop] = {
          chng: function() {
            state.add(detail);
          }
        };
        function _setProperty(newValue) {
          if (value !== newValue) {
            if (!!_getProperty[state.ro] && !state.upd) {
              throwInvalidAccess("[" + name + "] is read-only:" + /* @__PURE__ */ dumpObj(theConfig));
            }
            if (checkDynamic) {
              isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
              checkDynamic = false;
            }
            var isReferenced = isObjectOrArray && _getProperty[state.rf];
            if (isObjectOrArray) {
              if (isReferenced) {
                objForEachKey(value, function(key) {
                  value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
                });
                try {
                  objForEachKey(newValue, function(key, theValue) {
                    _setDynamicProperty(state, value, key, theValue);
                  });
                  newValue = value;
                } catch (e) {
                  _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e);
                  isObjectOrArray = false;
                }
              } else if (value && value[CFG_HANDLER_LINK]) {
                objForEachKey(value, function(key) {
                  var getter = _getOwnPropGetter(value, key);
                  if (getter) {
                    var valueState = getter[state.prop];
                    valueState && valueState.chng();
                  }
                });
              }
            }
            if (newValue !== value) {
              var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
              if (!isReferenced && newIsObjectOrArray) {
                newValue = _makeDynamicObject(state, newValue, name, "Converting");
              }
              value = newValue;
              isObjectOrArray = newIsObjectOrArray;
            }
            state.add(detail);
          }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
      }
      function _setDynamicProperty(state, target, name, value) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          if (!isDynamic) {
            _createDynamicProperty(state, target, name, value);
          } else {
            target[name] = value;
          }
        }
        return target;
      }
      function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          var inPlace = flags && flags[0];
          var rdOnly = flags && flags[1];
          var blkProp = flags && flags[2];
          if (!isDynamic) {
            if (blkProp) {
              try {
                blockDynamicConversion(target);
              } catch (e) {
                _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
              }
            }
            try {
              _setDynamicProperty(state, target, name, target[name]);
              getter = _getOwnPropGetter(target, name);
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
            }
          }
          if (inPlace) {
            getter[state.rf] = inPlace;
          }
          if (rdOnly) {
            getter[state.ro] = rdOnly;
          }
          if (blkProp) {
            getter[state.blkVal] = true;
          }
        }
        return target;
      }
      function _makeDynamicObject(state, target, name, desc) {
        try {
          objForEachKey(target, function(key, value) {
            _setDynamicProperty(state, target, key, value);
          });
          if (!target[CFG_HANDLER_LINK]) {
            objDefineProp(target, CFG_HANDLER_LINK, {
              get: function() {
                return state.hdlr;
              }
            });
            _patchArray(state, target, name);
          }
        } catch (e) {
          _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
        }
        return target;
      }
      var symPrefix = "[[ai_";
      var symPostfix = "]]";
      function _createState(cfgHandler) {
        var dynamicPropertySymbol = /* @__PURE__ */ newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = /* @__PURE__ */ newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = /* @__PURE__ */ newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = /* @__PURE__ */ newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = /* @__PURE__ */ newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
          var prevWatcher = theState.act;
          try {
            theState.act = activeHandler;
            if (activeHandler && activeHandler[dynamicPropertyDetail]) {
              arrForEach(activeHandler[dynamicPropertyDetail], function(detail) {
                detail.clr(activeHandler);
              });
              activeHandler[dynamicPropertyDetail] = [];
            }
            callback({
              cfg: cfgHandler.cfg,
              set: cfgHandler.set.bind(cfgHandler),
              setDf: cfgHandler.setDf.bind(cfgHandler),
              ref: cfgHandler.ref.bind(cfgHandler),
              rdOnly: cfgHandler.rdOnly.bind(cfgHandler)
            });
          } catch (e) {
            var logger2 = cfgHandler[_DYN_LOGGER];
            if (logger2) {
              logger2[_DYN_THROW_INTERNAL](1, 107, /* @__PURE__ */ dumpObj(e));
            }
            throw e;
          } finally {
            theState.act = prevWatcher || null;
          }
        }
        function _notifyWatchers() {
          if (_waitingHandlers) {
            var notifyHandlers = _waitingHandlers;
            _waitingHandlers = null;
            _watcherTimer && _watcherTimer[_DYN_CANCEL]();
            _watcherTimer = null;
            var watcherFailures_1 = [];
            arrForEach(notifyHandlers, function(handler) {
              if (handler) {
                if (handler[dynamicPropertyDetail]) {
                  arrForEach(handler[dynamicPropertyDetail], function(detail) {
                    detail.clr(handler);
                  });
                  handler[dynamicPropertyDetail] = null;
                }
                if (handler.fn) {
                  try {
                    _useHandler(handler, handler.fn);
                  } catch (e) {
                    watcherFailures_1[_DYN_PUSH$1](e);
                  }
                }
              }
            });
            if (_waitingHandlers) {
              try {
                _notifyWatchers();
              } catch (e) {
                watcherFailures_1[_DYN_PUSH$1](e);
              }
            }
            if (watcherFailures_1[_DYN_LENGTH$2] > 0) {
              throwAggregationError("Watcher error(s): ", watcherFailures_1);
            }
          }
        }
        function _addWatcher(detail) {
          if (detail && detail.h[_DYN_LENGTH$2] > 0) {
            if (!_waitingHandlers) {
              _waitingHandlers = [];
            }
            if (!_watcherTimer) {
              _watcherTimer = scheduleTimeout(function() {
                _watcherTimer = null;
                _notifyWatchers();
              }, 0);
            }
            for (var idx = 0; idx < detail.h[_DYN_LENGTH$2]; idx++) {
              var handler = detail.h[idx];
              if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                _waitingHandlers[_DYN_PUSH$1](handler);
              }
            }
          }
        }
        function _trackHandler(handler, detail) {
          if (handler) {
            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
            if (arrIndexOf(details, detail) === -1) {
              details[_DYN_PUSH$1](detail);
            }
          }
        }
        theState = {
          prop: dynamicPropertySymbol,
          ro: dynamicPropertyReadOnly,
          rf: dynamicPropertyReferenced,
          blkVal: dynamicPropertyBlockValue,
          hdlr: cfgHandler,
          add: _addWatcher,
          notify: _notifyWatchers,
          use: _useHandler,
          trk: _trackHandler
        };
        return theState;
      }
      function _createAndUseHandler(state, configHandler) {
        var handler = {
          fn: configHandler,
          rm: function() {
            handler.fn = null;
            state = null;
            configHandler = null;
          }
        };
        objDefine(handler, "toJSON", { v: function() {
          return "WatcherHandler" + (handler.fn ? "" : "[X]");
        } });
        state.use(handler, configHandler);
        return handler;
      }
      function _createDynamicHandler(logger2, target, inPlace) {
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
          return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = target && inPlace !== false ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
          theState.notify();
        }
        function _setValue(target2, name, value) {
          try {
            target2 = _setDynamicProperty(theState, target2, name, value);
          } catch (e) {
            _throwDynamicError(logger2, name, "Setting value", e);
          }
          return target2[name];
        }
        function _watch(configHandler) {
          return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
          theState.use(null, function(details) {
            var prevUpd = theState.upd;
            try {
              if (!/* @__PURE__ */ isUndefined(allowUpdate)) {
                theState.upd = allowUpdate;
              }
              configHandler(details);
            } finally {
              theState.upd = prevUpd;
            }
          });
        }
        function _ref(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[0] = true, _a2))[name];
        }
        function _rdOnly(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[1] = true, _a2))[name];
        }
        function _blkPropValue(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[2] = true, _a2))[name];
        }
        function _applyDefaults(theConfig, defaultValues2) {
          if (defaultValues2) {
            objForEachKey(defaultValues2, function(name, value) {
              _applyDefaultValue(cfgHandler, theConfig, name, value);
            });
          }
          return theConfig;
        }
        var cfgHandler = {
          uid: null,
          cfg: newTarget,
          logger: logger2,
          notify: _notifyWatchers,
          set: _setValue,
          setDf: _applyDefaults,
          watch: _watch,
          ref: _ref,
          rdOnly: _rdOnly,
          blkVal: _blkPropValue,
          _block
        };
        objDefine(cfgHandler, "uid", {
          c: false,
          e: false,
          w: false,
          v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
      }
      function _logInvalidAccess(logger2, message) {
        if (logger2) {
          logger2[_DYN_WARN_TO_CONSOLE](message);
          logger2[_DYN_THROW_INTERNAL](2, 108, message);
        } else {
          throwInvalidAccess(message);
        }
      }
      function createDynamicConfig(config, defaultConfig, logger2, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger2, config || {}, inPlace);
        if (defaultConfig) {
          dynamicHandler.setDf(dynamicHandler.cfg, defaultConfig);
        }
        return dynamicHandler;
      }
      function onConfigChange(config, configHandler, logger2) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
          return handler[_DYN_WATCH](configHandler);
        }
        _logInvalidAccess(logger2, STR_NOT_DYNAMIC_ERROR + /* @__PURE__ */ dumpObj(config));
        return createDynamicConfig(config, null, logger2)[_DYN_WATCH](configHandler);
      }
      var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var _aiNamespace = null;
      function _getExtensionNamespace() {
        var target = /* @__PURE__ */ getInst("Microsoft");
        if (target) {
          _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
      }
      function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
          ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
      }
      var _a$3;
      var STR_WARN_TO_CONSOLE = "warnToConsole";
      var AiNonUserActionablePrefix = "AI (Internal): ";
      var AiUserActionablePrefix = "AI: ";
      var AIInternalMessagePrefix = "AITR_";
      var defaultValues$1 = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
      };
      var _logFuncs = (_a$3 = {}, _a$3[0] = null, _a$3[1] = "errorToConsole", _a$3[2] = STR_WARN_TO_CONSOLE, _a$3[3] = "debugToConsole", _a$3);
      function _sanitizeDiagnosticText(text) {
        if (text) {
          return '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY$3) + '"';
        }
        return STR_EMPTY$3;
      }
      function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
          var logFunc = "log";
          if (theConsole[func]) {
            logFunc = func;
          }
          if (isFunction(theConsole[logFunc])) {
            theConsole[logFunc](message);
          }
        }
      }
      var _InternalLogMessage = (
        /** @class */
        function() {
          function _InternalLogMessage2(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) {
              isUserAct = false;
            }
            var _self = this;
            _self[_DYN_MESSAGE_ID] = msgId;
            _self[_DYN_MESSAGE] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
            var strProps = STR_EMPTY$3;
            if (hasJSON()) {
              strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY$3) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY$3);
            _self[_DYN_MESSAGE] += diagnosticText;
          }
          _InternalLogMessage2.dataType = "MessageData";
          return _InternalLogMessage2;
        }()
      );
      function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
      }
      var DiagnosticLogger = (
        /** @class */
        function() {
          function DiagnosticLogger2(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger2, this, function(_self) {
              _unloadHandler = _setDefaultsFromConfig(config || {});
              _self.consoleLoggingLevel = function() {
                return _loggingLevelConsole;
              };
              _self[_DYN_THROW_INTERNAL] = function(severity, msgId, msg, properties, isUserAct) {
                if (isUserAct === void 0) {
                  isUserAct = false;
                }
                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                if (_enableDebug) {
                  throw /* @__PURE__ */ dumpObj(message);
                } else {
                  var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                  if (!/* @__PURE__ */ isUndefined(message[_DYN_MESSAGE])) {
                    if (isUserAct) {
                      var messageKey = +message[_DYN_MESSAGE_ID];
                      if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE]);
                        _messageLogged[messageKey] = true;
                      }
                    } else {
                      if (_loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE]);
                      }
                    }
                    _logInternalMessage(severity, message);
                  } else {
                    _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);
                  }
                }
              };
              _self.debugToConsole = function(message) {
                _logToConsole("debug", message);
                _debugExtMsg("warning", message);
              };
              _self[_DYN_WARN_TO_CONSOLE] = function(message) {
                _logToConsole("warn", message);
                _debugExtMsg("warning", message);
              };
              _self.errorToConsole = function(message) {
                _logToConsole("error", message);
                _debugExtMsg("error", message);
              };
              _self.resetInternalMessageCount = function() {
                _messageCount = 0;
                _messageLogged = {};
              };
              _self.logInternalMessage = _logInternalMessage;
              _self[_DYN_UNLOAD] = function(isAsync) {
                _unloadHandler && _unloadHandler.rm();
                _unloadHandler = null;
              };
              function _logInternalMessage(severity, message) {
                if (_areInternalMessagesThrottled()) {
                  return;
                }
                var logMessage = true;
                var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
                if (_messageLogged[messageKey]) {
                  logMessage = false;
                } else {
                  _messageLogged[messageKey] = true;
                }
                if (logMessage) {
                  if (severity <= _loggingLevelTelemetry) {
                    _self.queue[_DYN_PUSH$1](message);
                    _messageCount++;
                    _debugExtMsg(severity === 1 ? "error" : "warn", message);
                  }
                  if (_messageCount === _maxInternalMessageLimit) {
                    var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                    var throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, false);
                    _self.queue[_DYN_PUSH$1](throttleMessage);
                    if (severity === 1) {
                      _self.errorToConsole(throttleLimitMessage);
                    } else {
                      _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
                    }
                  }
                }
              }
              function _setDefaultsFromConfig(config2) {
                return onConfigChange(createDynamicConfig(config2, defaultValues$1, _self).cfg, function(details) {
                  var config3 = details.cfg;
                  _loggingLevelConsole = config3[_DYN_LOGGING_LEVEL_CONSOL4];
                  _loggingLevelTelemetry = config3.loggingLevelTelemetry;
                  _maxInternalMessageLimit = config3.maxMessageLimit;
                  _enableDebug = config3.enableDebug;
                });
              }
              function _areInternalMessagesThrottled() {
                return _messageCount >= _maxInternalMessageLimit;
              }
              function _debugExtMsg(name, data) {
                var dbgExt = getDebugExt(config || {});
                if (dbgExt && dbgExt[_DYN_DIAG_LOG]) {
                  dbgExt[_DYN_DIAG_LOG](name, data);
                }
              }
            });
          }
          DiagnosticLogger2.__ieDyn = 1;
          return DiagnosticLogger2;
        }()
      );
      function _getLogger(logger2) {
        return logger2 || new DiagnosticLogger();
      }
      function _throwInternal(logger2, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) {
          isUserAct = false;
        }
        _getLogger(logger2)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
      }
      function _warnToConsole(logger2, message) {
        _getLogger(logger2)[_DYN_WARN_TO_CONSOLE](message);
      }
      var strExecutionContextKey = "ctx";
      var strParentContextKey = "ParentContextKey";
      var strChildrenContextKey = "ChildrenContextKey";
      var PerfEvent = (
        /** @class */
        function() {
          function PerfEvent2(name, payloadDetails, isAsync) {
            var _self = this;
            _self.start = /* @__PURE__ */ utcNow();
            _self[_DYN_NAME] = name;
            _self.isAsync = isAsync;
            _self[_DYN_IS_CHILD_EVT] = function() {
              return false;
            };
            if (isFunction(payloadDetails)) {
              var theDetails_1;
              objDefine(_self, "payload", {
                g: function() {
                  if (!theDetails_1 && isFunction(payloadDetails)) {
                    theDetails_1 = payloadDetails();
                    payloadDetails = null;
                  }
                  return theDetails_1;
                }
              });
            }
            _self[_DYN_GET_CTX] = function(key) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey] || key === PerfEvent2[strChildrenContextKey]) {
                  return _self[key];
                }
                return (_self[strExecutionContextKey] || {})[key];
              }
              return null;
            };
            _self[_DYN_SET_CTX] = function(key, value) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey]) {
                  if (!_self[key]) {
                    _self[_DYN_IS_CHILD_EVT] = function() {
                      return true;
                    };
                  }
                  _self[key] = value;
                } else if (key === PerfEvent2[strChildrenContextKey]) {
                  _self[key] = value;
                } else {
                  var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                  ctx[key] = value;
                }
              }
            };
            _self.complete = function() {
              var childTime = 0;
              var childEvts = _self[_DYN_GET_CTX](PerfEvent2[strChildrenContextKey]);
              if (isArray(childEvts)) {
                for (var lp = 0; lp < childEvts[_DYN_LENGTH$2]; lp++) {
                  var childEvt = childEvts[lp];
                  if (childEvt) {
                    childTime += childEvt.time;
                  }
                }
              }
              _self.time = /* @__PURE__ */ utcNow() - _self.start;
              _self.exTime = _self.time - childTime;
              _self.complete = function() {
              };
            };
          }
          PerfEvent2.ParentContextKey = "parent";
          PerfEvent2.ChildrenContextKey = "childEvts";
          return PerfEvent2;
        }()
      );
      var doPerfActiveKey = "CoreUtils.doPerf";
      function doPerf(mgrSource, getSource, func, details, isAsync) {
        if (mgrSource) {
          var perfMgr = mgrSource;
          if (perfMgr[STR_GET_PERF_MGR]) {
            perfMgr = perfMgr[STR_GET_PERF_MGR]();
          }
          if (perfMgr) {
            var perfEvt = void 0;
            var currentActive = perfMgr[_DYN_GET_CTX](doPerfActiveKey);
            try {
              perfEvt = perfMgr.create(getSource(), details, isAsync);
              if (perfEvt) {
                if (currentActive && perfEvt[_DYN_SET_CTX]) {
                  perfEvt[_DYN_SET_CTX](PerfEvent[strParentContextKey], currentActive);
                  if (currentActive[_DYN_GET_CTX] && currentActive[_DYN_SET_CTX]) {
                    var children = currentActive[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
                    if (!children) {
                      children = [];
                      currentActive[_DYN_SET_CTX](PerfEvent[strChildrenContextKey], children);
                    }
                    children[_DYN_PUSH$1](perfEvt);
                  }
                }
                perfMgr[_DYN_SET_CTX](doPerfActiveKey, perfEvt);
                return func(perfEvt);
              }
            } catch (ex) {
              if (perfEvt && perfEvt[_DYN_SET_CTX]) {
                perfEvt[_DYN_SET_CTX]("exception", ex);
              }
            } finally {
              if (perfEvt) {
                perfMgr.fire(perfEvt);
              }
              perfMgr[_DYN_SET_CTX](doPerfActiveKey, currentActive);
            }
          }
        }
        return func();
      }
      var pluginStateData = createElmNodeData("plugin");
      function _getPluginState(plugin) {
        return pluginStateData.get(plugin, "state", {}, true);
      }
      var strTelemetryPluginChain = "TelemetryPluginChain";
      var strHasRunFlags = "_hasRun";
      var strGetTelCtx = "_getTelCtx";
      var _chainId = 0;
      function _getNextProxyStart(proxy, core, startAt) {
        while (proxy) {
          if (proxy[_DYN_GET_PLUGIN]() === startAt) {
            return proxy;
          }
          proxy = proxy[_DYN_GET_NEXT]();
        }
        return createTelemetryProxyChain([startAt], core.config || {}, core);
      }
      function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
        var _nextProxy = null;
        var _onComplete = [];
        if (!dynamicHandler) {
          dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER]);
        }
        if (startAt !== null) {
          _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
        }
        var context = {
          _next: _moveNext,
          ctx: {
            core: function() {
              return core;
            },
            diagLog: function() {
              return safeGetLogger(core, dynamicHandler.cfg);
            },
            getCfg: function() {
              return dynamicHandler.cfg;
            },
            getExtCfg: _resolveExtCfg,
            getConfig: _getConfig,
            hasNext: function() {
              return !!_nextProxy;
            },
            getNext: function() {
              return _nextProxy;
            },
            setNext: function(nextPlugin) {
              _nextProxy = nextPlugin;
            },
            iterate: _iterateChain,
            onComplete: _addOnComplete
          }
        };
        function _addOnComplete(onComplete, that) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          if (onComplete) {
            _onComplete[_DYN_PUSH$1]({
              func: onComplete,
              self: !/* @__PURE__ */ isUndefined(that) ? that : context.ctx,
              args
            });
          }
        }
        function _moveNext() {
          var nextProxy = _nextProxy;
          _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT]() : null;
          if (!nextProxy) {
            var onComplete = _onComplete;
            if (onComplete && onComplete[_DYN_LENGTH$2] > 0) {
              arrForEach(onComplete, function(completeDetails) {
                try {
                  completeDetails.func.call(completeDetails.self, completeDetails.args);
                } catch (e) {
                  _throwInternal(core[_DYN_LOGGER], 2, 73, "Unexpected Exception during onComplete - " + /* @__PURE__ */ dumpObj(e));
                }
              });
              _onComplete = [];
            }
          }
          return nextProxy;
        }
        function _getExtCfg(identifier, createIfMissing) {
          var idCfg = null;
          var cfg = dynamicHandler.cfg;
          if (cfg && identifier) {
            var extCfg = cfg[STR_EXTENSION_CONFIG];
            if (!extCfg && createIfMissing) {
              extCfg = {};
            }
            cfg[STR_EXTENSION_CONFIG] = extCfg;
            extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);
            if (extCfg) {
              idCfg = extCfg[identifier];
              if (!idCfg && createIfMissing) {
                idCfg = {};
              }
              extCfg[identifier] = idCfg;
              idCfg = dynamicHandler.ref(extCfg, identifier);
            }
          }
          return idCfg;
        }
        function _resolveExtCfg(identifier, defaultValues2) {
          var newConfig = _getExtCfg(identifier, true);
          if (defaultValues2) {
            objForEachKey(defaultValues2, function(field, defaultValue) {
              if (/* @__PURE__ */ isNullOrUndefined(newConfig[field])) {
                var cfgValue = dynamicHandler.cfg[field];
                if (cfgValue || !/* @__PURE__ */ isNullOrUndefined(cfgValue)) {
                  newConfig[field] = cfgValue;
                }
              }
              _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
            });
          }
          return dynamicHandler.setDf(newConfig, defaultValues2);
        }
        function _getConfig(identifier, field, defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = false;
          }
          var theValue;
          var extConfig = _getExtCfg(identifier, false);
          var rootConfig = dynamicHandler.cfg;
          if (extConfig && (extConfig[field] || !/* @__PURE__ */ isNullOrUndefined(extConfig[field]))) {
            theValue = extConfig[field];
          } else if (rootConfig[field] || !/* @__PURE__ */ isNullOrUndefined(rootConfig[field])) {
            theValue = rootConfig[field];
          }
          return theValue || !/* @__PURE__ */ isNullOrUndefined(theValue) ? theValue : defaultValue;
        }
        function _iterateChain(cb) {
          var nextPlugin;
          while (!!(nextPlugin = context._next())) {
            var plugin = nextPlugin[_DYN_GET_PLUGIN]();
            if (plugin) {
              cb(plugin);
            }
          }
        }
        return context;
      }
      function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
        var config = createDynamicConfig(cfg);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(env2) {
          var nextPlugin = internalContext._next();
          if (nextPlugin) {
            nextPlugin[STR_PROCESS_TELEMETRY](env2, context);
          }
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT](), config.cfg, core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(unloadState) {
          var nextPlugin = internalContext._next();
          nextPlugin && nextPlugin[_DYN_UNLOAD](context, unloadState);
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(updateState) {
          return context.iterate(function(plugin) {
            if (isFunction(plugin[_DYN_UPDATE])) {
              plugin[_DYN_UPDATE](context, updateState);
            }
          });
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createTelemetryProxyChain(plugins, config, core, startAt) {
        var firstProxy = null;
        var add = startAt ? false : true;
        if (isArray(plugins) && plugins[_DYN_LENGTH$2] > 0) {
          var lastProxy_1 = null;
          arrForEach(plugins, function(thePlugin) {
            if (!add && startAt === thePlugin) {
              add = true;
            }
            if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY])) {
              var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
              if (!firstProxy) {
                firstProxy = newProxy;
              }
              if (lastProxy_1) {
                lastProxy_1._setNext(newProxy);
              }
              lastProxy_1 = newProxy;
            }
          });
        }
        if (startAt && !firstProxy) {
          return createTelemetryProxyChain([startAt], config, core);
        }
        return firstProxy;
      }
      function createTelemetryPluginProxy(plugin, config, core) {
        var nextProxy = null;
        var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY]);
        var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN]);
        var chainId;
        if (plugin) {
          chainId = plugin[_DYN_IDENTIFIER$1] + "-" + plugin[STR_PRIORITY] + "-" + _chainId++;
        } else {
          chainId = "Unknown-0-" + _chainId++;
        }
        var proxyChain = {
          getPlugin: function() {
            return plugin;
          },
          getNext: function() {
            return nextProxy;
          },
          processTelemetry: _processTelemetry,
          unload: _unloadPlugin,
          update: _updatePlugin,
          _id: chainId,
          _setNext: function(nextPlugin) {
            nextProxy = nextPlugin;
          }
        };
        function _getTelCtx() {
          var itemCtx;
          if (plugin && isFunction(plugin[strGetTelCtx])) {
            itemCtx = plugin[strGetTelCtx]();
          }
          if (!itemCtx) {
            itemCtx = createProcessTelemetryContext(proxyChain, config, core);
          }
          return itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
          var hasRun = false;
          var identifier = plugin ? plugin[_DYN_IDENTIFIER$1] : strTelemetryPluginChain;
          var hasRunContext = itemCtx[strHasRunFlags];
          if (!hasRunContext) {
            hasRunContext = itemCtx[strHasRunFlags] = {};
          }
          itemCtx.setNext(nextProxy);
          if (plugin) {
            doPerf(itemCtx[STR_CORE](), function() {
              return identifier + ":" + name;
            }, function() {
              hasRunContext[chainId] = true;
              try {
                var nextId = nextProxy ? nextProxy._id : STR_EMPTY$3;
                if (nextId) {
                  hasRunContext[nextId] = false;
                }
                hasRun = processPluginFn(itemCtx);
              } catch (error) {
                var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                if (hasNextRun) {
                  hasRun = true;
                }
                if (!nextProxy || !hasNextRun) {
                  _throwInternal(itemCtx[_DYN_DIAG_LOG](), 1, 73, "Plugin [" + identifier + "] failed during " + name + " - " + /* @__PURE__ */ dumpObj(error) + ", run flags: " + /* @__PURE__ */ dumpObj(hasRunContext));
                }
              }
            }, details, isAsync);
          }
          return hasRun;
        }
        function _processTelemetry(env2, itemCtx) {
          itemCtx = itemCtx || _getTelCtx();
          function _callProcessTelemetry(itemCtx2) {
            if (!plugin || !hasProcessTelemetry) {
              return false;
            }
            var pluginState = _getPluginState(plugin);
            if (pluginState[_DYN_TEARDOWN] || pluginState[STR_DISABLED]) {
              return false;
            }
            if (hasSetNext) {
              plugin[_DYN_SET_NEXT_PLUGIN](nextProxy);
            }
            plugin[STR_PROCESS_TELEMETRY](env2, itemCtx2);
            return true;
          }
          if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function() {
            return { item: env2 };
          }, !env2.sync)) {
            itemCtx[_DYN_PROCESS_NEXT](env2);
          }
        }
        function _unloadPlugin(unloadCtx, unloadState) {
          function _callTeardown() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                pluginState[STR_CORE] = null;
                pluginState[_DYN_TEARDOWN] = true;
                pluginState[_DYN_IS_INITIALIZED] = false;
                if (plugin[_DYN_TEARDOWN] && plugin[_DYN_TEARDOWN](unloadCtx, unloadState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(unloadCtx, _callTeardown, "unload", function() {
          }, unloadState.isAsync)) {
            unloadCtx[_DYN_PROCESS_NEXT](unloadState);
          }
        }
        function _updatePlugin(updateCtx, updateState) {
          function _callUpdate() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                if (plugin[_DYN_UPDATE] && plugin[_DYN_UPDATE](updateCtx, updateState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(updateCtx, _callUpdate, "update", function() {
          }, false)) {
            updateCtx[_DYN_PROCESS_NEXT](updateState);
          }
        }
        return objFreeze(proxyChain);
      }
      function createUnloadHandlerContainer() {
        var handlers = [];
        function _addHandler(handler) {
          if (handler) {
            handlers[_DYN_PUSH$1](handler);
          }
        }
        function _runHandlers(unloadCtx, unloadState) {
          arrForEach(handlers, function(handler) {
            try {
              handler(unloadCtx, unloadState);
            } catch (e) {
              _throwInternal(unloadCtx[_DYN_DIAG_LOG](), 2, 73, "Unexpected error calling unload handler - " + /* @__PURE__ */ dumpObj(e));
            }
          });
          handlers = [];
        }
        return {
          add: _addHandler,
          run: _runHandlers
        };
      }
      function createUnloadHookContainer() {
        var _hooks = [];
        function _doUnload(logger2) {
          var oldHooks = _hooks;
          _hooks = [];
          arrForEach(oldHooks, function(fn) {
            try {
              (fn.rm || fn.remove).call(fn);
            } catch (e) {
              _throwInternal(logger2, 2, 73, "Unloading:" + /* @__PURE__ */ dumpObj(e));
            }
          });
        }
        function _addHook(hooks) {
          if (hooks) {
            arrAppend(_hooks, hooks);
          }
        }
        return {
          run: _doUnload,
          add: _addHook
        };
      }
      var _a$2;
      var strGetPlugin = "getPlugin";
      var defaultValues = (_a$2 = {}, _a$2[STR_EXTENSION_CONFIG] = { isVal: isNotNullOrUndefined, v: {} }, _a$2);
      var BaseTelemetryPlugin = (
        /** @class */
        function() {
          function BaseTelemetryPlugin2() {
            var _self = this;
            var _isinitialized;
            var _rootCtx;
            var _nextPlugin;
            var _unloadHandlerContainer;
            var _hookContainer;
            _initDefaults();
            dynamicProto(BaseTelemetryPlugin2, _self, function(_self2) {
              _self2[_DYN_INITIALIZE$1] = function(config, core, extensions3, pluginChain) {
                _setDefaults(config, core, pluginChain);
                _isinitialized = true;
              };
              _self2[_DYN_TEARDOWN] = function(unloadCtx, unloadState) {
                var core = _self2[STR_CORE];
                if (!core || unloadCtx && core !== unloadCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var unloadDone = false;
                var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUnloadState = unloadState || {
                  reason: 0,
                  isAsync: false
                };
                function _unloadCallback() {
                  if (!unloadDone) {
                    unloadDone = true;
                    _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                    _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG]());
                    if (result === true) {
                      theUnloadCtx[_DYN_PROCESS_NEXT](theUnloadState);
                    }
                    _initDefaults();
                  }
                }
                if (!_self2[_DYN__DO_TEARDOWN] || _self2[_DYN__DO_TEARDOWN](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                  _unloadCallback();
                } else {
                  result = true;
                }
                return result;
              };
              _self2[_DYN_UPDATE] = function(updateCtx, updateState) {
                var core = _self2[STR_CORE];
                if (!core || updateCtx && core !== updateCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var updateDone = false;
                var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUpdateState = updateState || {
                  reason: 0
                };
                function _updateCallback() {
                  if (!updateDone) {
                    updateDone = true;
                    _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT]());
                  }
                }
                if (!_self2._doUpdate || _self2._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                  _updateCallback();
                } else {
                  result = true;
                }
                return result;
              };
              proxyFunctionAs(_self2, "_addUnloadCb", function() {
                return _unloadHandlerContainer;
              }, "add");
              proxyFunctionAs(_self2, "_addHook", function() {
                return _hookContainer;
              }, "add");
              objDefine(_self2, "_unloadHooks", { g: function() {
                return _hookContainer;
              } });
            });
            _self[_DYN_DIAG_LOG] = function(itemCtx) {
              return _getTelCtx(itemCtx)[_DYN_DIAG_LOG]();
            };
            _self[_DYN_IS_INITIALIZED] = function() {
              return _isinitialized;
            };
            _self.setInitialized = function(isInitialized) {
              _isinitialized = isInitialized;
            };
            _self[_DYN_SET_NEXT_PLUGIN] = function(next) {
              _nextPlugin = next;
            };
            _self[_DYN_PROCESS_NEXT] = function(env2, itemCtx) {
              if (itemCtx) {
                itemCtx[_DYN_PROCESS_NEXT](env2);
              } else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY])) {
                _nextPlugin[STR_PROCESS_TELEMETRY](env2, null);
              }
            };
            _self._getTelCtx = _getTelCtx;
            function _getTelCtx(currentCtx) {
              if (currentCtx === void 0) {
                currentCtx = null;
              }
              var itemCtx = currentCtx;
              if (!itemCtx) {
                var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE]);
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin[strGetPlugin]);
                } else {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin);
                }
              }
              return itemCtx;
            }
            function _setDefaults(config, core, pluginChain) {
              createDynamicConfig(config, defaultValues, safeGetLogger(core));
              if (!pluginChain && core) {
                pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2]()[_DYN_GET_NEXT]();
              }
              var nextPlugin = _nextPlugin;
              if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                nextPlugin = _nextPlugin[strGetPlugin]();
              }
              _self[STR_CORE] = core;
              _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
            }
            function _initDefaults() {
              _isinitialized = false;
              _self[STR_CORE] = null;
              _rootCtx = null;
              _nextPlugin = null;
              _hookContainer = createUnloadHookContainer();
              _unloadHandlerContainer = createUnloadHandlerContainer();
            }
          }
          BaseTelemetryPlugin2.__ieDyn = 1;
          return BaseTelemetryPlugin2;
        }()
      );
      var STR_EMPTY$2 = "";
      var STR_NO_RESPONSE_BODY$1 = "NoResponseBody";
      var _noResponseQs$1 = "&" + STR_NO_RESPONSE_BODY$1 + "=true";
      var STR_POST_METHOD = "POST";
      var SenderPostManager = (
        /** @class */
        function() {
          function SenderPostManager2() {
            var _syncFetchPayload = 0;
            var _enableSendPromise;
            var _isInitialized;
            var _diagLog;
            var _isOneDs;
            var _onCompleteFuncs;
            var _disableCredentials;
            var _fetchCredentials;
            var _fallbackInst;
            var _disableXhr;
            var _disableBeacon;
            var _disableBeaconSync;
            var _disableFetchKeepAlive;
            var _addNoResponse;
            var _timeoutWrapper;
            dynamicProto(SenderPostManager2, this, function(_self, _base) {
              var _sendCredentials = true;
              _initDefaults();
              _self[_DYN_INITIALIZE$1] = function(config, diagLog) {
                _diagLog = diagLog;
                if (_isInitialized) {
                  _throwInternal(_diagLog, 1, 28, "Sender is already initialized");
                }
                _self.SetConfig(config);
                _isInitialized = true;
              };
              _self["_getDbgPlgTargets"] = function() {
                return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
              };
              _self.SetConfig = function(config) {
                try {
                  _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                  _disableCredentials = !!config.disableCredentials;
                  _fetchCredentials = config.fetchCredentials;
                  _isOneDs = !!config.isOneDs;
                  _enableSendPromise = !!config.enableSendPromise;
                  _disableXhr = !!config.disableXhr;
                  _disableBeacon = !!config.disableBeacon;
                  _disableBeaconSync = !!config.disableBeaconSync;
                  _timeoutWrapper = config.timeWrapper;
                  _addNoResponse = !!config.addNoResponse;
                  _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                  _fallbackInst = { sendPOST: _xhrSender };
                  if (!_isOneDs) {
                    _sendCredentials = false;
                  }
                  if (_disableCredentials) {
                    var location_1 = getLocation();
                    if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE$1]() === "file:") {
                      _sendCredentials = false;
                    }
                  }
                  return true;
                } catch (e) {
                }
                return false;
              };
              _self.getSyncFetchPayload = function() {
                return _syncFetchPayload;
              };
              _self.getSenderInst = function(transports, sync) {
                if (transports && transports[_DYN_LENGTH$2]) {
                  return _getSenderInterface(transports, sync);
                }
                return null;
              };
              _self.getFallbackInst = function() {
                return _fallbackInst;
              };
              _self[_DYN__DO_TEARDOWN] = function(unloadCtx, unloadState) {
                _initDefaults();
              };
              _self.preparePayload = function(callback, zipPayload, payload, isSync) {
                if (!zipPayload || isSync || !payload[_DYN_DATA]) {
                  callback(payload);
                  return;
                }
                try {
                  var csStream = /* @__PURE__ */ getInst("CompressionStream");
                  if (!isFunction(csStream)) {
                    callback(payload);
                    return;
                  }
                  var body = new ReadableStream({
                    start: function(controller) {
                      controller.enqueue(isString(payload[_DYN_DATA]) ? new TextEncoder().encode(payload[_DYN_DATA]) : payload[_DYN_DATA]);
                      controller.close();
                    }
                  });
                  var compressedStream = body.pipeThrough(new csStream("gzip"));
                  var reader_1 = compressedStream.getReader();
                  var chunks_1 = [];
                  var totalLength_1 = 0;
                  var callbackCalled_1 = false;
                  doAwaitResponse(reader_1.read(), function processChunk(response) {
                    if (!callbackCalled_1 && !response.rejected) {
                      var result = response[_DYN_VALUE$1];
                      if (!result.done) {
                        chunks_1[_DYN_PUSH$1](result[_DYN_VALUE$1]);
                        totalLength_1 += result.value[_DYN_LENGTH$2];
                        return doAwaitResponse(reader_1.read(), processChunk);
                      }
                      var combined = new Uint8Array(totalLength_1);
                      var offset = 0;
                      for (var _i = 0, chunks_2 = chunks_1; _i < chunks_2.length; _i++) {
                        var chunk = chunks_2[_i];
                        combined.set(chunk, offset);
                        offset += chunk[_DYN_LENGTH$2];
                      }
                      payload[_DYN_DATA] = combined;
                      payload[_DYN_HEADERS$1]["Content-Encoding"] = "gzip";
                      payload._chunkCount = chunks_1[_DYN_LENGTH$2];
                    }
                    if (!callbackCalled_1) {
                      callbackCalled_1 = true;
                      callback(payload);
                    }
                  });
                  return reader_1;
                } catch (error) {
                  callback(payload);
                  return;
                }
              };
              function _onSuccess(res, onComplete) {
                _doOnComplete(onComplete, 200, {}, res);
              }
              function _onError(message, onComplete) {
                _throwInternal(_diagLog, 2, 26, "Failed to send telemetry.", { message });
                _doOnComplete(onComplete, 400, {});
              }
              function _onNoPayloadUrl(onComplete) {
                _onError("No endpoint url is provided for the batch", onComplete);
              }
              function _getSenderInterface(transports, syncSupport) {
                var transportType = 0;
                var sendPostFunc = null;
                var lp = 0;
                while (sendPostFunc == null && lp < transports[_DYN_LENGTH$2]) {
                  transportType = transports[lp];
                  if (!_disableXhr && transportType === 1) {
                    if (useXDomainRequest()) {
                      sendPostFunc = _xdrSender;
                    } else if (isXhrSupported()) {
                      sendPostFunc = _xhrSender;
                    }
                  } else if (transportType === 2 && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                    sendPostFunc = _doFetchSender;
                  } else if (transportType === 3 && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                    sendPostFunc = _beaconSender;
                  }
                  lp++;
                }
                if (sendPostFunc) {
                  return {
                    _transport: transportType,
                    _isSync: syncSupport,
                    sendPOST: sendPostFunc
                  };
                }
                return null;
              }
              function _doOnComplete(oncomplete, status, headers, response) {
                try {
                  oncomplete && oncomplete(status, headers, response);
                } catch (e) {
                }
              }
              function _doBeaconSend(payload, oncomplete) {
                var nav = getNavigator();
                var url = payload[_DYN_URL_STRING];
                if (!url) {
                  _onNoPayloadUrl(oncomplete);
                  return true;
                }
                url = payload[_DYN_URL_STRING] + (_addNoResponse ? _noResponseQs$1 : STR_EMPTY$2);
                var data = payload[_DYN_DATA];
                var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                var queued = nav.sendBeacon(url, plainTextBatch);
                return queued;
              }
              function _beaconSender(payload, oncomplete, sync) {
                var data = payload[_DYN_DATA];
                try {
                  if (data) {
                    if (!_doBeaconSend(payload, oncomplete)) {
                      var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                      if (onRetry && isFunction(onRetry)) {
                        onRetry(payload, oncomplete, _doBeaconSend);
                      } else {
                        _fallbackInst && _fallbackInst.sendPOST(payload, oncomplete, true);
                        _throwInternal(_diagLog, 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");
                      }
                    } else {
                      _onSuccess(STR_EMPTY$2, oncomplete);
                    }
                  }
                } catch (e) {
                  _isOneDs && _warnToConsole(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + /* @__PURE__ */ dumpObj(e));
                  _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY$2);
                }
                return;
              }
              function _xhrSender(payload, oncomplete, sync) {
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var headers = payload[_DYN_HEADERS$1] || {};
                if (!sync && _enableSendPromise) {
                  thePromise = createPromise(function(resolve3, reject) {
                    resolveFunc = resolve3;
                    rejectFunc = reject;
                  });
                }
                if (_isOneDs && sync && payload.disableXhrSync) {
                  sync = false;
                }
                var endPointUrl = payload[_DYN_URL_STRING];
                if (!endPointUrl) {
                  _onNoPayloadUrl(oncomplete);
                  resolveFunc && resolveFunc(false);
                  return;
                }
                var xhr = openXhr(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT]);
                if (!_isOneDs) {
                  xhr.setRequestHeader("Content-type", "application/json");
                }
                arrForEach(objKeys(headers), function(headerName) {
                  xhr.setRequestHeader(headerName, headers[headerName]);
                });
                xhr.onreadystatechange = function() {
                  if (!_isOneDs) {
                    _doOnReadyFunc(xhr);
                    if (xhr.readyState === 4) {
                      resolveFunc && resolveFunc(true);
                    }
                  }
                };
                xhr.onload = function() {
                  if (_isOneDs) {
                    _doOnReadyFunc(xhr);
                  }
                };
                function _doOnReadyFunc(xhr2) {
                  var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                  var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);
                  if (onReadyFuncExist) {
                    onReadyFunc(xhr2, oncomplete, payload);
                  } else {
                    var response = getResponseText(xhr2);
                    _doOnComplete(oncomplete, xhr2[_DYN_STATUS], _getAllResponseHeaders(xhr2, _isOneDs), response);
                  }
                }
                xhr.onerror = function(event) {
                  _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$2 : formatErrorMessageXhr(xhr));
                  rejectFunc && rejectFunc(event);
                };
                xhr.ontimeout = function() {
                  _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY$2 : formatErrorMessageXhr(xhr));
                  resolveFunc && resolveFunc(false);
                };
                xhr.send(payload[_DYN_DATA]);
                return thePromise;
              }
              function _doFetchSender(payload, oncomplete, sync) {
                var _a2;
                var endPointUrl = payload[_DYN_URL_STRING];
                var batch = payload[_DYN_DATA];
                var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var requestHeaders = new Headers();
                var batchLength = batch[_DYN_LENGTH$2];
                var ignoreResponse = false;
                var responseHandled = false;
                var headers = payload[_DYN_HEADERS$1] || {};
                var init = (_a2 = {
                  method: STR_POST_METHOD,
                  body: plainTextBatch
                }, _a2[DisabledPropertyName] = true, _a2);
                if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH$2] > 0) {
                  arrForEach(objKeys(headers), function(headerName) {
                    requestHeaders.append(headerName, headers[headerName]);
                  });
                  init[_DYN_HEADERS$1] = requestHeaders;
                }
                if (_fetchCredentials) {
                  init.credentials = _fetchCredentials;
                } else if (_sendCredentials && _isOneDs) {
                  init.credentials = "include";
                }
                if (sync) {
                  init.keepalive = true;
                  _syncFetchPayload += batchLength;
                  if (_isOneDs) {
                    if (payload["_sendReason"] === 2) {
                      ignoreResponse = true;
                      if (_addNoResponse) {
                        endPointUrl += _noResponseQs$1;
                      }
                    }
                  } else {
                    ignoreResponse = true;
                  }
                }
                var request = new Request(endPointUrl, init);
                try {
                  request[DisabledPropertyName] = true;
                } catch (e) {
                }
                if (!sync && _enableSendPromise) {
                  thePromise = createPromise(function(resolve3, reject) {
                    resolveFunc = resolve3;
                    rejectFunc = reject;
                  });
                }
                if (!endPointUrl) {
                  _onNoPayloadUrl(oncomplete);
                  resolveFunc && resolveFunc(false);
                  return;
                }
                function _handleError(res, statusCode) {
                  if (statusCode) {
                    _doOnComplete(oncomplete, _isOneDs ? 0 : statusCode, {}, _isOneDs ? STR_EMPTY$2 : res);
                  } else {
                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY$2 : res);
                  }
                }
                function _onFetchComplete(response, payload2, value) {
                  var status = response[_DYN_STATUS];
                  var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                  if (onCompleteFunc && isFunction(onCompleteFunc)) {
                    onCompleteFunc(response, oncomplete, value || STR_EMPTY$2, payload2);
                  } else {
                    _doOnComplete(oncomplete, status, {}, value || STR_EMPTY$2);
                  }
                }
                try {
                  doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function(result) {
                    if (sync) {
                      _syncFetchPayload -= batchLength;
                      batchLength = 0;
                    }
                    if (!responseHandled) {
                      responseHandled = true;
                      if (!result.rejected) {
                        var response_1 = result[_DYN_VALUE$1];
                        try {
                          if (!_isOneDs && !response_1.ok) {
                            if (response_1[_DYN_STATUS]) {
                              _handleError(response_1.statusText, response_1[_DYN_STATUS]);
                            } else {
                              _handleError(response_1.statusText, 499);
                            }
                            resolveFunc && resolveFunc(false);
                          } else {
                            if (_isOneDs && !response_1.body) {
                              _onFetchComplete(response_1, null, STR_EMPTY$2);
                              resolveFunc && resolveFunc(true);
                            } else {
                              doAwaitResponse(response_1.text(), function(resp) {
                                _onFetchComplete(response_1, payload, resp[_DYN_VALUE$1]);
                                resolveFunc && resolveFunc(true);
                              });
                            }
                          }
                        } catch (e) {
                          if (response_1 && response_1[_DYN_STATUS]) {
                            _handleError(/* @__PURE__ */ dumpObj(e), response_1[_DYN_STATUS]);
                          } else {
                            _handleError(/* @__PURE__ */ dumpObj(e), 499);
                          }
                          rejectFunc && rejectFunc(e);
                        }
                      } else {
                        _handleError(result.reason && result.reason[_DYN_MESSAGE], 499);
                        rejectFunc && rejectFunc(result.reason);
                      }
                    }
                  });
                } catch (e) {
                  if (!responseHandled) {
                    _handleError(/* @__PURE__ */ dumpObj(e), 499);
                    rejectFunc && rejectFunc(e);
                  }
                }
                if (ignoreResponse && !responseHandled) {
                  responseHandled = true;
                  _doOnComplete(oncomplete, 200, {});
                  resolveFunc && resolveFunc(true);
                }
                if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT] > 0) {
                  _timeoutWrapper && _timeoutWrapper.set(function() {
                    if (!responseHandled) {
                      responseHandled = true;
                      _doOnComplete(oncomplete, 500, {});
                      resolveFunc && resolveFunc(true);
                    }
                  }, payload[_DYN_TIMEOUT]);
                }
                return thePromise;
              }
              function _xdrSender(payload, oncomplete, sync) {
                var _window = getWindow();
                var xdr = new XDomainRequest();
                var data = payload[_DYN_DATA];
                xdr.onload = function() {
                  var response = getResponseText(xdr);
                  var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                  if (onloadFunc && isFunction(onloadFunc)) {
                    onloadFunc(xdr, oncomplete, payload);
                  } else {
                    _doOnComplete(oncomplete, 200, {}, response);
                  }
                };
                xdr.onerror = function() {
                  _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY$2 : formatErrorMessageXdr(xdr));
                };
                xdr.ontimeout = function() {
                  _doOnComplete(oncomplete, 500, {});
                };
                xdr.onprogress = function() {
                };
                var hostingProtocol = _window && _window.location && _window.location.protocol || "";
                var endpoint = payload[_DYN_URL_STRING];
                if (!endpoint) {
                  _onNoPayloadUrl(oncomplete);
                  return;
                }
                if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                  var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                  _throwInternal(_diagLog, 2, 40, ". " + msg);
                  _onError(msg, oncomplete);
                  return;
                }
                var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE](/^(https?:)/, "");
                xdr.open(STR_POST_METHOD, endpointUrl);
                if (payload[_DYN_TIMEOUT]) {
                  xdr[_DYN_TIMEOUT] = payload[_DYN_TIMEOUT];
                }
                xdr.send(data);
                if (_isOneDs && sync) {
                  _timeoutWrapper && _timeoutWrapper.set(function() {
                    xdr.send(data);
                  }, 0);
                } else {
                  xdr.send(data);
                }
              }
              function _initDefaults() {
                _syncFetchPayload = 0;
                _isInitialized = false;
                _enableSendPromise = false;
                _diagLog = null;
                _isOneDs = null;
                _onCompleteFuncs = null;
                _disableCredentials = null;
                _fetchCredentials = null;
                _fallbackInst = null;
                _disableXhr = false;
                _disableBeacon = false;
                _disableBeaconSync = false;
                _disableFetchKeepAlive = false;
                _addNoResponse = false;
                _timeoutWrapper = null;
              }
            });
          }
          SenderPostManager2.__ieDyn = 1;
          return SenderPostManager2;
        }()
      );
      var strOnPrefix = "on";
      var strAttachEvent = "attachEvent";
      var strAddEventHelper = "addEventListener";
      var strDetachEvent = "detachEvent";
      var strRemoveEventListener = "removeEventListener";
      var strEvents = "events";
      var strVisibilityChangeEvt = "visibilitychange";
      var strPageHide = "pagehide";
      var strPageShow = "pageshow";
      var strUnload = "unload";
      var strBeforeUnload = "beforeunload";
      var strPageHideNamespace = createUniqueNamespace("aiEvtPageHide");
      var strPageShowNamespace = createUniqueNamespace("aiEvtPageShow");
      var rRemoveEmptyNs = /\.[\.]+/g;
      var rRemoveTrailingEmptyNs = /[\.]+$/;
      var _guid = 1;
      var elmNodeData = createElmNodeData("events");
      var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
      function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE]) {
          return name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY$3);
        }
        return name;
      }
      function _getEvtNamespace(eventName, evtNamespace) {
        if (evtNamespace) {
          var theNamespace_1 = STR_EMPTY$3;
          if (isArray(evtNamespace)) {
            theNamespace_1 = STR_EMPTY$3;
            arrForEach(evtNamespace, function(name) {
              name = _normalizeNamespace(name);
              if (name) {
                if (name[0] !== ".") {
                  name = "." + name;
                }
                theNamespace_1 += name;
              }
            });
          } else {
            theNamespace_1 = _normalizeNamespace(evtNamespace);
          }
          if (theNamespace_1) {
            if (theNamespace_1[0] !== ".") {
              theNamespace_1 = "." + theNamespace_1;
            }
            eventName = (eventName || STR_EMPTY$3) + theNamespace_1;
          }
        }
        var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY$3) || [];
        return {
          type: parsedEvent[1],
          ns: (parsedEvent[2] || STR_EMPTY$3).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY$3)[_DYN_SPLIT$1](".").sort().join(".")
        };
      }
      function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) {
          addDefault = true;
        }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
          registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
      }
      function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE]) {
          if (obj[strRemoveEventListener]) {
            obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture);
          } else if (obj[strDetachEvent]) {
            obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
          }
        }
      }
      function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE] && handlerRef) {
          if (obj[strAddEventHelper]) {
            obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture);
            result = true;
          } else if (obj[strAttachEvent]) {
            obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
            result = true;
          }
        }
        return result;
      }
      function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$2];
        while (idx--) {
          var theEvent = events[idx];
          if (theEvent) {
            if (!evtName.ns || evtName.ns === theEvent[_DYN_EVT_NAME].ns) {
              if (!unRegFn || unRegFn(theEvent)) {
                _doDetach(target, theEvent[_DYN_EVT_NAME], theEvent.handler, theEvent.capture);
                events[_DYN_SPLICE](idx, 1);
              }
            }
          }
        }
      }
      function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE]) {
          _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);
        } else {
          var eventCache = elmNodeData.get(target, strEvents, {});
          objForEachKey(eventCache, function(evtType, events) {
            _doUnregister(target, events, evtName, unRegFn);
          });
          if (objKeys(eventCache)[_DYN_LENGTH$2] === 0) {
            elmNodeData.kill(target, strEvents);
          }
        }
      }
      function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
          if (isArray(namespaces)) {
            newNamespaces = [theNamespace].concat(namespaces);
          } else {
            newNamespaces = [theNamespace, namespaces];
          }
          newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT$1](".");
        } else {
          newNamespaces = theNamespace;
        }
        return newNamespaces;
      }
      function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        var result = false;
        if (target) {
          try {
            var evtName = _getEvtNamespace(eventName, evtNamespace);
            result = _doAttach(target, evtName, handlerRef, useCapture);
            if (result && elmNodeData.accept(target)) {
              var registeredEvent = {
                guid: _guid++,
                evtName,
                handler: handlerRef,
                capture: useCapture
              };
              _getRegisteredEvents(target, evtName.type)[_DYN_PUSH$1](registeredEvent);
            }
          } catch (e) {
          }
        }
        return result;
      }
      function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        if (target) {
          try {
            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
            var found_1 = false;
            _unregisterEvents(target, evtName_1, function(regEvent) {
              if (evtName_1.ns && !handlerRef || regEvent.handler === handlerRef) {
                found_1 = true;
                return true;
              }
              return false;
            });
            if (!found_1) {
              _doDetach(target, evtName_1, handlerRef, useCapture);
            }
          } catch (e) {
          }
        }
      }
      function addEventHandler(eventName, callback, evtNamespace) {
        var result = false;
        var w = getWindow();
        if (w) {
          result = eventOn(w, eventName, callback, evtNamespace);
          result = eventOn(w["body"], eventName, callback, evtNamespace) || result;
        }
        var doc = getDocument();
        if (doc) {
          result = eventOn(doc, eventName, callback, evtNamespace) || result;
        }
        return result;
      }
      function removeEventHandler(eventName, callback, evtNamespace) {
        var w = getWindow();
        if (w) {
          eventOff(w, eventName, callback, evtNamespace);
          eventOff(w["body"], eventName, callback, evtNamespace);
        }
        var doc = getDocument();
        if (doc) {
          eventOff(doc, eventName, callback, evtNamespace);
        }
      }
      function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && events[_DYN_LENGTH$2] > 0) {
          arrForEach(events, function(name) {
            if (name) {
              if (!excludeEvents || arrIndexOf(excludeEvents, name) === -1) {
                added = addEventHandler(name, listener, evtNamespace) || added;
              }
            }
          });
        }
        return added;
      }
      function addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && isArray(events)) {
          added = _addEventListeners(events, listener, excludeEvents, evtNamespace);
          if (!added && excludeEvents && excludeEvents[_DYN_LENGTH$2] > 0) {
            added = _addEventListeners(events, listener, null, evtNamespace);
          }
        }
        return added;
      }
      function removeEventListeners(events, listener, evtNamespace) {
        if (events && isArray(events)) {
          arrForEach(events, function(name) {
            if (name) {
              removeEventHandler(name, listener, evtNamespace);
            }
          });
        }
      }
      function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
        return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);
      }
      function removePageUnloadEventListener(listener, evtNamespace) {
        removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);
      }
      function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
          var doc = getDocument();
          if (listener && doc && doc.visibilityState === "hidden") {
            listener(evt);
          }
        }
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);
        if (!excludeEvents || arrIndexOf(excludeEvents, strVisibilityChangeEvt) === -1) {
          pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;
        }
        if (!pageUnloadAdded && excludeEvents) {
          pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);
        }
        return pageUnloadAdded;
      }
      function removePageHideEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        removeEventListeners([strPageHide], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
      }
      function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
          var doc = getDocument();
          if (listener && doc && doc.visibilityState === "visible") {
            listener(evt);
          }
        }
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);
        pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;
        if (!pageShowAdded && excludeEvents) {
          pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);
        }
        return pageShowAdded;
      }
      function removePageShowEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        removeEventListeners([strPageShow], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
      }
      var STR_EMPTY$1 = "";
      var _DYN_TIMINGS$1 = "timings";
      var _DYN_VALUE = "value";
      var _DYN_LENGTH$1 = "length";
      var _DYN_PROCESS_TELEMETRY_ST0 = "processTelemetryStart";
      var _a$1;
      var Version = "4.3.7";
      var FullVersionString = "1DS-Web-JS-" + Version;
      var ObjHasOwnProperty = ObjProto$1.hasOwnProperty;
      var _fieldTypeEventPropMap = (_a$1 = {}, _a$1[0] = 0, _a$1[2] = 6, _a$1[1] = 1, _a$1[3] = 7, _a$1[4096 | 2] = 6, _a$1[4096 | 1] = 1, _a$1[4096 | 3] = 7, _a$1);
      function isValueAssigned(value) {
        return !(value === STR_EMPTY$1 || /* @__PURE__ */ isNullOrUndefined(value));
      }
      function getTenantId(apiKey) {
        if (apiKey) {
          var indexTenantId = strIndexOf(apiKey, "-");
          if (indexTenantId > -1) {
            return /* @__PURE__ */ strLeft(apiKey, indexTenantId);
          }
        }
        return STR_EMPTY$1;
      }
      function sanitizeProperty(name, property, stringifyObjects) {
        if (!property && !isValueAssigned(property) || typeof name !== "string") {
          return null;
        }
        var propType = typeof property;
        if (propType === "string" || propType === "number" || propType === "boolean" || isArray(property)) {
          property = { value: property };
        } else if (propType === "object" && !ObjHasOwnProperty.call(property, "value")) {
          property = { value: stringifyObjects ? JSON.stringify(property) : property };
        } else if (/* @__PURE__ */ isNullOrUndefined(property[_DYN_VALUE]) || property[_DYN_VALUE] === STR_EMPTY$1 || !isString(property[_DYN_VALUE]) && !isNumber(property[_DYN_VALUE]) && !isBoolean(property[_DYN_VALUE]) && !isArray(property[_DYN_VALUE])) {
          return null;
        }
        if (isArray(property[_DYN_VALUE]) && !isArrayValid(property[_DYN_VALUE])) {
          return null;
        }
        if (!/* @__PURE__ */ isNullOrUndefined(property.kind)) {
          if (isArray(property[_DYN_VALUE]) || !isValueKind(property.kind)) {
            return null;
          }
          property[_DYN_VALUE] = property[_DYN_VALUE].toString();
        }
        return property;
      }
      function getCommonSchemaMetaData(value, kind, type) {
        var encodedTypeValue = -1;
        if (!/* @__PURE__ */ isUndefined(value)) {
          if (kind > 0) {
            if (kind === 32) {
              encodedTypeValue = 1 << 13;
            } else if (kind <= 13) {
              encodedTypeValue = kind << 5;
            }
          }
          if (isDataType(type)) {
            if (encodedTypeValue === -1) {
              encodedTypeValue = 0;
            }
            encodedTypeValue |= type;
          } else {
            var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
            if (encodedTypeValue !== -1 && propType !== -1) {
              encodedTypeValue |= propType;
            } else if (propType === 6) {
              encodedTypeValue = propType;
            }
          }
        }
        return encodedTypeValue;
      }
      function extend(obj, obj2, obj3, obj4, obj5) {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments[_DYN_LENGTH$1];
        var theArgs = arguments;
        if (isBoolean(theArgs[0])) {
          deep = theArgs[0];
          i++;
        }
        for (; i < length; i++) {
          var obj = theArgs[i];
          objForEachKey(obj, function(prop, value) {
            if (deep && value && /* @__PURE__ */ isObject(value)) {
              if (isArray(value)) {
                extended[prop] = extended[prop] || [];
                arrForEach(value, function(arrayValue, arrayIndex) {
                  if (arrayValue && /* @__PURE__ */ isObject(arrayValue)) {
                    extended[prop][arrayIndex] = extend(true, extended[prop][arrayIndex], arrayValue);
                  } else {
                    extended[prop][arrayIndex] = arrayValue;
                  }
                });
              } else {
                extended[prop] = extend(true, extended[prop], value);
              }
            } else {
              extended[prop] = value;
            }
          });
        }
        return extended;
      }
      var getTime = perfNow;
      function isValueKind(value) {
        if (value === 0 || (value > 0 && value <= 13 || value === 32)) {
          return true;
        }
        return false;
      }
      function isDataType(value) {
        if (value >= 0 && value <= 9) {
          return true;
        }
        return false;
      }
      function isArrayValid(value) {
        return value[_DYN_LENGTH$1] > 0;
      }
      function setProcessTelemetryTimings(event, identifier) {
        var evt = event;
        evt[_DYN_TIMINGS$1] = evt[_DYN_TIMINGS$1] || {};
        evt[_DYN_TIMINGS$1][_DYN_PROCESS_TELEMETRY_ST0] = evt[_DYN_TIMINGS$1][_DYN_PROCESS_TELEMETRY_ST0] || {};
        evt[_DYN_TIMINGS$1][_DYN_PROCESS_TELEMETRY_ST0][identifier] = getTime();
      }
      function getFieldValueType(value) {
        var theType = 0;
        if (value !== null && value !== void 0) {
          var objType = typeof value;
          if (objType === "string") {
            theType = 1;
          } else if (objType === "number") {
            theType = 2;
          } else if (objType === "boolean") {
            theType = 3;
          } else if (objType === strShimObject) {
            theType = 4;
            if (isArray(value)) {
              theType = 4096;
              if (value[_DYN_LENGTH$1] > 0) {
                theType |= getFieldValueType(value[0]);
              }
            } else if (ObjHasOwnProperty.call(value, "value")) {
              theType = 8192 | getFieldValueType(value[_DYN_VALUE]);
            }
          }
        }
        return theType;
      }
      function isChromium() {
        return !!/* @__PURE__ */ getInst("chrome");
      }
      function isGreaterThanZero(value) {
        return value > 0;
      }
      var STR_EMPTY = "";
      var STR_DROPPED = "drop";
      var STR_SENDING = "send";
      var STR_REQUEUE = "requeue";
      var STR_RESPONSE_FAIL = "rspFail";
      var STR_OTHER = "oth";
      var DEFAULT_CACHE_CONTROL = "no-cache, no-store";
      var DEFAULT_CONTENT_TYPE = "application/x-json-stream";
      var STR_CACHE_CONTROL = "cache-control";
      var STR_CONTENT_TYPE_HEADER = "content-type";
      var STR_KILL_TOKENS_HEADER = "kill-tokens";
      var STR_KILL_DURATION_HEADER = "kill-duration";
      var STR_TIME_DELTA_HEADER = "time-delta-millis";
      var STR_CLIENT_VERSION = "client-version";
      var STR_CLIENT_ID = "client-id";
      var STR_TIME_DELTA_TO_APPLY = "time-delta-to-apply-millis";
      var STR_UPLOAD_TIME = "upload-time";
      var STR_API_KEY = "apikey";
      var STR_MSA_DEVICE_TICKET = "AuthMsaDeviceTicket";
      var STR_AUTH_WEB_TOKEN = "WebAuthToken";
      var STR_AUTH_XTOKEN = "AuthXToken";
      var STR_NO_RESPONSE_BODY = "NoResponseBody";
      var STR_MSFPC = "msfpc";
      var STR_TRACE = "trace";
      var STR_USER = "user";
      var _DYN_ALLOW_REQUEST_SENDIN0 = "allowRequestSending";
      var _DYN_SHOULD_ADD_CLOCK_SKE1 = "shouldAddClockSkewHeaders";
      var _DYN_GET_CLOCK_SKEW_HEADE2 = "getClockSkewHeaderValue";
      var _DYN_SET_CLOCK_SKEW = "setClockSkew";
      var _DYN_LENGTH = "length";
      var _DYN_CONCAT = "concat";
      var _DYN_I_KEY = "iKey";
      var _DYN_COUNT = "count";
      var _DYN_EVENTS = "events";
      var _DYN_PUSH = "push";
      var _DYN_SPLIT = "split";
      var _DYN_TO_LOWER_CASE = "toLowerCase";
      var _DYN_HDRS = "hdrs";
      var _DYN_USE_HDRS = "useHdrs";
      var _DYN_INITIALIZE = "initialize";
      var _DYN_SET_TIMEOUT_OVERRIDE = "setTimeoutOverride";
      var _DYN_CLEAR_TIMEOUT_OVERRI3 = "clearTimeoutOverride";
      var _DYN_PAYLOAD_PREPROCESSOR = "payloadPreprocessor";
      var _DYN_OVERRIDE_ENDPOINT_UR4 = "overrideEndpointUrl";
      var _DYN_AVOID_OPTIONS = "avoidOptions";
      var _DYN_DISABLE_EVENT_TIMING5 = "disableEventTimings";
      var _DYN_ENABLE_COMPOUND_KEY = "enableCompoundKey";
      var _DYN_DISABLE_XHR_SYNC = "disableXhrSync";
      var _DYN_DISABLE_FETCH_KEEP_A6 = "disableFetchKeepAlive";
      var _DYN_ADD_NO_RESPONSE = "addNoResponse";
      var _DYN_USE_SEND_BEACON = "useSendBeacon";
      var _DYN_FETCH_CREDENTIALS = "fetchCredentials";
      var _DYN_ALWAYS_USE_XHR_OVERR7 = "alwaysUseXhrOverride";
      var _DYN_SERIALIZE_OFFLINE_EV8 = "serializeOfflineEvt";
      var _DYN_GET_OFFLINE_REQUEST_9 = "getOfflineRequestDetails";
      var _DYN_CREATE_PAYLOAD = "createPayload";
      var _DYN_CREATE_ONE_DSPAYLOAD = "createOneDSPayload";
      var _DYN_PAYLOAD_BLOB = "payloadBlob";
      var _DYN_HEADERS = "headers";
      var _DYN__THE_PAYLOAD = "_thePayload";
      var _DYN_BATCHES = "batches";
      var _DYN_SEND_TYPE = "sendType";
      var _DYN_CAN_SEND_REQUEST = "canSendRequest";
      var _DYN_SEND_QUEUED_REQUESTS = "sendQueuedRequests";
      var _DYN_SET_UNLOADING = "setUnloading";
      var _DYN_IS_TENANT_KILLED = "isTenantKilled";
      var _DYN_SEND_SYNCHRONOUS_BAT10 = "sendSynchronousBatch";
      var _DYN__TRANSPORT = "_transport";
      var _DYN_GET_WPARAM = "getWParam";
      var _DYN_IS_BEACON = "isBeacon";
      var _DYN_TIMINGS = "timings";
      var _DYN_IS_TEARDOWN = "isTeardown";
      var _DYN__SEND_REASON = "_sendReason";
      var _DYN_SET_KILL_SWITCH_TENA11 = "setKillSwitchTenants";
      var _DYN__BACK_OFF_TRANSMISSI12 = "_backOffTransmission";
      var _DYN_IDENTIFIER = "identifier";
      var _DYN_IGNORE_MC1_MS0_COOKI13 = "ignoreMc1Ms0CookieProcessing";
      var _DYN_AUTO_FLUSH_EVENTS_LI14 = "autoFlushEventsLimit";
      var _DYN_DISABLE_AUTO_BATCH_F15 = "disableAutoBatchFlushLimit";
      var _DYN_OVERRIDE_INSTRUMENTA16 = "overrideInstrumentationKey";
      var _DYN_SEND_ATTEMPT = "sendAttempt";
      var _DYN_LATENCY = "latency";
      var _DYN_SYNC = "sync";
      function _getEventMsfpc(theEvent) {
        var intWeb = (theEvent.ext || {})["intweb"];
        if (intWeb && isValueAssigned(intWeb[STR_MSFPC])) {
          return intWeb[STR_MSFPC];
        }
        return null;
      }
      function _getMsfpc(theEvents) {
        var msfpc = null;
        for (var lp = 0; msfpc === null && lp < theEvents[_DYN_LENGTH]; lp++) {
          msfpc = _getEventMsfpc(theEvents[lp]);
        }
        return msfpc;
      }
      var EventBatch = (
        /** @class */
        function() {
          function EventBatch2(iKey, addEvents) {
            var events = addEvents ? [][_DYN_CONCAT](addEvents) : [];
            var _self = this;
            var _msfpc = _getMsfpc(events);
            _self[_DYN_I_KEY] = function() {
              return iKey;
            };
            _self.Msfpc = function() {
              return _msfpc || STR_EMPTY;
            };
            _self[_DYN_COUNT] = function() {
              return events[_DYN_LENGTH];
            };
            _self[_DYN_EVENTS] = function() {
              return events;
            };
            _self.addEvent = function(theEvent) {
              if (theEvent) {
                events[_DYN_PUSH](theEvent);
                if (!_msfpc) {
                  _msfpc = _getEventMsfpc(theEvent);
                }
                return true;
              }
              return false;
            };
            _self[_DYN_SPLIT] = function(fromEvent, numEvents) {
              var theEvents;
              if (fromEvent < events[_DYN_LENGTH]) {
                var cnt = events[_DYN_LENGTH] - fromEvent;
                if (!/* @__PURE__ */ isNullOrUndefined(numEvents)) {
                  cnt = numEvents < cnt ? numEvents : cnt;
                }
                theEvents = events.splice(fromEvent, cnt);
                _msfpc = _getMsfpc(events);
              }
              return new EventBatch2(iKey, theEvents);
            };
          }
          EventBatch2.create = function(iKey, theEvents) {
            return new EventBatch2(iKey, theEvents);
          };
          return EventBatch2;
        }()
      );
      var ClockSkewManager = (
        /** @class */
        function() {
          function ClockSkewManager2() {
            var _allowRequestSending = true;
            var _shouldAddClockSkewHeaders = true;
            var _isFirstRequest = true;
            var _clockSkewHeaderValue = "use-collector-delta";
            var _clockSkewSet = false;
            dynamicProto(ClockSkewManager2, this, function(_self) {
              _self[_DYN_ALLOW_REQUEST_SENDIN0] = function() {
                return _allowRequestSending;
              };
              _self.firstRequestSent = function() {
                if (_isFirstRequest) {
                  _isFirstRequest = false;
                  if (!_clockSkewSet) {
                    _allowRequestSending = false;
                  }
                }
              };
              _self[_DYN_SHOULD_ADD_CLOCK_SKE1] = function() {
                return _shouldAddClockSkewHeaders;
              };
              _self[_DYN_GET_CLOCK_SKEW_HEADE2] = function() {
                return _clockSkewHeaderValue;
              };
              _self[_DYN_SET_CLOCK_SKEW] = function(timeDeltaInMillis) {
                if (!_clockSkewSet) {
                  if (timeDeltaInMillis) {
                    _clockSkewHeaderValue = timeDeltaInMillis;
                    _shouldAddClockSkewHeaders = true;
                    _clockSkewSet = true;
                  } else {
                    _shouldAddClockSkewHeaders = false;
                  }
                  _allowRequestSending = true;
                }
              };
            });
          }
          ClockSkewManager2.__ieDyn = 1;
          return ClockSkewManager2;
        }()
      );
      var SecToMsMultiplier = 1e3;
      var KillSwitch = (
        /** @class */
        function() {
          function KillSwitch2() {
            var _killedTokenDictionary = {};
            function _normalizeTenants(values) {
              var result = [];
              if (values) {
                arrForEach(values, function(value) {
                  result[_DYN_PUSH](strTrim(value));
                });
              }
              return result;
            }
            dynamicProto(KillSwitch2, this, function(_self) {
              _self[_DYN_SET_KILL_SWITCH_TENA11] = function(killTokens, killDuration) {
                if (killTokens && killDuration) {
                  try {
                    var killedTokens = _normalizeTenants(killTokens[_DYN_SPLIT](","));
                    if (killDuration === "this-request-only") {
                      return killedTokens;
                    }
                    var durationMs = parseInt(killDuration, 10) * SecToMsMultiplier;
                    for (var i = 0; i < killedTokens[_DYN_LENGTH]; ++i) {
                      _killedTokenDictionary[killedTokens[i]] = /* @__PURE__ */ utcNow() + durationMs;
                    }
                  } catch (ex) {
                    return [];
                  }
                }
                return [];
              };
              _self[_DYN_IS_TENANT_KILLED] = function(tenantToken) {
                var killDictionary = _killedTokenDictionary;
                var name = strTrim(tenantToken);
                if (killDictionary[name] !== void 0 && killDictionary[name] > /* @__PURE__ */ utcNow()) {
                  return true;
                }
                delete killDictionary[name];
                return false;
              };
            });
          }
          KillSwitch2.__ieDyn = 1;
          return KillSwitch2;
        }()
      );
      var RandomizationLowerThreshold = 0.8;
      var RandomizationUpperThreshold = 1.2;
      var BaseBackoff = 3e3;
      var MaxBackoff = 6e5;
      function retryPolicyShouldRetryForStatus(httpStatusCode) {
        return !(httpStatusCode >= 300 && httpStatusCode < 500 && httpStatusCode != 429 || httpStatusCode == 501 || httpStatusCode == 505);
      }
      function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {
        var waitDuration = 0;
        var minBackoff = BaseBackoff * RandomizationLowerThreshold;
        var maxBackoff = BaseBackoff * RandomizationUpperThreshold;
        var randomBackoff = mathFloor(Math.random() * (maxBackoff - minBackoff)) + minBackoff;
        waitDuration = Math.pow(2, retriesSoFar) * randomBackoff;
        return mathMin(waitDuration, MaxBackoff);
      }
      var _MAX_STRING_JOINS = 20;
      var RequestSizeLimitBytes = 3145728;
      var BeaconRequestSizeLimitBytes = 65e3;
      var MaxRecordSize = 2e6;
      var MaxBeaconRecordSize = mathMin(MaxRecordSize, BeaconRequestSizeLimitBytes);
      var metadata = "metadata";
      var f = "f";
      var rCheckDot = /\./;
      var Serializer = (
        /** @class */
        function() {
          function Serializer2(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey, getEncodedTypeOverride, excludeCsMetaData, cfg) {
            var strData = "data";
            var strBaseData = "baseData";
            var strExt = "ext";
            var _checkForCompoundkey = !!enableCompoundKey;
            var _processSubKeys = true;
            var _theSanitizer = valueSanitizer;
            var _isReservedCache = {};
            var _excludeCsMetaData = !!excludeCsMetaData;
            var _getEncodedType = getEncodedTypeOverride || getCommonSchemaMetaData;
            var _sizeCfg = _getSizeLimtCfg(cfg);
            var _requestSizeLimitBytes = _validateSizeLimit(_sizeCfg.requestLimit, RequestSizeLimitBytes, 0);
            var _beaconRequestSizeLimitBytes = _validateSizeLimit(_sizeCfg.requestLimit, BeaconRequestSizeLimitBytes, 1);
            var _maxRecordSize = _validateSizeLimit(_sizeCfg.recordLimit, MaxRecordSize, 0);
            var _maxBeaconRecordSize = Math.min(_validateSizeLimit(_sizeCfg.recordLimit, MaxBeaconRecordSize, 1), _beaconRequestSizeLimitBytes);
            dynamicProto(Serializer2, this, function(_self) {
              _self.createPayload = function(retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {
                return {
                  apiKeys: [],
                  payloadBlob: STR_EMPTY,
                  overflow: null,
                  sizeExceed: [],
                  failedEvts: [],
                  batches: [],
                  numEvents: 0,
                  retryCnt,
                  isTeardown,
                  isSync,
                  isBeacon: isReducedPayload,
                  sendType,
                  sendReason
                };
              };
              _self.appendPayload = function(payload, theBatch, maxEventsPerBatch) {
                var canAddEvents = payload && theBatch && !payload.overflow;
                if (canAddEvents) {
                  doPerf(perfManager, function() {
                    return "Serializer:appendPayload";
                  }, function() {
                    var theEvents = theBatch.events();
                    var payloadBlob = payload.payloadBlob;
                    var payloadEvents = payload.numEvents;
                    var eventsAdded = false;
                    var sizeExceeded = [];
                    var failedEvts = [];
                    var isBeaconPayload = payload.isBeacon;
                    var requestMaxSize = isBeaconPayload ? _beaconRequestSizeLimitBytes : _requestSizeLimitBytes;
                    var recordMaxSize = isBeaconPayload ? _maxBeaconRecordSize : _maxRecordSize;
                    var lp = 0;
                    var joinCount = 0;
                    while (lp < theEvents.length) {
                      var theEvent = theEvents[lp];
                      if (theEvent) {
                        if (payloadEvents >= maxEventsPerBatch) {
                          payload.overflow = theBatch.split(lp);
                          break;
                        }
                        var eventBlob = _self.getEventBlob(theEvent);
                        if (eventBlob && eventBlob.length <= recordMaxSize) {
                          var blobLength = eventBlob.length;
                          var currentSize = payloadBlob.length;
                          if (currentSize + blobLength > requestMaxSize) {
                            payload.overflow = theBatch.split(lp);
                            break;
                          }
                          if (payloadBlob) {
                            payloadBlob += "\n";
                          }
                          payloadBlob += eventBlob;
                          joinCount++;
                          if (joinCount > _MAX_STRING_JOINS) {
                            strSubstr(payloadBlob, 0, 1);
                            joinCount = 0;
                          }
                          eventsAdded = true;
                          payloadEvents++;
                        } else {
                          if (eventBlob) {
                            sizeExceeded.push(theEvent);
                          } else {
                            failedEvts.push(theEvent);
                          }
                          theEvents.splice(lp, 1);
                          lp--;
                        }
                      }
                      lp++;
                    }
                    if (sizeExceeded.length > 0) {
                      payload.sizeExceed.push(EventBatch.create(theBatch.iKey(), sizeExceeded));
                    }
                    if (failedEvts.length > 0) {
                      payload.failedEvts.push(EventBatch.create(theBatch.iKey(), failedEvts));
                    }
                    if (eventsAdded) {
                      payload.batches.push(theBatch);
                      payload.payloadBlob = payloadBlob;
                      payload.numEvents = payloadEvents;
                      var apiKey = theBatch.iKey();
                      if (arrIndexOf(payload.apiKeys, apiKey) === -1) {
                        payload.apiKeys.push(apiKey);
                      }
                    }
                  }, function() {
                    return { payload, theBatch: { iKey: theBatch.iKey(), evts: theBatch.events() }, max: maxEventsPerBatch };
                  });
                }
                return canAddEvents;
              };
              _self.getEventBlob = function(eventData) {
                try {
                  return doPerf(perfManager, function() {
                    return "Serializer.getEventBlob";
                  }, function() {
                    var serializedEvent = {};
                    serializedEvent.name = eventData.name;
                    serializedEvent.time = eventData.time;
                    serializedEvent.ver = eventData.ver;
                    serializedEvent.iKey = "o:" + getTenantId(eventData.iKey);
                    var serializedExt = {};
                    var _addMetadataCallback;
                    if (!_excludeCsMetaData) {
                      _addMetadataCallback = function(pathKeys, key, value) {
                        _addJSONPropertyMetaData(_getEncodedType, serializedExt, pathKeys, key, value);
                      };
                    }
                    var eventExt = eventData[strExt];
                    if (eventExt) {
                      serializedEvent[strExt] = serializedExt;
                      objForEachKey(eventExt, function(key, value) {
                        var data = serializedExt[key] = {};
                        _processPathKeys(value, data, "ext." + key, true, null, null, true);
                      });
                    }
                    var serializedData = serializedEvent[strData] = {};
                    serializedData.baseType = eventData.baseType;
                    var serializedBaseData = serializedData[strBaseData] = {};
                    _processPathKeys(eventData.baseData, serializedBaseData, strBaseData, false, [strBaseData], _addMetadataCallback, _processSubKeys);
                    _processPathKeys(eventData.data, serializedData, strData, false, [], _addMetadataCallback, _processSubKeys);
                    return JSON.stringify(serializedEvent);
                  }, function() {
                    return { item: eventData };
                  });
                } catch (e) {
                  return null;
                }
              };
              function _isReservedField(path11, name) {
                var result = _isReservedCache[path11];
                if (result === void 0) {
                  if (path11.length >= 7) {
                    result = strStartsWith(path11, "ext.metadata") || strStartsWith(path11, "ext.web");
                  }
                  _isReservedCache[path11] = result;
                }
                return result;
              }
              function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {
                objForEachKey(srcObj, function(key, srcValue) {
                  var prop = null;
                  if (srcValue || isValueAssigned(srcValue)) {
                    var path11 = thePath;
                    var name_1 = key;
                    var theMetaPathKeys = metadataPathKeys;
                    var destObj = target;
                    if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {
                      var subKeys = key.split(".");
                      var keyLen = subKeys.length;
                      if (keyLen > 1) {
                        if (theMetaPathKeys) {
                          theMetaPathKeys = theMetaPathKeys.slice();
                        }
                        for (var lp = 0; lp < keyLen - 1; lp++) {
                          var subKey = subKeys[lp];
                          destObj = destObj[subKey] = destObj[subKey] || {};
                          path11 += "." + subKey;
                          if (theMetaPathKeys) {
                            theMetaPathKeys.push(subKey);
                          }
                        }
                        name_1 = subKeys[keyLen - 1];
                      }
                    }
                    var isReserved = checkReserved && _isReservedField(path11);
                    if (!isReserved && _theSanitizer && _theSanitizer.handleField(path11, name_1)) {
                      prop = _theSanitizer.value(path11, name_1, srcValue, stringifyObjects);
                    } else {
                      prop = sanitizeProperty(name_1, srcValue, stringifyObjects);
                    }
                    if (prop) {
                      var newValue = prop.value;
                      destObj[name_1] = newValue;
                      if (metadataCallback) {
                        metadataCallback(theMetaPathKeys, name_1, prop);
                      }
                      if (processSubKeys && typeof newValue === "object" && !isArray(newValue)) {
                        var newPath = theMetaPathKeys;
                        if (newPath) {
                          newPath = newPath.slice();
                          newPath.push(name_1);
                        }
                        _processPathKeys(srcValue, newValue, path11 + "." + name_1, checkReserved, newPath, metadataCallback, processSubKeys);
                      }
                    }
                  }
                });
              }
            });
          }
          Serializer2.__ieDyn = 1;
          return Serializer2;
        }()
      );
      function _validateSizeLimit(cfgVal, defaultVal, idx) {
        if (isArray(cfgVal)) {
          var val = cfgVal[idx];
          if (val > 0 && val <= defaultVal) {
            return val;
          }
        }
        return defaultVal;
      }
      function _getSizeLimtCfg(cfg) {
        var defaultCfg = {};
        if (cfg && cfg.requestLimit) {
          return cfg.requestLimit;
        }
        return defaultCfg;
      }
      function _addJSONPropertyMetaData(getEncodedType, json, propKeys, name, propertyValue) {
        if (propertyValue && json) {
          var encodedTypeValue = getEncodedType(propertyValue.value, propertyValue.kind, propertyValue.propertyType);
          if (encodedTypeValue > -1) {
            var metaData = json[metadata];
            if (!metaData) {
              metaData = json[metadata] = { f: {} };
            }
            var metaTarget = metaData[f];
            if (!metaTarget) {
              metaTarget = metaData[f] = {};
            }
            if (propKeys) {
              for (var lp = 0; lp < propKeys.length; lp++) {
                var key = propKeys[lp];
                if (!metaTarget[key]) {
                  metaTarget[key] = { f: {} };
                }
                var newTarget = metaTarget[key][f];
                if (!newTarget) {
                  newTarget = metaTarget[key][f] = {};
                }
                metaTarget = newTarget;
              }
            }
            metaTarget = metaTarget[name] = {};
            if (isArray(propertyValue.value)) {
              metaTarget["a"] = {
                t: encodedTypeValue
              };
            } else {
              metaTarget["t"] = encodedTypeValue;
            }
          }
        }
      }
      function createTimeoutWrapper(argSetTimeout, argClearTimeout) {
        return {
          set: function(callback, ms) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            return scheduleTimeoutWith([argSetTimeout, argClearTimeout], callback, ms, args);
          }
        };
      }
      var _a;
      var strSendAttempt = "sendAttempt";
      var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
      var UrlQueryString = "?cors=true&" + STR_CONTENT_TYPE_HEADER[_DYN_TO_LOWER_CASE]() + "=" + DEFAULT_CONTENT_TYPE;
      var _eventActionMap = (_a = {}, _a[1] = STR_REQUEUE, _a[100] = STR_REQUEUE, _a[200] = "sent", _a[8004] = STR_DROPPED, _a[8003] = STR_DROPPED, _a);
      var _collectorQsHeaders = {};
      var _collectorHeaderToQs = {};
      function _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {
        _collectorQsHeaders[qsName] = headerName;
        if (allowQs !== false) {
          _collectorHeaderToQs[headerName] = qsName;
        }
      }
      _addCollectorHeaderQsMapping(STR_MSA_DEVICE_TICKET, STR_MSA_DEVICE_TICKET, false);
      _addCollectorHeaderQsMapping(STR_CLIENT_VERSION, STR_CLIENT_VERSION);
      _addCollectorHeaderQsMapping(STR_CLIENT_ID, "Client-Id");
      _addCollectorHeaderQsMapping(STR_API_KEY, STR_API_KEY);
      _addCollectorHeaderQsMapping(STR_TIME_DELTA_TO_APPLY, STR_TIME_DELTA_TO_APPLY);
      _addCollectorHeaderQsMapping(STR_UPLOAD_TIME, STR_UPLOAD_TIME);
      _addCollectorHeaderQsMapping(STR_AUTH_XTOKEN, STR_AUTH_XTOKEN);
      function _hasHeader(headers, header) {
        var hasHeader = false;
        if (headers && header) {
          var keys = objKeys(headers);
          if (keys && keys[_DYN_LENGTH] > 0) {
            var lowerHeader = header[_DYN_TO_LOWER_CASE]();
            for (var lp = 0; lp < keys[_DYN_LENGTH]; lp++) {
              var value = keys[lp];
              if (value && /* @__PURE__ */ objHasOwnProperty(header, value) && value[_DYN_TO_LOWER_CASE]() === lowerHeader) {
                hasHeader = true;
                break;
              }
            }
          }
        }
        return hasHeader;
      }
      function _addRequestDetails(details, name, value, useHeaders) {
        if (name && value && value[_DYN_LENGTH] > 0) {
          if (useHeaders && _collectorQsHeaders[name]) {
            details[_DYN_HDRS][_collectorQsHeaders[name]] = value;
            details[_DYN_USE_HDRS] = true;
          } else {
            details.url += "&" + name + "=" + value;
          }
        }
      }
      function _addQueryStringParameter(qsParams, name, value) {
        for (var i = 0; i < qsParams[_DYN_LENGTH]; i++) {
          if (qsParams[i].name === name) {
            qsParams[i].value = value;
            return;
          }
        }
        qsParams[_DYN_PUSH]({ name, value });
      }
      function _removeQueryStringParameter(qsParams, name) {
        for (var i = 0; i < qsParams[_DYN_LENGTH]; i++) {
          if (qsParams[i].name === name) {
            qsParams.splice(i, 1);
            return;
          }
        }
      }
      var HttpManager = (
        /** @class */
        function() {
          function HttpManager2(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions) {
            var _urlString;
            var _killSwitch;
            var _paused;
            var _clockSkewManager;
            var _useBeacons = false;
            var _outstandingRequests;
            var _postManager;
            var _logger;
            var _sendInterfaces;
            var _core;
            var _customHttpInterface;
            var _queryStringParameters;
            var _headers;
            var _batchQueue;
            var _serializer;
            var _enableEventTimings;
            var _cookieMgr;
            var _isUnloading;
            var _useHeaders;
            var _xhrTimeout;
            var _zipPayload;
            var _disableXhrSync;
            var _disableFetchKeepAlive;
            var _canHaveReducedPayload;
            var _addNoResponse;
            var _unloadHooks;
            var _sendHook;
            var _sendListener;
            var _responseHandlers;
            var _isInitialized;
            var _timeoutWrapper;
            var _excludeCsMetaData;
            var _sendPostMgr;
            var _fetchCredentials;
            var _maxEvtPerBatch = maxEventsPerBatch;
            dynamicProto(HttpManager2, this, function(_self) {
              _initDefaults();
              var _sendCredentials = true;
              _self[_DYN_INITIALIZE] = function(theConfig, core, postChannel) {
                if (!_isInitialized) {
                  _core = core;
                  _cookieMgr = core.getCookieMgr();
                  _postManager = postChannel;
                  _logger = _postManager.diagLog();
                  arrAppend(_unloadHooks, onConfigChange(theConfig, function(details) {
                    var _a2;
                    var coreConfig = details.cfg;
                    var channelConfig = details.cfg.extensionConfig[postChannel.identifier];
                    _timeoutWrapper = createTimeoutWrapper(channelConfig[_DYN_SET_TIMEOUT_OVERRIDE], channelConfig[_DYN_CLEAR_TIMEOUT_OVERRI3]);
                    if (isValueAssigned(coreConfig.anonCookieName)) {
                      _addQueryStringParameter(_queryStringParameters, "anoncknm", coreConfig.anonCookieName);
                    } else {
                      _removeQueryStringParameter(_queryStringParameters, "anoncknm");
                    }
                    _sendHook = channelConfig[_DYN_PAYLOAD_PREPROCESSOR];
                    _sendListener = channelConfig.payloadListener;
                    var httpInterface = channelConfig.httpXHROverride;
                    var endpointUrl = channelConfig[_DYN_OVERRIDE_ENDPOINT_UR4] ? channelConfig[_DYN_OVERRIDE_ENDPOINT_UR4] : coreConfig.endpointUrl;
                    _urlString = endpointUrl + UrlQueryString;
                    _useHeaders = !/* @__PURE__ */ isUndefined(channelConfig[_DYN_AVOID_OPTIONS]) ? !channelConfig[_DYN_AVOID_OPTIONS] : true;
                    _enableEventTimings = !channelConfig[_DYN_DISABLE_EVENT_TIMING5];
                    var maxEvtCfg = channelConfig.maxEvtPerBatch;
                    _maxEvtPerBatch = maxEvtCfg && maxEvtCfg <= maxEventsPerBatch ? maxEvtCfg : maxEventsPerBatch;
                    var valueSanitizer = channelConfig.valueSanitizer;
                    var stringifyObjects = channelConfig.stringifyObjects;
                    var enableCompoundKey = !!coreConfig[_DYN_ENABLE_COMPOUND_KEY];
                    if (!/* @__PURE__ */ isUndefined(channelConfig[_DYN_ENABLE_COMPOUND_KEY])) {
                      enableCompoundKey = !!channelConfig[_DYN_ENABLE_COMPOUND_KEY];
                    }
                    _xhrTimeout = channelConfig.xhrTimeout;
                    var csStream = /* @__PURE__ */ getInst("CompressionStream");
                    _zipPayload = isFeatureEnabled("zipPayload", coreConfig, false);
                    if (!isFunction(csStream) || _sendHook) {
                      _zipPayload = false;
                    }
                    _disableXhrSync = !!channelConfig[_DYN_DISABLE_XHR_SYNC];
                    _disableFetchKeepAlive = !!channelConfig[_DYN_DISABLE_FETCH_KEEP_A6];
                    _addNoResponse = channelConfig[_DYN_ADD_NO_RESPONSE] !== false;
                    _excludeCsMetaData = !!channelConfig.excludeCsMetaData;
                    if (!!core.getPlugin("LocalStorage")) {
                      _disableFetchKeepAlive = true;
                    }
                    _useBeacons = !isReactNative();
                    _serializer = new Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey, getCommonSchemaMetaData, _excludeCsMetaData, channelConfig);
                    if (!/* @__PURE__ */ isNullOrUndefined(channelConfig[_DYN_USE_SEND_BEACON])) {
                      _useBeacons = !!channelConfig[_DYN_USE_SEND_BEACON];
                    }
                    if (channelConfig[_DYN_FETCH_CREDENTIALS]) {
                      _fetchCredentials = channelConfig[_DYN_FETCH_CREDENTIALS];
                    }
                    var sendPostConfig = _getSendPostMgrConfig();
                    if (!_sendPostMgr) {
                      _sendPostMgr = new SenderPostManager();
                      _sendPostMgr[_DYN_INITIALIZE](sendPostConfig, _logger);
                    } else {
                      _sendPostMgr.SetConfig(sendPostConfig);
                    }
                    var syncHttpInterface = httpInterface;
                    var beaconHttpInterface = channelConfig[_DYN_ALWAYS_USE_XHR_OVERR7] ? httpInterface : null;
                    var fetchSyncHttpInterface = channelConfig[_DYN_ALWAYS_USE_XHR_OVERR7] ? httpInterface : null;
                    var beaconUnloadTransports = [3, 2];
                    if (!httpInterface) {
                      _customHttpInterface = false;
                      var theTransports = [];
                      if (isReactNative()) {
                        theTransports = [2, 1];
                        beaconUnloadTransports = [2, 1, 3];
                      } else {
                        theTransports = [1, 2, 3];
                      }
                      theTransports = prependTransports(theTransports, channelConfig.transports);
                      httpInterface = _getSenderInterface(theTransports, false);
                      if (!httpInterface) {
                        _warnToConsole(_logger, "No available transport to send events");
                      }
                      syncHttpInterface = _getSenderInterface(theTransports, true);
                    }
                    if (!beaconHttpInterface) {
                      beaconUnloadTransports = prependTransports(beaconUnloadTransports, channelConfig.unloadTransports);
                      beaconHttpInterface = _getSenderInterface(beaconUnloadTransports, true);
                    }
                    _canHaveReducedPayload = !_customHttpInterface && (_useBeacons && isBeaconsSupported() || !_disableFetchKeepAlive && isFetchSupported(true));
                    _sendInterfaces = (_a2 = {}, _a2[0] = httpInterface, _a2[1] = syncHttpInterface || _getSenderInterface([1, 2, 3], true), _a2[2] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([1], true), _a2[3] = fetchSyncHttpInterface || _getSenderInterface([2, 3], true) || syncHttpInterface || _getSenderInterface([1], true), _a2);
                  }));
                  _isInitialized = true;
                }
              };
              _self.addResponseHandler = function(responseHandler) {
                _responseHandlers[_DYN_PUSH](responseHandler);
                return {
                  rm: function() {
                    var index = _responseHandlers.indexOf(responseHandler);
                    if (index >= 0) {
                      _responseHandlers.splice(index, 1);
                    }
                  }
                };
              };
              _self[_DYN_SERIALIZE_OFFLINE_EV8] = function(evt) {
                try {
                  if (_serializer) {
                    return _serializer.getEventBlob(evt);
                  }
                } catch (e) {
                }
                return STR_EMPTY;
              };
              _self[_DYN_GET_OFFLINE_REQUEST_9] = function() {
                try {
                  var payload = _serializer && _serializer[_DYN_CREATE_PAYLOAD](0, false, false, false, 1, 0);
                  return _buildRequestDetails(payload, _useHeaders);
                } catch (e) {
                }
                return null;
              };
              _self[_DYN_CREATE_ONE_DSPAYLOAD] = function(evts, optimize) {
                try {
                  var theBatches_1 = [];
                  arrForEach(evts, function(evt) {
                    if (optimize) {
                      evt = optimizeObject(evt);
                    }
                    var batch = EventBatch.create(evt[_DYN_I_KEY], [evt]);
                    theBatches_1[_DYN_PUSH](batch);
                  });
                  var thePayload = null;
                  while (theBatches_1[_DYN_LENGTH] > 0 && _serializer) {
                    var theBatch = theBatches_1.shift();
                    if (theBatch && theBatch[_DYN_COUNT]() > 0) {
                      thePayload = thePayload || _serializer[_DYN_CREATE_PAYLOAD](0, false, false, false, 1, 0);
                      _serializer.appendPayload(thePayload, theBatch, _maxEvtPerBatch);
                    }
                  }
                  var requestDetails = _buildRequestDetails(thePayload, _useHeaders);
                  var payloadData = {
                    data: thePayload[_DYN_PAYLOAD_BLOB],
                    urlString: requestDetails.url,
                    headers: requestDetails[_DYN_HDRS],
                    timeout: _xhrTimeout,
                    disableXhrSync: _disableXhrSync,
                    disableFetchKeepAlive: _disableFetchKeepAlive
                  };
                  if (_useHeaders) {
                    if (!_hasHeader(payloadData[_DYN_HEADERS], STR_CACHE_CONTROL)) {
                      payloadData[_DYN_HEADERS][STR_CACHE_CONTROL] = DEFAULT_CACHE_CONTROL;
                    }
                    if (!_hasHeader(payloadData[_DYN_HEADERS], STR_CONTENT_TYPE_HEADER)) {
                      payloadData[_DYN_HEADERS][STR_CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE;
                    }
                  }
                  return payloadData;
                } catch (e) {
                }
                return null;
              };
              function _getSenderInterface(transports, syncSupport) {
                try {
                  return _sendPostMgr && _sendPostMgr.getSenderInst(transports, syncSupport);
                } catch (e) {
                }
                return null;
              }
              _self["_getDbgPlgTargets"] = function() {
                return [_sendInterfaces[0], _killSwitch, _serializer, _sendInterfaces, _getSendPostMgrConfig(), _urlString, _maxEvtPerBatch];
              };
              function _getSendPostMgrConfig() {
                try {
                  var onCompleteFuncs = {
                    xdrOnComplete: _xdrOncomplete,
                    fetchOnComplete: _fetchOnComplete,
                    xhrOnComplete: _xhrOnComplete,
                    beaconOnRetry: _onBeaconRetry
                  };
                  var config = {
                    enableSendPromise: false,
                    isOneDs: true,
                    disableCredentials: !_sendCredentials,
                    fetchCredentials: _fetchCredentials,
                    disableXhr: false,
                    disableBeacon: !_useBeacons,
                    disableBeaconSync: !_useBeacons,
                    disableFetchKeepAlive: _disableFetchKeepAlive,
                    timeWrapper: _timeoutWrapper,
                    addNoResponse: _addNoResponse,
                    senderOnCompleteCallBack: onCompleteFuncs
                  };
                  return config;
                } catch (e) {
                }
                return null;
              }
              function _xdrOncomplete(xdr, oncomplete, payload) {
                var response = getResponseText(xdr);
                _doOnComplete(oncomplete, 200, {}, response);
                _handleCollectorResponse(response);
              }
              function _initDefaults() {
                var undefValue2;
                _urlString = null;
                _killSwitch = new KillSwitch();
                _paused = false;
                _clockSkewManager = new ClockSkewManager();
                _useBeacons = false;
                _outstandingRequests = 0;
                _postManager = null;
                _logger = null;
                _sendInterfaces = null;
                _core = null;
                _customHttpInterface = true;
                _queryStringParameters = [];
                _headers = {};
                _batchQueue = [];
                _serializer = null;
                _enableEventTimings = false;
                _cookieMgr = null;
                _isUnloading = false;
                _useHeaders = false;
                _xhrTimeout = undefValue2;
                _disableXhrSync = undefValue2;
                _disableFetchKeepAlive = undefValue2;
                _canHaveReducedPayload = undefValue2;
                _addNoResponse = undefValue2;
                _unloadHooks = [];
                _sendHook = undefValue2;
                _sendListener = undefValue2;
                _responseHandlers = [];
                _isInitialized = false;
                _timeoutWrapper = createTimeoutWrapper();
                _excludeCsMetaData = false;
                _sendPostMgr = null;
                _maxEvtPerBatch = null;
              }
              function _fetchOnComplete(response, onComplete, resValue, payload) {
                var handleResponse = function(status, headerMap2, responseText) {
                  _doOnComplete(onComplete, status, headerMap2, responseText);
                  _handleCollectorResponse(responseText);
                };
                var headerMap = {};
                var headers = response[_DYN_HEADERS];
                if (headers) {
                  headers["forEach"](function(value, name) {
                    headerMap[name] = value;
                  });
                }
                handleResponse(response.status, headerMap, resValue || STR_EMPTY);
              }
              function _xhrOnComplete(request, oncomplete, payload) {
                var response = getResponseText(request);
                _doOnComplete(oncomplete, request.status, _getAllResponseHeaders(request, true), response);
                _handleCollectorResponse(response);
              }
              function _doOnComplete(oncomplete, status, headers, response) {
                try {
                  oncomplete(status, headers, response);
                } catch (e) {
                  _throwInternal(_logger, 2, 518, /* @__PURE__ */ dumpObj(e));
                }
              }
              function _onBeaconRetry(payload, onComplete, canSend) {
                var internalPayloadData = payload;
                var status = 200;
                var thePayload = internalPayloadData[_DYN__THE_PAYLOAD];
                var theUrl = payload.urlString + (_addNoResponse ? _noResponseQs : STR_EMPTY);
                try {
                  var nav_1 = getNavigator();
                  if (thePayload) {
                    var persistStorage = !!_core.getPlugin("LocalStorage");
                    var droppedBatches_1 = [];
                    var sentBatches_1 = [];
                    arrForEach(thePayload[_DYN_BATCHES], function(theBatch) {
                      if (droppedBatches_1 && theBatch && theBatch[_DYN_COUNT]() > 0) {
                        var theEvents = theBatch[_DYN_EVENTS]();
                        for (var lp = 0; lp < theEvents[_DYN_LENGTH]; lp++) {
                          if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {
                            droppedBatches_1[_DYN_PUSH](theBatch[_DYN_SPLIT](lp));
                            break;
                          } else {
                            sentBatches_1[_DYN_PUSH](theBatch[lp]);
                          }
                        }
                      } else {
                        droppedBatches_1[_DYN_PUSH](theBatch[_DYN_SPLIT](0));
                      }
                    });
                    if (sentBatches_1[_DYN_LENGTH] > 0) {
                      thePayload.sentEvts = sentBatches_1;
                    }
                    if (!persistStorage) {
                      _sendBatchesNotification(droppedBatches_1, 8003, thePayload[_DYN_SEND_TYPE], true);
                    }
                  } else {
                    status = 0;
                  }
                } catch (ex) {
                  _warnToConsole(_logger, "Failed to send telemetry using sendBeacon API. Ex:" + /* @__PURE__ */ dumpObj(ex));
                  status = 0;
                } finally {
                  _doOnComplete(onComplete, status, {}, STR_EMPTY);
                }
              }
              function _isBeaconPayload(sendType) {
                return sendType === 2 || sendType === 3;
              }
              function _adjustSendType(sendType) {
                if (_isUnloading && _isBeaconPayload(sendType)) {
                  sendType = 2;
                }
                return sendType;
              }
              _self.addHeader = function(name, value) {
                _headers[name] = value;
              };
              _self.removeHeader = function(name) {
                delete _headers[name];
              };
              _self[_DYN_CAN_SEND_REQUEST] = function() {
                return _hasIdleConnection() && _clockSkewManager[_DYN_ALLOW_REQUEST_SENDIN0]();
              };
              _self[_DYN_SEND_QUEUED_REQUESTS] = function(sendType, sendReason) {
                if (/* @__PURE__ */ isUndefined(sendType)) {
                  sendType = 0;
                }
                if (_isUnloading) {
                  sendType = _adjustSendType(sendType);
                  sendReason = 2;
                }
                if (_canSendPayload(_batchQueue, sendType, 0)) {
                  _sendBatches(_clearQueue(), 0, false, sendType, sendReason || 0);
                }
              };
              _self.isCompletelyIdle = function() {
                return !_paused && _outstandingRequests === 0 && _batchQueue[_DYN_LENGTH] === 0;
              };
              _self[_DYN_SET_UNLOADING] = function(value) {
                _isUnloading = value;
              };
              _self.addBatch = function(theBatch) {
                if (theBatch && theBatch[_DYN_COUNT]() > 0) {
                  if (_killSwitch.isTenantKilled(theBatch[_DYN_I_KEY]())) {
                    return false;
                  }
                  _batchQueue[_DYN_PUSH](theBatch);
                }
                return true;
              };
              _self.teardown = function() {
                if (_batchQueue[_DYN_LENGTH] > 0) {
                  _sendBatches(_clearQueue(), 0, true, 2, 2);
                }
                arrForEach(_unloadHooks, function(hook) {
                  hook && hook.rm && hook.rm();
                });
                _unloadHooks = [];
              };
              _self.pause = function() {
                _paused = true;
              };
              _self.resume = function() {
                _paused = false;
                _self[_DYN_SEND_QUEUED_REQUESTS](0, 4);
              };
              _self[_DYN_SEND_SYNCHRONOUS_BAT10] = function(batch, sendType, sendReason) {
                if (batch && batch[_DYN_COUNT]() > 0) {
                  if (/* @__PURE__ */ isNullOrUndefined(sendType)) {
                    sendType = 1;
                  }
                  if (_isUnloading) {
                    sendType = _adjustSendType(sendType);
                    sendReason = 2;
                  }
                  _sendBatches([batch], 0, false, sendType, sendReason || 0);
                }
              };
              function _hasIdleConnection() {
                return !_paused && _outstandingRequests < maxConnections;
              }
              function _clearQueue() {
                var theQueue = _batchQueue;
                _batchQueue = [];
                return theQueue;
              }
              function _canSendPayload(theBatches, sendType, retryCnt) {
                var result = false;
                if (theBatches && theBatches[_DYN_LENGTH] > 0 && !_paused && _sendInterfaces[sendType] && _serializer) {
                  result = sendType !== 0 || _hasIdleConnection() && (retryCnt > 0 || _clockSkewManager[_DYN_ALLOW_REQUEST_SENDIN0]());
                }
                return result;
              }
              function _createDebugBatches(theBatches) {
                var values = {};
                if (theBatches) {
                  arrForEach(theBatches, function(theBatch, idx) {
                    values[idx] = {
                      iKey: theBatch[_DYN_I_KEY](),
                      evts: theBatch[_DYN_EVENTS]()
                    };
                  });
                }
                return values;
              }
              function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {
                if (!theBatches || theBatches[_DYN_LENGTH] === 0) {
                  return;
                }
                if (_paused) {
                  _sendBatchesNotification(theBatches, 1, sendType);
                  return;
                }
                sendType = _adjustSendType(sendType);
                try {
                  var orgBatches_1 = theBatches;
                  var isSynchronous_1 = sendType !== 0;
                  doPerf(_core, function() {
                    return "HttpManager:_sendBatches";
                  }, function(perfEvt) {
                    if (perfEvt) {
                      theBatches = theBatches.slice(0);
                    }
                    var droppedBatches = [];
                    var thePayload = null;
                    var serializationStart = getTime();
                    var sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1] : _sendInterfaces[0]);
                    var sendTransport = sendInterface && sendInterface[_DYN__TRANSPORT];
                    var isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || (sendTransport === 3 || sendInterface._isSync && sendTransport === 2));
                    while (_canSendPayload(theBatches, sendType, retryCount)) {
                      var theBatch = theBatches.shift();
                      if (theBatch && theBatch[_DYN_COUNT]() > 0) {
                        if (!_killSwitch.isTenantKilled(theBatch[_DYN_I_KEY]())) {
                          thePayload = thePayload || _serializer[_DYN_CREATE_PAYLOAD](retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType);
                          if (!_serializer.appendPayload(thePayload, theBatch, _maxEvtPerBatch)) {
                            _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);
                            serializationStart = getTime();
                            theBatches = [theBatch][_DYN_CONCAT](theBatches);
                            thePayload = null;
                          } else if (thePayload.overflow !== null) {
                            theBatches = [thePayload.overflow][_DYN_CONCAT](theBatches);
                            thePayload.overflow = null;
                            _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);
                            serializationStart = getTime();
                            thePayload = null;
                          }
                        } else {
                          droppedBatches[_DYN_PUSH](theBatch);
                        }
                      }
                    }
                    if (thePayload) {
                      _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);
                    }
                    if (theBatches[_DYN_LENGTH] > 0) {
                      _batchQueue = theBatches[_DYN_CONCAT](_batchQueue);
                    }
                    _sendBatchesNotification(droppedBatches, 8004, sendType);
                  }, function() {
                    return { batches: _createDebugBatches(orgBatches_1), retryCount, isTeardown, isSynchronous: isSynchronous_1, sendReason, useSendBeacon: _isBeaconPayload(sendType), sendType };
                  }, !isSynchronous_1);
                } catch (ex) {
                  _throwInternal(_logger, 2, 48, "Unexpected Exception sending batch: " + /* @__PURE__ */ dumpObj(ex));
                }
              }
              function _buildRequestDetails(thePayload, useHeaders) {
                var requestDetails = {
                  url: _urlString,
                  hdrs: {},
                  useHdrs: false
                };
                if (!useHeaders) {
                  objForEachKey(_headers, function(name, value) {
                    if (_collectorHeaderToQs[name]) {
                      _addRequestDetails(requestDetails, _collectorHeaderToQs[name], value, false);
                    } else {
                      requestDetails[_DYN_HDRS][name] = value;
                      requestDetails[_DYN_USE_HDRS] = true;
                    }
                  });
                } else {
                  requestDetails[_DYN_HDRS] = extend(requestDetails[_DYN_HDRS], _headers);
                  requestDetails.useHdrs = objKeys(requestDetails.hdrs)[_DYN_LENGTH] > 0;
                }
                _addRequestDetails(requestDetails, STR_CLIENT_ID, "NO_AUTH", useHeaders);
                _addRequestDetails(requestDetails, STR_CLIENT_VERSION, FullVersionString, useHeaders);
                var apiQsKeys = STR_EMPTY;
                arrForEach(thePayload.apiKeys, function(apiKey) {
                  if (apiQsKeys[_DYN_LENGTH] > 0) {
                    apiQsKeys += ",";
                  }
                  apiQsKeys += apiKey;
                });
                _addRequestDetails(requestDetails, STR_API_KEY, apiQsKeys, useHeaders);
                _addRequestDetails(requestDetails, STR_UPLOAD_TIME, (/* @__PURE__ */ utcNow()).toString(), useHeaders);
                var msfpc = _getMsfpc2(thePayload);
                if (isValueAssigned(msfpc)) {
                  requestDetails.url += "&ext.intweb.msfpc=" + msfpc;
                }
                if (_clockSkewManager[_DYN_SHOULD_ADD_CLOCK_SKE1]()) {
                  _addRequestDetails(requestDetails, STR_TIME_DELTA_TO_APPLY, _clockSkewManager[_DYN_GET_CLOCK_SKEW_HEADE2](), useHeaders);
                }
                if (_core[_DYN_GET_WPARAM]) {
                  var wParam = _core[_DYN_GET_WPARAM]();
                  if (wParam >= 0) {
                    requestDetails.url += "&w=" + wParam;
                  }
                }
                for (var i = 0; i < _queryStringParameters[_DYN_LENGTH]; i++) {
                  requestDetails.url += "&" + _queryStringParameters[i].name + "=" + _queryStringParameters[i].value;
                }
                return requestDetails;
              }
              function _setTimingValue(timings, name, value) {
                timings[name] = timings[name] || {};
                timings[name][_postManager.identifier] = value;
              }
              function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {
                if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob[_DYN_LENGTH] > 0) {
                  var useSendHook_1 = !!_sendHook;
                  var sendInterface_1 = _sendInterfaces[thePayload.sendType];
                  if (!_isBeaconPayload(thePayload[_DYN_SEND_TYPE]) && thePayload[_DYN_IS_BEACON] && thePayload.sendReason === 2) {
                    sendInterface_1 = _sendInterfaces[2] || _sendInterfaces[3] || sendInterface_1;
                  }
                  var useHeaders_1 = _useHeaders;
                  if (thePayload.isBeacon || sendInterface_1[_DYN__TRANSPORT] === 3) {
                    useHeaders_1 = false;
                  }
                  var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);
                  useHeaders_1 = useHeaders_1 || requestDetails_1[_DYN_USE_HDRS];
                  var sendEventStart_1 = getTime();
                  doPerf(_core, function() {
                    return "HttpManager:_doPayloadSend";
                  }, function() {
                    for (var batchLp = 0; batchLp < thePayload.batches[_DYN_LENGTH]; batchLp++) {
                      var theBatch = thePayload[_DYN_BATCHES][batchLp];
                      var theEvents = theBatch[_DYN_EVENTS]();
                      for (var evtLp = 0; evtLp < theEvents[_DYN_LENGTH]; evtLp++) {
                        var telemetryItem = theEvents[evtLp];
                        if (_enableEventTimings) {
                          var timings = telemetryItem[_DYN_TIMINGS] = telemetryItem[_DYN_TIMINGS] || {};
                          _setTimingValue(timings, "sendEventStart", sendEventStart_1);
                          _setTimingValue(timings, "serializationStart", serializationStart);
                          _setTimingValue(timings, "serializationCompleted", serializationCompleted);
                        }
                        telemetryItem[strSendAttempt] > 0 ? telemetryItem[strSendAttempt]++ : telemetryItem[strSendAttempt] = 1;
                      }
                    }
                    _sendBatchesNotification(thePayload[_DYN_BATCHES], 1e3 + (sendReason || 0), thePayload[_DYN_SEND_TYPE], true);
                    var orgPayloadData = {
                      data: thePayload[_DYN_PAYLOAD_BLOB],
                      urlString: requestDetails_1.url,
                      headers: requestDetails_1[_DYN_HDRS],
                      _thePayload: thePayload,
                      _sendReason: sendReason,
                      timeout: _xhrTimeout,
                      disableXhrSync: _disableXhrSync,
                      disableFetchKeepAlive: _disableFetchKeepAlive
                    };
                    if (useHeaders_1) {
                      if (!_hasHeader(orgPayloadData[_DYN_HEADERS], STR_CACHE_CONTROL)) {
                        orgPayloadData[_DYN_HEADERS][STR_CACHE_CONTROL] = DEFAULT_CACHE_CONTROL;
                      }
                      if (!_hasHeader(orgPayloadData[_DYN_HEADERS], STR_CONTENT_TYPE_HEADER)) {
                        orgPayloadData[_DYN_HEADERS][STR_CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE;
                      }
                    }
                    var sender = null;
                    if (sendInterface_1) {
                      sender = function(payload) {
                        _clockSkewManager.firstRequestSent();
                        var onComplete = function(status, headers) {
                          _retryRequestIfNeeded(status, headers, thePayload, sendReason);
                        };
                        var isSync = thePayload[_DYN_IS_TEARDOWN] || thePayload.isSync;
                        _sendPostMgr.preparePayload(function(processedPayload) {
                          try {
                            sendInterface_1.sendPOST(processedPayload, onComplete, isSync);
                            if (_sendListener) {
                              _sendListener(orgPayloadData, processedPayload, isSync, thePayload[_DYN_IS_BEACON]);
                            }
                          } catch (ex) {
                            _doOnComplete(onComplete, 0, {});
                            _warnToConsole(_logger, "Unexpected exception sending payload. Ex:" + /* @__PURE__ */ dumpObj(ex));
                          }
                        }, _zipPayload, payload, isSync);
                      };
                    }
                    doPerf(_core, function() {
                      return "HttpManager:_doPayloadSend.sender";
                    }, function() {
                      if (sender) {
                        if (thePayload[_DYN_SEND_TYPE] === 0) {
                          _outstandingRequests++;
                        }
                        if (useSendHook_1 && !thePayload.isBeacon && sendInterface_1[_DYN__TRANSPORT] !== 3) {
                          var hookData_1 = {
                            data: orgPayloadData.data,
                            urlString: orgPayloadData.urlString,
                            headers: extend({}, orgPayloadData[_DYN_HEADERS]),
                            timeout: orgPayloadData.timeout,
                            disableXhrSync: orgPayloadData[_DYN_DISABLE_XHR_SYNC],
                            disableFetchKeepAlive: orgPayloadData[_DYN_DISABLE_FETCH_KEEP_A6]
                          };
                          var senderCalled_1 = false;
                          doPerf(_core, function() {
                            return "HttpManager:_doPayloadSend.sendHook";
                          }, function() {
                            try {
                              _sendHook(hookData_1, function(payload) {
                                senderCalled_1 = true;
                                if (!_customHttpInterface && !payload[_DYN__THE_PAYLOAD]) {
                                  payload[_DYN__THE_PAYLOAD] = payload[_DYN__THE_PAYLOAD] || orgPayloadData[_DYN__THE_PAYLOAD];
                                  payload[_DYN__SEND_REASON] = payload[_DYN__SEND_REASON] || orgPayloadData[_DYN__SEND_REASON];
                                }
                                sender(payload);
                              }, thePayload.isSync || thePayload[_DYN_IS_TEARDOWN]);
                            } catch (ex) {
                              if (!senderCalled_1) {
                                sender(orgPayloadData);
                              }
                            }
                          });
                        } else {
                          sender(orgPayloadData);
                        }
                      }
                    });
                  }, function() {
                    return { thePayload, serializationStart, serializationCompleted, sendReason };
                  }, thePayload.isSync);
                }
                if (thePayload.sizeExceed && thePayload.sizeExceed[_DYN_LENGTH] > 0) {
                  _sendBatchesNotification(thePayload.sizeExceed, 8003, thePayload[_DYN_SEND_TYPE]);
                }
                if (thePayload.failedEvts && thePayload.failedEvts[_DYN_LENGTH] > 0) {
                  _sendBatchesNotification(thePayload.failedEvts, 8002, thePayload[_DYN_SEND_TYPE]);
                }
              }
              function _addEventCompletedTimings(theEvents, sendEventCompleted) {
                if (_enableEventTimings) {
                  arrForEach(theEvents, function(theEvent) {
                    var timings = theEvent[_DYN_TIMINGS] = theEvent[_DYN_TIMINGS] || {};
                    _setTimingValue(timings, "sendEventCompleted", sendEventCompleted);
                  });
                }
              }
              function _retryRequestIfNeeded(status, headers, thePayload, sendReason) {
                var reason = 9e3;
                var droppedBatches = null;
                var isRetrying = false;
                var backOffTrans = false;
                try {
                  var shouldRetry = true;
                  if (typeof status !== strShimUndefined) {
                    if (headers) {
                      _clockSkewManager[_DYN_SET_CLOCK_SKEW](headers[STR_TIME_DELTA_HEADER]);
                      var killDuration = headers[STR_KILL_DURATION_HEADER] || headers["kill-duration-seconds"];
                      arrForEach(_killSwitch[_DYN_SET_KILL_SWITCH_TENA11](headers[STR_KILL_TOKENS_HEADER], killDuration), function(killToken) {
                        arrForEach(thePayload[_DYN_BATCHES], function(theBatch) {
                          if (theBatch[_DYN_I_KEY]() === killToken) {
                            droppedBatches = droppedBatches || [];
                            var removedEvents = theBatch[_DYN_SPLIT](0);
                            thePayload.numEvents -= removedEvents[_DYN_COUNT]();
                            droppedBatches[_DYN_PUSH](removedEvents);
                          }
                        });
                      });
                    }
                    if (status == 200 || status == 204) {
                      reason = 200;
                      return;
                    }
                    if (!retryPolicyShouldRetryForStatus(status) || thePayload.numEvents <= 0) {
                      shouldRetry = false;
                    }
                    reason = 9e3 + status % 1e3;
                  }
                  if (shouldRetry) {
                    reason = 100;
                    var retryCount_1 = thePayload.retryCnt;
                    if (thePayload[_DYN_SEND_TYPE] === 0) {
                      if (retryCount_1 < maxRequestRetriesBeforeBackoff) {
                        isRetrying = true;
                        _doAction(function() {
                          if (thePayload[_DYN_SEND_TYPE] === 0) {
                            _outstandingRequests--;
                          }
                          _sendBatches(thePayload[_DYN_BATCHES], retryCount_1 + 1, thePayload[_DYN_IS_TEARDOWN], _isUnloading ? 2 : thePayload[_DYN_SEND_TYPE], 5);
                        }, _isUnloading, retryPolicyGetMillisToBackoffForRetry(retryCount_1));
                      } else {
                        backOffTrans = true;
                        if (_isUnloading) {
                          reason = 8001;
                        }
                      }
                    }
                  }
                } finally {
                  if (!isRetrying) {
                    _clockSkewManager[_DYN_SET_CLOCK_SKEW]();
                    _handleRequestFinished(thePayload, reason, sendReason, backOffTrans);
                  }
                  _sendBatchesNotification(droppedBatches, 8004, thePayload[_DYN_SEND_TYPE]);
                }
              }
              function _handleRequestFinished(thePayload, batchReason, sendReason, backOffTrans) {
                try {
                  if (backOffTrans) {
                    _postManager[_DYN__BACK_OFF_TRANSMISSI12]();
                  }
                  var theBatches = thePayload[_DYN_BATCHES];
                  if (batchReason === 200) {
                    theBatches = thePayload.sentEvts || thePayload[_DYN_BATCHES];
                    if (!backOffTrans && !thePayload.isSync) {
                      _postManager._clearBackOff();
                    }
                    _addCompleteTimings(theBatches);
                  }
                  _sendBatchesNotification(theBatches, batchReason, thePayload[_DYN_SEND_TYPE], true);
                } finally {
                  if (thePayload[_DYN_SEND_TYPE] === 0) {
                    _outstandingRequests--;
                    if (sendReason !== 5) {
                      _self.sendQueuedRequests(thePayload[_DYN_SEND_TYPE], sendReason);
                    }
                  }
                }
              }
              function _addCompleteTimings(theBatches) {
                if (_enableEventTimings) {
                  var sendEventCompleted_1 = getTime();
                  arrForEach(theBatches, function(theBatch) {
                    if (theBatch && theBatch[_DYN_COUNT]() > 0) {
                      _addEventCompletedTimings(theBatch[_DYN_EVENTS](), sendEventCompleted_1);
                    }
                  });
                }
              }
              function _doAction(cb, isSync, interval) {
                if (isSync) {
                  cb();
                } else {
                  _timeoutWrapper.set(cb, interval);
                }
              }
              function _getMsfpc2(thePayload) {
                for (var lp = 0; lp < thePayload.batches[_DYN_LENGTH]; lp++) {
                  var msfpc = thePayload[_DYN_BATCHES][lp].Msfpc();
                  if (msfpc) {
                    return encodeURIComponent(msfpc);
                  }
                }
                return STR_EMPTY;
              }
              function _handleCollectorResponse(responseText) {
                var responseHandlers = _responseHandlers;
                try {
                  for (var i = 0; i < responseHandlers[_DYN_LENGTH]; i++) {
                    try {
                      responseHandlers[i](responseText);
                    } catch (e) {
                      _throwInternal(_logger, 1, 519, "Response handler failed: " + e);
                    }
                  }
                  if (responseText) {
                    var response = JSON.parse(responseText);
                    if (isValueAssigned(response.webResult) && isValueAssigned(response.webResult[STR_MSFPC])) {
                      _cookieMgr.set("MSFPC", response.webResult[STR_MSFPC], 365 * 86400);
                    }
                  }
                } catch (ex) {
                }
              }
              function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {
                if (theBatches && theBatches[_DYN_LENGTH] > 0 && actions) {
                  var theAction_1 = actions[_getNotificationAction(batchReason)];
                  if (theAction_1) {
                    var isSyncRequest_1 = sendType !== 0;
                    doPerf(_core, function() {
                      return "HttpManager:_sendBatchesNotification";
                    }, function() {
                      _doAction(function() {
                        try {
                          theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);
                        } catch (e) {
                          _throwInternal(_logger, 1, 74, "send request notification failed: " + e);
                        }
                      }, sendSync || isSyncRequest_1, 0);
                    }, function() {
                      return { batches: _createDebugBatches(theBatches), reason: batchReason, isSync: isSyncRequest_1, sendSync, sendType };
                    }, !isSyncRequest_1);
                  }
                }
              }
              function _getNotificationAction(reason) {
                var action = _eventActionMap[reason];
                if (!isValueAssigned(action)) {
                  action = STR_OTHER;
                  if (reason >= 9e3 && reason <= 9999) {
                    action = STR_RESPONSE_FAIL;
                  } else if (reason >= 8e3 && reason <= 8999) {
                    action = STR_DROPPED;
                  } else if (reason >= 1e3 && reason <= 1999) {
                    action = STR_SENDING;
                  }
                }
                return action;
              }
            });
          }
          HttpManager2.__ieDyn = 1;
          return HttpManager2;
        }()
      );
      var FlushCheckTimer = 0.25;
      var MaxNumberEventPerBatch = 500;
      var EventsDroppedAtOneTime = 20;
      var MaxSendAttempts = 6;
      var MaxSyncUnloadSendAttempts = 2;
      var MaxBackoffCount = 4;
      var MaxConnections = 2;
      var MaxRequestRetriesBeforeBackoff = 1;
      var MaxEventsLimitInMem = 1e4;
      var strEventsDiscarded = "eventsDiscarded";
      var EMPTY_STR = "";
      var undefValue = void 0;
      var defaultPostChannelConfig = objDeepFreeze({
        eventsLimitInMem: { isVal: isGreaterThanZero, v: MaxEventsLimitInMem },
        immediateEventLimit: { isVal: isGreaterThanZero, v: 500 },
        autoFlushEventsLimit: { isVal: isGreaterThanZero, v: 0 },
        disableAutoBatchFlushLimit: false,
        httpXHROverride: { isVal: isOverrideFn, v: undefValue },
        overrideInstrumentationKey: undefValue,
        overrideEndpointUrl: undefValue,
        disableTelemetry: false,
        ignoreMc1Ms0CookieProcessing: false,
        setTimeoutOverride: undefValue,
        clearTimeoutOverride: undefValue,
        payloadPreprocessor: undefValue,
        payloadListener: undefValue,
        disableEventTimings: undefValue,
        valueSanitizer: undefValue,
        stringifyObjects: undefValue,
        enableCompoundKey: undefValue,
        disableOptimizeObj: false,
        fetchCredentials: undefValue,
        transports: undefValue,
        unloadTransports: undefValue,
        useSendBeacon: undefValue,
        disableFetchKeepAlive: undefValue,
        avoidOptions: false,
        xhrTimeout: undefValue,
        disableXhrSync: undefValue,
        alwaysUseXhrOverride: false,
        maxEventRetryAttempts: { isVal: isNumber, v: MaxSendAttempts },
        maxUnloadEventRetryAttempts: { isVal: isNumber, v: MaxSyncUnloadSendAttempts },
        addNoResponse: undefValue,
        maxEvtPerBatch: { isVal: isNumber, v: MaxNumberEventPerBatch },
        excludeCsMetaData: undefValue,
        requestLimit: {}
      });
      function isOverrideFn(httpXHROverride) {
        return httpXHROverride && httpXHROverride.sendPOST;
      }
      var PostChannel = (
        /** @class */
        function(_super) {
          __extendsFn(PostChannel2, _super);
          function PostChannel2() {
            var _this = _super.call(this) || this;
            _this.identifier = "PostChannel";
            _this.priority = 1011;
            _this.version = "4.3.7";
            var _postConfig;
            var _isTeardownCalled = false;
            var _flushCallbackQueue = [];
            var _flushCallbackTimer;
            var _paused = false;
            var _immediateQueueSize = 0;
            var _immediateQueueSizeLimit;
            var _queueSize = 0;
            var _queueSizeLimit;
            var _profiles = {};
            var _currentProfile = RT_PROFILE;
            var _scheduledTimer;
            var _immediateTimer;
            var _currentBackoffCount;
            var _timerCount;
            var _httpManager;
            var _batchQueues;
            var _autoFlushEventsLimit;
            var _autoFlushBatchLimit;
            var _delayedBatchSendLatency;
            var _delayedBatchReason;
            var _optimizeObject;
            var _isPageUnloadTriggered;
            var _maxEventSendAttempts;
            var _maxUnloadEventSendAttempts;
            var _evtNamespace;
            var _timeoutWrapper;
            var _ignoreMc1Ms0CookieProcessing;
            var _disableAutoBatchFlushLimit;
            var _notificationManager;
            var _unloadHandlersAdded;
            var _overrideInstrumentationKey;
            var _disableTelemetry;
            var _maxEvtPerBatch;
            dynamicProto(PostChannel2, _this, function(_self, _base) {
              _initDefaults();
              _self["_getDbgPlgTargets"] = function() {
                return [_httpManager, _postConfig];
              };
              _self[_DYN_INITIALIZE] = function(theConfig, core, extensions3) {
                doPerf(core, function() {
                  return "PostChannel:initialize";
                }, function() {
                  _base[_DYN_INITIALIZE](theConfig, core, extensions3);
                  _notificationManager = core.getNotifyMgr();
                  try {
                    _evtNamespace = mergeEvtNamespace(createUniqueNamespace(_self[_DYN_IDENTIFIER]), core.evtNamespace && core.evtNamespace());
                    _self._addHook(onConfigChange(theConfig, function(details) {
                      var coreConfig = details.cfg;
                      var ctx = createProcessTelemetryContext(null, coreConfig, core);
                      _postConfig = ctx.getExtCfg(_self[_DYN_IDENTIFIER], defaultPostChannelConfig);
                      _timeoutWrapper = createTimeoutWrapper(_postConfig[_DYN_SET_TIMEOUT_OVERRIDE], _postConfig[_DYN_CLEAR_TIMEOUT_OVERRI3]);
                      _optimizeObject = !_postConfig.disableOptimizeObj && isChromium();
                      _ignoreMc1Ms0CookieProcessing = _postConfig[_DYN_IGNORE_MC1_MS0_COOKI13];
                      _hookWParam(core);
                      _queueSizeLimit = _postConfig.eventsLimitInMem;
                      _immediateQueueSizeLimit = _postConfig.immediateEventLimit;
                      _autoFlushEventsLimit = _postConfig[_DYN_AUTO_FLUSH_EVENTS_LI14];
                      _maxEventSendAttempts = _postConfig.maxEventRetryAttempts;
                      _maxUnloadEventSendAttempts = _postConfig.maxUnloadEventRetryAttempts;
                      _disableAutoBatchFlushLimit = _postConfig[_DYN_DISABLE_AUTO_BATCH_F15];
                      _maxEvtPerBatch = _postConfig.maxEvtPerBatch;
                      if (/* @__PURE__ */ isPromiseLike(coreConfig.endpointUrl)) {
                        _self.pause();
                      } else if (!!_paused) {
                        _self.resume();
                      }
                      _setAutoLimits();
                      _overrideInstrumentationKey = _postConfig[_DYN_OVERRIDE_INSTRUMENTA16];
                      _disableTelemetry = !!_postConfig.disableTelemetry;
                      if (_unloadHandlersAdded) {
                        _removeUnloadHandlers();
                      }
                      var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];
                      _unloadHandlersAdded = addPageUnloadEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);
                      _unloadHandlersAdded = addPageHideEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace) || _unloadHandlersAdded;
                      _unloadHandlersAdded = addPageShowEventListener(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace) || _unloadHandlersAdded;
                    }));
                    _httpManager[_DYN_INITIALIZE](theConfig, _self.core, _self);
                  } catch (e) {
                    _self.setInitialized(false);
                    throw e;
                  }
                }, function() {
                  return { theConfig, core, extensions: extensions3 };
                });
              };
              _self.processTelemetry = function(ev, itemCtx) {
                setProcessTelemetryTimings(ev, _self[_DYN_IDENTIFIER]);
                itemCtx = itemCtx || _self._getTelCtx(itemCtx);
                var event = ev;
                if (!_disableTelemetry && !_isTeardownCalled) {
                  if (_overrideInstrumentationKey) {
                    event[_DYN_I_KEY] = _overrideInstrumentationKey;
                  }
                  _addEventToQueues(event, true);
                  if (_isPageUnloadTriggered) {
                    _releaseAllQueues(2, 2);
                  } else {
                    _scheduleTimer();
                  }
                }
                _self.processNext(event, itemCtx);
              };
              _self.getOfflineSupport = function() {
                try {
                  var details_1 = _httpManager && _httpManager[_DYN_GET_OFFLINE_REQUEST_9]();
                  if (_httpManager) {
                    return {
                      getUrl: function() {
                        if (details_1) {
                          return details_1.url;
                        }
                        return null;
                      },
                      serialize: _serialize,
                      batch: _batch,
                      shouldProcess: function(evt) {
                        return !_disableTelemetry;
                      },
                      createPayload: function(evt) {
                        return null;
                      },
                      createOneDSPayload: function(evts) {
                        if (_httpManager[_DYN_CREATE_ONE_DSPAYLOAD]) {
                          return _httpManager[_DYN_CREATE_ONE_DSPAYLOAD](evts, _optimizeObject);
                        }
                      }
                    };
                  }
                } catch (e) {
                }
                return null;
              };
              _self._doTeardown = function(unloadCtx, unloadState) {
                _releaseAllQueues(2, 2);
                _isTeardownCalled = true;
                _httpManager.teardown();
                _removeUnloadHandlers();
                _initDefaults();
              };
              function _removeUnloadHandlers() {
                removePageUnloadEventListener(null, _evtNamespace);
                removePageHideEventListener(null, _evtNamespace);
                removePageShowEventListener(null, _evtNamespace);
              }
              function _hookWParam(core) {
                var existingGetWParamMethod = core[_DYN_GET_WPARAM];
                core[_DYN_GET_WPARAM] = function() {
                  var wparam = 0;
                  if (_ignoreMc1Ms0CookieProcessing) {
                    wparam = wparam | 2;
                  }
                  return wparam | existingGetWParamMethod.call(core);
                };
              }
              function _batch(arr) {
                var rlt = EMPTY_STR;
                if (arr && arr[_DYN_LENGTH]) {
                  arrForEach(arr, function(item) {
                    if (rlt) {
                      rlt += "\n";
                    }
                    rlt += item;
                  });
                }
                return rlt;
              }
              function _serialize(event) {
                var rlt = EMPTY_STR;
                try {
                  _cleanEvent(event);
                  rlt = _httpManager[_DYN_SERIALIZE_OFFLINE_EV8](event);
                } catch (e) {
                }
                return rlt;
              }
              function _handleUnloadEvents(evt) {
                var theEvt = evt || getWindow().event;
                if (theEvt.type !== "beforeunload") {
                  _isPageUnloadTriggered = true;
                  _httpManager[_DYN_SET_UNLOADING](_isPageUnloadTriggered);
                }
                _releaseAllQueues(2, 2);
              }
              function _handleShowEvents(evt) {
                _isPageUnloadTriggered = false;
                _httpManager[_DYN_SET_UNLOADING](_isPageUnloadTriggered);
              }
              function _cleanEvent(event) {
                if (event.ext && event.ext[STR_TRACE]) {
                  delete event.ext[STR_TRACE];
                }
                if (event.ext && event.ext[STR_USER] && event.ext[STR_USER]["id"]) {
                  delete event.ext[STR_USER]["id"];
                }
                if (_optimizeObject) {
                  event.ext = optimizeObject(event.ext);
                  if (event.baseData) {
                    event.baseData = optimizeObject(event.baseData);
                  }
                  if (event.data) {
                    event.data = optimizeObject(event.data);
                  }
                }
              }
              function _addEventToQueues(event, append) {
                if (!event[_DYN_SEND_ATTEMPT]) {
                  event[_DYN_SEND_ATTEMPT] = 0;
                }
                if (!event[_DYN_LATENCY]) {
                  event[_DYN_LATENCY] = 1;
                }
                _cleanEvent(event);
                if (event[_DYN_SYNC]) {
                  if (_currentBackoffCount || _paused) {
                    event[_DYN_LATENCY] = 3;
                    event[_DYN_SYNC] = false;
                  } else {
                    if (_httpManager) {
                      if (_optimizeObject) {
                        event = optimizeObject(event);
                      }
                      _httpManager[_DYN_SEND_SYNCHRONOUS_BAT10](EventBatch.create(event[_DYN_I_KEY], [event]), event[_DYN_SYNC] === true ? 1 : event[_DYN_SYNC], 3);
                      return;
                    }
                  }
                }
                var evtLatency = event[_DYN_LATENCY];
                var queueSize = _queueSize;
                var queueLimit = _queueSizeLimit;
                if (evtLatency === 4) {
                  queueSize = _immediateQueueSize;
                  queueLimit = _immediateQueueSizeLimit;
                }
                var eventDropped = false;
                if (queueSize < queueLimit) {
                  eventDropped = !_addEventToProperQueue(event, append);
                } else {
                  var dropLatency = 1;
                  var dropNumber = EventsDroppedAtOneTime;
                  if (evtLatency === 4) {
                    dropLatency = 4;
                    dropNumber = 1;
                  }
                  eventDropped = true;
                  if (_dropEventWithLatencyOrLess(event[_DYN_I_KEY], event[_DYN_LATENCY], dropLatency, dropNumber)) {
                    eventDropped = !_addEventToProperQueue(event, append);
                  }
                }
                if (eventDropped) {
                  _notifyEvents(strEventsDiscarded, [event], EventsDiscardedReason.QueueFull);
                }
              }
              _self.setEventQueueLimits = function(eventLimit, autoFlushLimit) {
                _postConfig.eventsLimitInMem = _queueSizeLimit = isGreaterThanZero(eventLimit) ? eventLimit : MaxEventsLimitInMem;
                _postConfig[_DYN_AUTO_FLUSH_EVENTS_LI14] = _autoFlushEventsLimit = isGreaterThanZero(autoFlushLimit) ? autoFlushLimit : 0;
                _setAutoLimits();
                var doFlush = _queueSize > eventLimit;
                if (!doFlush && _autoFlushBatchLimit > 0) {
                  for (var latency = 1; !doFlush && latency <= 3; latency++) {
                    var batchQueue = _batchQueues[latency];
                    if (batchQueue && batchQueue[_DYN_BATCHES]) {
                      arrForEach(batchQueue[_DYN_BATCHES], function(theBatch) {
                        if (theBatch && theBatch[_DYN_COUNT]() >= _autoFlushBatchLimit) {
                          doFlush = true;
                        }
                      });
                    }
                  }
                }
                _performAutoFlush(true, doFlush);
              };
              _self.pause = function() {
                _clearScheduledTimer();
                _paused = true;
                _httpManager && _httpManager.pause();
              };
              _self.resume = function() {
                _paused = false;
                _httpManager && _httpManager.resume();
                _scheduleTimer();
              };
              _self._loadTransmitProfiles = function(profiles) {
                _resetTransmitProfiles();
                objForEachKey(profiles, function(profileName, profileValue) {
                  var profLen = profileValue[_DYN_LENGTH];
                  if (profLen >= 2) {
                    var directValue = profLen > 2 ? profileValue[2] : 0;
                    profileValue.splice(0, profLen - 2);
                    if (profileValue[1] < 0) {
                      profileValue[0] = -1;
                    }
                    if (profileValue[1] > 0 && profileValue[0] > 0) {
                      var timerMultiplier = profileValue[0] / profileValue[1];
                      profileValue[0] = mathCeil(timerMultiplier) * profileValue[1];
                    }
                    if (directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1]) {
                      directValue = profileValue[1];
                    }
                    profileValue[_DYN_PUSH](directValue);
                    _profiles[profileName] = profileValue;
                  }
                });
              };
              _self.flush = function(async, callback, sendReason) {
                if (async === void 0) {
                  async = true;
                }
                var result;
                if (!_paused) {
                  sendReason = sendReason || 1;
                  if (async) {
                    if (!callback) {
                      result = createPromise(function(resolve3) {
                        callback = resolve3;
                      });
                    }
                    if (_flushCallbackTimer == null) {
                      _clearScheduledTimer();
                      _queueBatches(1, 0, sendReason);
                      _flushCallbackTimer = _createTimer(function() {
                        _flushCallbackTimer = null;
                        _flushImpl(callback, sendReason);
                      }, 0);
                    } else {
                      _flushCallbackQueue[_DYN_PUSH](callback);
                    }
                  } else {
                    var cleared = _clearScheduledTimer();
                    _sendEventsForLatencyAndAbove(1, 1, sendReason);
                    callback && callback();
                    if (cleared) {
                      _scheduleTimer();
                    }
                  }
                }
                return result;
              };
              _self.setMsaAuthTicket = function(ticket) {
                _httpManager.addHeader(STR_MSA_DEVICE_TICKET, ticket);
              };
              _self.setAuthPluginHeader = function(token) {
                _httpManager.addHeader(STR_AUTH_WEB_TOKEN, token);
              };
              _self.removeAuthPluginHeader = function() {
                _httpManager.removeHeader(STR_AUTH_WEB_TOKEN);
              };
              _self.hasEvents = _hasEvents;
              _self._setTransmitProfile = function(profileName) {
                if (_currentProfile !== profileName && _profiles[profileName] !== void 0) {
                  _clearScheduledTimer();
                  _currentProfile = profileName;
                  _scheduleTimer();
                }
              };
              proxyFunctions(_self, function() {
                return _httpManager;
              }, ["addResponseHandler"]);
              function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {
                var queued = _queueBatches(latency, sendType, sendReason);
                _httpManager[_DYN_SEND_QUEUED_REQUESTS](sendType, sendReason);
                return queued;
              }
              function _hasEvents() {
                return _queueSize > 0;
              }
              function _scheduleTimer() {
                if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0, _delayedBatchReason)) {
                  _httpManager[_DYN_SEND_QUEUED_REQUESTS](0, _delayedBatchReason);
                }
                if (_immediateQueueSize > 0 && !_immediateTimer && !_paused) {
                  var immediateTimeOut = _profiles[_currentProfile][2];
                  if (immediateTimeOut >= 0) {
                    _immediateTimer = _createTimer(function() {
                      _immediateTimer = null;
                      _sendEventsForLatencyAndAbove(4, 0, 1);
                      _scheduleTimer();
                    }, immediateTimeOut);
                  }
                }
                var timeOut = _profiles[_currentProfile][1];
                if (!_scheduledTimer && !_flushCallbackTimer && timeOut >= 0 && !_paused) {
                  if (_hasEvents()) {
                    _scheduledTimer = _createTimer(function() {
                      _scheduledTimer = null;
                      _sendEventsForLatencyAndAbove(_timerCount === 0 ? 3 : 1, 0, 1);
                      _timerCount++;
                      _timerCount %= 2;
                      _scheduleTimer();
                    }, timeOut);
                  } else {
                    _timerCount = 0;
                  }
                }
              }
              _self[_DYN__BACK_OFF_TRANSMISSI12] = function() {
                if (_currentBackoffCount < MaxBackoffCount) {
                  _currentBackoffCount++;
                  _clearScheduledTimer();
                  _scheduleTimer();
                }
              };
              _self._clearBackOff = function() {
                if (_currentBackoffCount) {
                  _currentBackoffCount = 0;
                  _clearScheduledTimer();
                  _scheduleTimer();
                }
              };
              function _initDefaults() {
                _postConfig = null;
                _isTeardownCalled = false;
                _flushCallbackQueue = [];
                _flushCallbackTimer = null;
                _paused = false;
                _immediateQueueSize = 0;
                _immediateQueueSizeLimit = 500;
                _queueSize = 0;
                _queueSizeLimit = MaxEventsLimitInMem;
                _profiles = {};
                _currentProfile = RT_PROFILE;
                _scheduledTimer = null;
                _immediateTimer = null;
                _currentBackoffCount = 0;
                _timerCount = 0;
                _batchQueues = {};
                _autoFlushEventsLimit = 0;
                _unloadHandlersAdded = false;
                _autoFlushBatchLimit = 0;
                _delayedBatchSendLatency = -1;
                _delayedBatchReason = null;
                _optimizeObject = true;
                _isPageUnloadTriggered = false;
                _maxEventSendAttempts = MaxSendAttempts;
                _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;
                _evtNamespace = null;
                _overrideInstrumentationKey = null;
                _maxEvtPerBatch = null;
                _disableTelemetry = false;
                _timeoutWrapper = createTimeoutWrapper();
                _httpManager = new HttpManager(MaxNumberEventPerBatch, MaxConnections, MaxRequestRetriesBeforeBackoff, {
                  requeue: _requeueEvents,
                  send: _sendingEvent,
                  sent: _eventsSentEvent,
                  drop: _eventsDropped,
                  rspFail: _eventsResponseFail,
                  oth: _otherEvent
                });
                _initializeProfiles();
                _clearQueues();
                _setAutoLimits();
              }
              function _createTimer(theTimerFunc, timeOut) {
                if (timeOut === 0 && _currentBackoffCount) {
                  timeOut = 1;
                }
                var timerMultiplier = 1e3;
                if (_currentBackoffCount) {
                  timerMultiplier = retryPolicyGetMillisToBackoffForRetry(_currentBackoffCount - 1);
                }
                return _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);
              }
              function _clearScheduledTimer() {
                if (_scheduledTimer !== null) {
                  _scheduledTimer.cancel();
                  _scheduledTimer = null;
                  _timerCount = 0;
                  return true;
                }
                return false;
              }
              function _releaseAllQueues(sendType, sendReason) {
                _clearScheduledTimer();
                if (_flushCallbackTimer) {
                  _flushCallbackTimer.cancel();
                  _flushCallbackTimer = null;
                }
                if (!_paused) {
                  _sendEventsForLatencyAndAbove(1, sendType, sendReason);
                }
              }
              function _clearQueues() {
                _batchQueues[4] = {
                  batches: [],
                  iKeyMap: {}
                };
                _batchQueues[3] = {
                  batches: [],
                  iKeyMap: {}
                };
                _batchQueues[2] = {
                  batches: [],
                  iKeyMap: {}
                };
                _batchQueues[1] = {
                  batches: [],
                  iKeyMap: {}
                };
              }
              function _getEventBatch(iKey, latency, create) {
                var batchQueue = _batchQueues[latency];
                if (!batchQueue) {
                  latency = 1;
                  batchQueue = _batchQueues[latency];
                }
                var eventBatch = batchQueue.iKeyMap[iKey];
                if (!eventBatch && create) {
                  eventBatch = EventBatch.create(iKey);
                  batchQueue.batches[_DYN_PUSH](eventBatch);
                  batchQueue.iKeyMap[iKey] = eventBatch;
                }
                return eventBatch;
              }
              function _performAutoFlush(isAsync, doFlush) {
                if (_httpManager[_DYN_CAN_SEND_REQUEST]() && !_currentBackoffCount) {
                  if (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit) {
                    doFlush = true;
                  }
                  if (doFlush && _flushCallbackTimer == null) {
                    _self.flush(isAsync, function() {
                    }, 20);
                  }
                }
              }
              function _addEventToProperQueue(event, append) {
                if (_optimizeObject) {
                  event = optimizeObject(event);
                }
                var latency = event[_DYN_LATENCY];
                var eventBatch = _getEventBatch(event[_DYN_I_KEY], latency, true);
                if (eventBatch.addEvent(event)) {
                  if (latency !== 4) {
                    _queueSize++;
                    if (append && event[_DYN_SEND_ATTEMPT] === 0) {
                      _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch[_DYN_COUNT]() >= _autoFlushBatchLimit);
                    }
                  } else {
                    _immediateQueueSize++;
                  }
                  return true;
                }
                return false;
              }
              function _dropEventWithLatencyOrLess(iKey, latency, currentLatency, dropNumber) {
                while (currentLatency <= latency) {
                  var eventBatch = _getEventBatch(iKey, latency, true);
                  if (eventBatch && eventBatch[_DYN_COUNT]() > 0) {
                    var droppedEvents = eventBatch[_DYN_SPLIT](0, dropNumber);
                    var droppedCount = droppedEvents[_DYN_COUNT]();
                    if (droppedCount > 0) {
                      if (currentLatency === 4) {
                        _immediateQueueSize -= droppedCount;
                      } else {
                        _queueSize -= droppedCount;
                      }
                      _notifyBatchEvents(strEventsDiscarded, [droppedEvents], EventsDiscardedReason.QueueFull);
                      return true;
                    }
                  }
                  currentLatency++;
                }
                _resetQueueCounts();
                return false;
              }
              function _resetQueueCounts() {
                var immediateQueue = 0;
                var normalQueue = 0;
                var _loop_1 = function(latency2) {
                  var batchQueue = _batchQueues[latency2];
                  if (batchQueue && batchQueue[_DYN_BATCHES]) {
                    arrForEach(batchQueue[_DYN_BATCHES], function(theBatch) {
                      if (latency2 === 4) {
                        immediateQueue += theBatch[_DYN_COUNT]();
                      } else {
                        normalQueue += theBatch[_DYN_COUNT]();
                      }
                    });
                  }
                };
                for (var latency = 1; latency <= 4; latency++) {
                  _loop_1(latency);
                }
                _queueSize = normalQueue;
                _immediateQueueSize = immediateQueue;
              }
              function _queueBatches(latency, sendType, sendReason) {
                var eventsQueued = false;
                var isAsync = sendType === 0;
                if (!isAsync || _httpManager[_DYN_CAN_SEND_REQUEST]()) {
                  doPerf(_self.core, function() {
                    return "PostChannel._queueBatches";
                  }, function() {
                    var droppedEvents = [];
                    var latencyToProcess = 4;
                    while (latencyToProcess >= latency) {
                      var batchQueue = _batchQueues[latencyToProcess];
                      if (batchQueue && batchQueue.batches && batchQueue.batches[_DYN_LENGTH] > 0) {
                        arrForEach(batchQueue[_DYN_BATCHES], function(theBatch) {
                          if (!_httpManager.addBatch(theBatch)) {
                            droppedEvents = droppedEvents[_DYN_CONCAT](theBatch[_DYN_EVENTS]());
                          } else {
                            eventsQueued = eventsQueued || theBatch && theBatch[_DYN_COUNT]() > 0;
                          }
                          if (latencyToProcess === 4) {
                            _immediateQueueSize -= theBatch[_DYN_COUNT]();
                          } else {
                            _queueSize -= theBatch[_DYN_COUNT]();
                          }
                        });
                        batchQueue[_DYN_BATCHES] = [];
                        batchQueue.iKeyMap = {};
                      }
                      latencyToProcess--;
                    }
                    if (droppedEvents[_DYN_LENGTH] > 0) {
                      _notifyEvents(strEventsDiscarded, droppedEvents, EventsDiscardedReason.KillSwitch);
                    }
                    if (eventsQueued && _delayedBatchSendLatency >= latency) {
                      _delayedBatchSendLatency = -1;
                      _delayedBatchReason = 0;
                    }
                  }, function() {
                    return { latency, sendType, sendReason };
                  }, !isAsync);
                } else {
                  _delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? mathMin(_delayedBatchSendLatency, latency) : latency;
                  _delayedBatchReason = mathMax(_delayedBatchReason, sendReason);
                }
                return eventsQueued;
              }
              function _flushImpl(callback, sendReason) {
                _sendEventsForLatencyAndAbove(1, 0, sendReason);
                _resetQueueCounts();
                _waitForIdleManager(function() {
                  if (callback) {
                    callback();
                  }
                  if (_flushCallbackQueue[_DYN_LENGTH] > 0) {
                    _flushCallbackTimer = _createTimer(function() {
                      _flushCallbackTimer = null;
                      _flushImpl(_flushCallbackQueue.shift(), sendReason);
                    }, 0);
                  } else {
                    _flushCallbackTimer = null;
                    _scheduleTimer();
                  }
                });
              }
              function _waitForIdleManager(callback) {
                if (_httpManager.isCompletelyIdle()) {
                  callback();
                } else {
                  _flushCallbackTimer = _createTimer(function() {
                    _flushCallbackTimer = null;
                    _waitForIdleManager(callback);
                  }, FlushCheckTimer);
                }
              }
              function _resetTransmitProfiles() {
                _clearScheduledTimer();
                _initializeProfiles();
                _currentProfile = RT_PROFILE;
                _scheduleTimer();
              }
              function _initializeProfiles() {
                _profiles = {};
                _profiles[RT_PROFILE] = [2, 1, 0];
                _profiles[NRT_PROFILE] = [6, 3, 0];
                _profiles[BE_PROFILE] = [18, 9, 0];
              }
              function _requeueEvents(batches, reason) {
                var droppedEvents = [];
                var maxSendAttempts = _maxEventSendAttempts;
                if (_isPageUnloadTriggered) {
                  maxSendAttempts = _maxUnloadEventSendAttempts;
                }
                arrForEach(batches, function(theBatch) {
                  if (theBatch && theBatch[_DYN_COUNT]() > 0) {
                    arrForEach(theBatch[_DYN_EVENTS](), function(theEvent) {
                      if (theEvent) {
                        if (theEvent[_DYN_SYNC]) {
                          theEvent[_DYN_LATENCY] = 4;
                          theEvent[_DYN_SYNC] = false;
                        }
                        if (theEvent[_DYN_SEND_ATTEMPT] < maxSendAttempts) {
                          setProcessTelemetryTimings(theEvent, _self[_DYN_IDENTIFIER]);
                          _addEventToQueues(theEvent, false);
                        } else {
                          droppedEvents[_DYN_PUSH](theEvent);
                        }
                      }
                    });
                  }
                });
                if (droppedEvents[_DYN_LENGTH] > 0) {
                  _notifyEvents(strEventsDiscarded, droppedEvents, EventsDiscardedReason.NonRetryableStatus);
                }
                if (_isPageUnloadTriggered) {
                  _releaseAllQueues(2, 2);
                }
              }
              function _callNotification(evtName, theArgs) {
                var manager = _notificationManager || {};
                var notifyFunc = manager[evtName];
                if (notifyFunc) {
                  try {
                    notifyFunc.apply(manager, theArgs);
                  } catch (e) {
                    _throwInternal(_self.diagLog(), 1, 74, evtName + " notification failed: " + e);
                  }
                }
              }
              function _notifyEvents(evtName, theEvents) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                  extraArgs[_i - 2] = arguments[_i];
                }
                if (theEvents && theEvents[_DYN_LENGTH] > 0) {
                  _callNotification(evtName, [theEvents][_DYN_CONCAT](extraArgs));
                }
              }
              function _notifyBatchEvents(evtName, batches) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                  extraArgs[_i - 2] = arguments[_i];
                }
                if (batches && batches[_DYN_LENGTH] > 0) {
                  arrForEach(batches, function(theBatch) {
                    if (theBatch && theBatch[_DYN_COUNT]() > 0) {
                      _callNotification(evtName, [theBatch.events()][_DYN_CONCAT](extraArgs));
                    }
                  });
                }
              }
              function _sendingEvent(batches, reason, isSyncRequest) {
                if (batches && batches[_DYN_LENGTH] > 0) {
                  _callNotification("eventsSendRequest", [reason >= 1e3 && reason <= 1999 ? reason - 1e3 : 0, isSyncRequest !== true]);
                }
              }
              function _eventsSentEvent(batches, reason) {
                _notifyBatchEvents("eventsSent", batches, reason);
                _scheduleTimer();
              }
              function _eventsDropped(batches, reason) {
                _notifyBatchEvents(strEventsDiscarded, batches, reason >= 8e3 && reason <= 8999 ? reason - 8e3 : EventsDiscardedReason.Unknown);
              }
              function _eventsResponseFail(batches) {
                _notifyBatchEvents(strEventsDiscarded, batches, EventsDiscardedReason.NonRetryableStatus);
                _scheduleTimer();
              }
              function _otherEvent(batches, reason) {
                _notifyBatchEvents(strEventsDiscarded, batches, EventsDiscardedReason.Unknown);
                _scheduleTimer();
              }
              function _setAutoLimits() {
                if (!_disableAutoBatchFlushLimit) {
                  _autoFlushBatchLimit = mathMax(_maxEvtPerBatch * (MaxConnections + 1), _queueSizeLimit / 6);
                } else {
                  _autoFlushBatchLimit = 0;
                }
              }
            });
            return _this;
          }
          PostChannel2.__ieDyn = 1;
          return PostChannel2;
        }(BaseTelemetryPlugin)
      );
      exports3.BE_PROFILE = BE_PROFILE;
      exports3.NRT_PROFILE = NRT_PROFILE;
      exports3.PostChannel = PostChannel;
      exports3.RT_PROFILE = RT_PROFILE;
    });
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/1dsClientFactory.js
var require_dsClientFactory = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/1dsClientFactory.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.oneDataSystemClientFactory = void 0;
    var getAICore = async (key, vscodeAPI, xhrOverride) => {
      const oneDs = await Promise.resolve().then(() => __importStar(require_ms_core()));
      const postPlugin = await Promise.resolve().then(() => __importStar(require_ms_post()));
      const appInsightsCore = new oneDs.AppInsightsCore();
      const collectorChannelPlugin = new postPlugin.PostChannel();
      const coreConfig = {
        instrumentationKey: key,
        endpointUrl: "https://mobile.events.data.microsoft.com/OneCollector/1.0",
        loggingLevelTelemetry: 0,
        loggingLevelConsole: 0,
        disableCookiesUsage: true,
        disableDbgExt: true,
        disableInstrumentationKeyValidation: true,
        channels: [[
          collectorChannelPlugin
        ]]
      };
      if (xhrOverride) {
        coreConfig.extensionConfig = {};
        const channelConfig = {
          alwaysUseXhrOverride: true,
          httpXHROverride: xhrOverride
        };
        coreConfig.extensionConfig[collectorChannelPlugin.identifier] = channelConfig;
      }
      const config = vscodeAPI.workspace.getConfiguration("telemetry");
      const internalTesting = config.get("internalTesting");
      appInsightsCore.initialize(coreConfig, []);
      appInsightsCore.addTelemetryInitializer((envelope) => {
        envelope["ext"] = envelope["ext"] ?? {};
        envelope["ext"]["web"] = envelope["ext"]["web"] ?? {};
        envelope["ext"]["web"]["consentDetails"] = '{"GPC_DataSharingOptIn":false}';
        if (!internalTesting) {
          return;
        }
        envelope["ext"]["utc"] = envelope["ext"]["utc"] ?? {};
        envelope["ext"]["utc"]["flags"] = 8462029;
      });
      return appInsightsCore;
    };
    var oneDataSystemClientFactory = async (key, vscodeAPI, xhrOverride) => {
      let appInsightsCore = await getAICore(key, vscodeAPI, xhrOverride);
      const flushOneDS = async () => {
        try {
          const flushPromise = new Promise((resolve3, reject) => {
            if (!appInsightsCore) {
              resolve3();
              return;
            }
            appInsightsCore.flush(true, (completedFlush) => {
              if (!completedFlush) {
                reject("Failed to flush app 1DS!");
                return;
              }
            });
          });
          return flushPromise;
        } catch (e) {
          throw new Error("Failed to flush 1DS!\n" + e.message);
        }
      };
      const telemetryClient = {
        logEvent: (eventName, data) => {
          try {
            appInsightsCore?.track({
              name: eventName,
              baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
            });
          } catch (e) {
            throw new Error("Failed to log event to app insights!\n" + e.message);
          }
        },
        flush: flushOneDS,
        dispose: async () => {
          const disposePromise = new Promise((resolve3) => {
            if (!appInsightsCore) {
              resolve3();
              return;
            }
            appInsightsCore.unload(false, () => {
              resolve3();
              appInsightsCore = void 0;
              return;
            }, 1e3);
          });
          return disposePromise;
        }
      };
      return telemetryClient;
    };
    exports2.oneDataSystemClientFactory = oneDataSystemClientFactory;
  }
});

// node_modules/@microsoft/applicationinsights-common/dist/es5/applicationinsights-common.js
var require_applicationinsights_common = __commonJS({
  "node_modules/@microsoft/applicationinsights-common/dist/es5/applicationinsights-common.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory((global2.Microsoft = global2.Microsoft || {}, global2.Microsoft.ApplicationInsights = global2.Microsoft.ApplicationInsights || {})));
    })(exports2, function(exports3) {
      "use strict";
      // @__NO_SIDE_EFFECTS__
      function _pureAssign(func1, func2) {
        return func1 || func2;
      }
      // @__NO_SIDE_EFFECTS__
      function _pureRef(value, name) {
        return value[name];
      }
      var UNDEF_VALUE = void 0;
      var NULL_VALUE = null;
      var EMPTY = "";
      var FUNCTION = "function";
      var OBJECT = "object";
      var PROTOTYPE = "prototype";
      var __PROTO__ = "__proto__";
      var UNDEFINED = "undefined";
      var CONSTRUCTOR = "constructor";
      var SYMBOL = "Symbol";
      var LENGTH = "length";
      var NAME = "name";
      var CALL = "call";
      var TO_STRING = "toString";
      var GET_OWN_PROPERTY_DESCRIPTOR = "getOwnPropertyDescriptor";
      var ObjClass$1 = /* @__PURE__ */ _pureAssign(Object);
      var ObjProto$1 = /* @__PURE__ */ _pureRef(ObjClass$1, PROTOTYPE);
      var StrCls = /* @__PURE__ */ _pureAssign(String);
      var StrProto = /* @__PURE__ */ _pureRef(StrCls, PROTOTYPE);
      var MathCls = /* @__PURE__ */ _pureAssign(Math);
      var ArrCls = /* @__PURE__ */ _pureAssign(Array);
      var ArrProto = /* @__PURE__ */ _pureRef(ArrCls, PROTOTYPE);
      var ArrSlice = /* @__PURE__ */ _pureRef(ArrProto, "slice");
      var POLYFILL_TAG = "_polyfill";
      var POLYFILL_TYPE_NAME = "__nw21$polytype__";
      function safe(func, argArray) {
        try {
          return {
            v: func.apply(this, argArray)
          };
        } catch (e) {
          return { e };
        }
      }
      // @__NO_SIDE_EFFECTS__
      function _createIs(theType) {
        return function(value) {
          return typeof value === theType;
        };
      }
      // @__NO_SIDE_EFFECTS__
      function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function(value) {
          return !!(value && /* @__PURE__ */ objToString(value) === theType);
        };
      }
      // @__NO_SIDE_EFFECTS__
      function objToString(value) {
        return ObjProto$1[TO_STRING].call(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictUndefined(arg) {
        return arg === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isNullOrUndefined(value) {
        return value === NULL_VALUE || /* @__PURE__ */ isUndefined(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || value === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
      }
      var isString = /* @__PURE__ */ _createIs("string");
      var isFunction = /* @__PURE__ */ _createIs(FUNCTION);
      // @__NO_SIDE_EFFECTS__
      function isObject(value) {
        if (!value && /* @__PURE__ */ isNullOrUndefined(value)) {
          return false;
        }
        return !!value && typeof value === OBJECT;
      }
      var isArray = /* @__PURE__ */ _pureRef(ArrCls, "isArray");
      var isError = /* @__PURE__ */ _createObjIs("Error");
      function _returnNothing() {
        return;
      }
      var asString = /* @__PURE__ */ _pureAssign(StrCls);
      var ERROR_TYPE = "[object Error]";
      // @__NO_SIDE_EFFECTS__
      function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto$1[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
          object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
          propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format === "number" ? format : 4 : UNDEF_VALUE);
          propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
        } catch (e) {
          propertyValueDump = " - " + /* @__PURE__ */ dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
      }
      function throwError(message) {
        throw new Error(message);
      }
      function throwTypeError(message) {
        throw new TypeError(message);
      }
      function _throwIfNullOrUndefined(obj) {
        if (/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          throwTypeError("Cannot convert undefined or null to object");
        }
      }
      function _throwIfNotString(value) {
        if (!isString(value)) {
          throwTypeError("'" + /* @__PURE__ */ dumpObj(value) + "' is not a string");
        }
      }
      // @__NO_SIDE_EFFECTS__
      function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto$1.hasOwnProperty[CALL](obj, prop);
      }
      var _objGetOwnPropertyDescriptor$2 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var objHasOwn = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "hasOwn"), polyObjHasOwn);
      // @__NO_SIDE_EFFECTS__
      function polyObjHasOwn(obj, prop) {
        _throwIfNullOrUndefined(obj);
        return /* @__PURE__ */ objHasOwnProperty(obj, prop) || !!_objGetOwnPropertyDescriptor$2(obj, prop);
      }
      function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && (/* @__PURE__ */ isObject(theObject) || isFunction(theObject))) {
          for (var prop in theObject) {
            if (objHasOwn(theObject, prop)) {
              if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                break;
              }
            }
          }
        }
      }
      function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
          var len = theArray[LENGTH] >>> 0;
          for (var idx = 0; idx < len; idx++) {
            if (idx in theArray) {
              if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                break;
              }
            }
          }
        }
      }
      var _unwrapFunction = _unwrapFunctionWithPoly;
      // @__NO_SIDE_EFFECTS__
      function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
        return function(thisArg) {
          var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
          if (theFunc || polyFunc) {
            var theArgs = arguments;
            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
          }
          throwTypeError('"' + asString(funcName) + '" not defined for ' + /* @__PURE__ */ dumpObj(thisArg));
        };
      }
      var _objGetOwnPropertyDescriptor$1 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
      };
      // @__NO_SIDE_EFFECTS__
      function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
          prop.get = function() {
            return value.l.v;
          };
          var desc = _objGetOwnPropertyDescriptor$1(value.l, "v");
          if (desc && desc.set) {
            prop.set = function(newValue) {
              value.l.v = newValue;
            };
          }
        }
        objForEachKey(value, function(key, value2) {
          prop[propMap[key]] = /* @__PURE__ */ isStrictUndefined(value2) ? prop[propMap[key]] : value2;
        });
        return prop;
      }
      var objDefineProp = /* @__PURE__ */ _pureRef(ObjClass$1, "defineProperty");
      var objDefineProperties = /* @__PURE__ */ _pureRef(ObjClass$1, "defineProperties");
      function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, /* @__PURE__ */ _createProp(propDesc));
      }
      // @__NO_SIDE_EFFECTS__
      function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
        var theMap = {};
        objForEachKey(values, function(key, value) {
          _assignMapValue(theMap, key, keyType ? value : key);
          _assignMapValue(theMap, value, valueType ? value : key);
        });
        return completeFn ? completeFn(theMap) : theMap;
      }
      function _assignMapValue(theMap, key, value, writable) {
        objDefineProp(theMap, key, {
          value,
          enumerable: true,
          writable: false
        });
      }
      var _objFreeze = /* @__PURE__ */ _pureRef(ObjClass$1, "freeze");
      function _doNothing(value) {
        return value;
      }
      // @__NO_SIDE_EFFECTS__
      function _getProto(value) {
        _throwIfNullOrUndefined(value);
        return value[__PROTO__] || NULL_VALUE;
      }
      var objAssign = /* @__PURE__ */ _pureRef(ObjClass$1, "assign");
      var objKeys = /* @__PURE__ */ _pureRef(ObjClass$1, "keys");
      var objFreeze = /* @__PURE__ */ _pureAssign(_objFreeze, _doNothing);
      var objGetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "getPrototypeOf"), _getProto);
      // @__NO_SIDE_EFFECTS__
      function createEnum(values) {
        return /* @__PURE__ */ _createKeyValueMap(values, 1, 0, objFreeze);
      }
      // @__NO_SIDE_EFFECTS__
      function createSimpleMap(values) {
        var mapClass = {};
        objForEachKey(values, function(key, value) {
          _assignMapValue(mapClass, key, value[1]);
          _assignMapValue(mapClass, value[0], value[1]);
        });
        return objFreeze(mapClass);
      }
      // @__NO_SIDE_EFFECTS__
      function createTypeMap(values) {
        return /* @__PURE__ */ createSimpleMap(values);
      }
      var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
      var _globalCfg;
      // @__NO_SIDE_EFFECTS__
      function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
          result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
          result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
          result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
          result = global;
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function _getGlobalConfig() {
        if (!_globalCfg) {
          var gbl = safe(_getGlobalValue).v || {};
          _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
      }
      var mathMin = /* @__PURE__ */ _pureRef(MathCls, "min");
      var mathMax = /* @__PURE__ */ _pureRef(MathCls, "max");
      var strSlice = /* @__PURE__ */ _unwrapFunction("slice", StrProto);
      var strSubstring = /* @__PURE__ */ _unwrapFunction("substring", StrProto);
      var strSubstr = /* @__PURE__ */ _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
      // @__NO_SIDE_EFFECTS__
      function polyStrSubstr(value, start, length) {
        _throwIfNullOrUndefined(value);
        if (length < 0) {
          return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
          start = mathMax(start + value[LENGTH], 0);
        }
        if (/* @__PURE__ */ isUndefined(length)) {
          return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
      }
      // @__NO_SIDE_EFFECTS__
      function strLeft(value, count) {
        return strSubstring(value, 0, count);
      }
      function _tagAsPolyfill(target, polyfillTypeName) {
        if (target) {
          safe(function() {
            target[POLYFILL_TAG] = true;
            target[POLYFILL_TYPE_NAME] = polyfillTypeName;
          });
          safe(objDefine, [target, POLYFILL_TAG, {
            v: true,
            w: false,
            e: false
          }]);
          safe(objDefine, [target, POLYFILL_TYPE_NAME, {
            v: polyfillTypeName,
            w: false,
            e: false
          }]);
        }
        return target;
      }
      var objCreate = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "create"), polyObjCreate);
      // @__NO_SIDE_EFFECTS__
      function polyObjCreate(obj, properties) {
        var newObj = null;
        function tempFunc() {
        }
        if (!/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          var type = typeof obj;
          if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + /* @__PURE__ */ dumpObj(obj));
          }
          tempFunc[PROTOTYPE] = obj;
          safe(function() {
            tempFunc[__PROTO__] = obj;
          });
          newObj = new tempFunc();
        } else {
          newObj = {};
        }
        if (properties) {
          safe(objDefineProperties, [newObj, properties]);
        }
        return newObj;
      }
      // @__NO_SIDE_EFFECTS__
      function utcNow() {
        return (Date.now || polyUtcNow)();
      }
      // @__NO_SIDE_EFFECTS__
      function polyUtcNow() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
      function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
      }
      var _globalLazyTestHooks;
      function _initTestHooks() {
        _globalLazyTestHooks = /* @__PURE__ */ _getGlobalConfig();
      }
      // @__NO_SIDE_EFFECTS__
      function getLazy(cb, argArray) {
        var lazyValue = {};
        !_globalLazyTestHooks && _initTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
          configurable: true,
          get: function() {
            var result = fnApply(cb, null, argArray);
            if (!_globalLazyTestHooks.lzy) {
              objDefineProp(lazyValue, "v", {
                value: result
              });
            }
            lazyValue.b = _globalLazyTestHooks.lzy;
            return result;
          }
        });
        return lazyValue;
      }
      var mathRandom = /* @__PURE__ */ _pureRef(MathCls, "random");
      var _uniqueInstanceId = /* @__PURE__ */ getLazy(function() {
        var value = (/* @__PURE__ */ utcNow()).toString(36).slice(2);
        while (value.length < 16) {
          value += mathRandom().toString(36).slice(2);
        }
        value = value.substring(0, 16);
        return value;
      });
      var UNIQUE_REGISTRY_ID = "_urid";
      var POLY_SYM = "$nw21sym";
      var _polySymbols;
      var _polyId = 0;
      // @__NO_SIDE_EFFECTS__
      function _globalSymbolRegistry() {
        if (!_polySymbols) {
          var gblCfg = /* @__PURE__ */ _getGlobalConfig();
          _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
      }
      // @__NO_SIDE_EFFECTS__
      function polyNewSymbol(description) {
        var uniqueId = "_" + _polyId++ + "_" + _uniqueInstanceId.v;
        var symString = SYMBOL + "(" + description + ")";
        function _setProp(name, value) {
          objDefine(theSymbol, name, {
            v: value,
            e: false,
            w: false
          });
        }
        var theSymbol = objCreate(null);
        _setProp("description", asString(description));
        _setProp(TO_STRING, function() {
          return symString + POLY_SYM + uniqueId;
        });
        _setProp("valueOf", function() {
          return theSymbol;
        });
        _setProp("v", symString);
        _setProp("_uid", uniqueId);
        return _tagAsPolyfill(theSymbol, "symbol");
      }
      // @__NO_SIDE_EFFECTS__
      function polySymbolFor(key) {
        var registry = /* @__PURE__ */ _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
          var newSymbol_1 = /* @__PURE__ */ polyNewSymbol(key);
          var regId_1 = objKeys(registry.s).length;
          newSymbol_1[UNIQUE_REGISTRY_ID] = function() {
            return regId_1 + "_" + newSymbol_1[TO_STRING]();
          };
          registry.k[key] = newSymbol_1;
          registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
      }
      // @__NO_SIDE_EFFECTS__
      function createCachedValue(value) {
        return objDefineProp({
          toJSON: function() {
            return value;
          }
        }, "v", { value });
      }
      var WINDOW = "window";
      var _cachedGlobal;
      function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function() {
          !_globalLazyTestHooks && _initTestHooks();
          if (!cachedValue || _globalLazyTestHooks.lzy) {
            cachedValue = /* @__PURE__ */ createCachedValue(safe(getFn, theArgs).v);
          }
          return cachedValue.v;
        };
      }
      function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        if (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) {
          _cachedGlobal = /* @__PURE__ */ createCachedValue(safe(_getGlobalValue).v || NULL_VALUE);
        }
        return _cachedGlobal.v;
      }
      // @__NO_SIDE_EFFECTS__
      function getInst(name, useCached) {
        var gbl;
        if (!_cachedGlobal || useCached === false) {
          gbl = getGlobal(useCached);
        } else {
          gbl = _cachedGlobal.v;
        }
        if (gbl && gbl[name]) {
          return gbl[name];
        }
        if (name === WINDOW) {
          try {
            return window;
          } catch (e) {
          }
        }
        return NULL_VALUE;
      }
      var getDocument = /* @__PURE__ */ _getGlobalInstFn(getInst, ["document"]);
      // @__NO_SIDE_EFFECTS__
      function hasWindow() {
        return !!/* @__PURE__ */ getWindow();
      }
      var getWindow = /* @__PURE__ */ _getGlobalInstFn(getInst, [WINDOW]);
      // @__NO_SIDE_EFFECTS__
      function hasNavigator() {
        return !!/* @__PURE__ */ getNavigator();
      }
      var getNavigator = /* @__PURE__ */ _getGlobalInstFn(getInst, ["navigator"]);
      var _symbol;
      var _symbolFor;
      // @__NO_SIDE_EFFECTS__
      function _initSymbol() {
        _symbol = /* @__PURE__ */ createCachedValue(safe(getInst, [SYMBOL]).v);
        return _symbol;
      }
      function _getSymbolKey(key) {
        var gblSym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return gblSym.v ? gblSym.v[key] : UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return sym.v ? sym.v(description) : !noPoly ? /* @__PURE__ */ polyNewSymbol(description) : NULL_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = (!_globalLazyTestHooks.lzy ? _symbolFor : 0) || /* @__PURE__ */ createCachedValue(safe(_getSymbolKey, ["for"]).v);
        return (_symbolFor.v || polySymbolFor)(key);
      }
      var arrIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", ArrProto);
      var arrMap = /* @__PURE__ */ _unwrapFunction("map", ArrProto);
      var arrReduce = /* @__PURE__ */ _unwrapFunction("reduce", ArrProto);
      var _isProtoArray;
      var objSetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "setPrototypeOf"), _polyObjSetPrototypeOf);
      function _polyObjSetPrototypeOf(obj, proto) {
        var _a2;
        !_isProtoArray && (_isProtoArray = /* @__PURE__ */ createCachedValue((_a2 = {}, _a2[__PROTO__] = [], _a2) instanceof Array));
        _isProtoArray.v ? obj[__PROTO__] = proto : objForEachKey(proto, function(key, value) {
          return obj[key] = value;
        });
        return obj;
      }
      // @__NO_SIDE_EFFECTS__
      function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
          this[CONSTRUCTOR] = d;
          safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
      }
      function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
      }
      // @__NO_SIDE_EFFECTS__
      function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return /* @__PURE__ */ _createCustomError(name, function() {
          var _this = this;
          var theArgs = arguments;
          try {
            safe(_setName, [theBaseClass, name]);
            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
            if (_self !== _this) {
              var orgProto = objGetPrototypeOf(_this);
              if (orgProto !== objGetPrototypeOf(_self)) {
                objSetPrototypeOf(_self, orgProto);
              }
            }
            captureFn && captureFn(_self, _this[CONSTRUCTOR]);
            constructCb && constructCb(_self, theArgs);
            return _self;
          } finally {
            safe(_setName, [theBaseClass, orgName]);
          }
        }, theBaseClass);
      }
      // @__NO_SIDE_EFFECTS__
      function _createTrimFn(exp) {
        return function _doTrim(value) {
          _throwIfNullOrUndefined(value);
          if (value && value.replace) {
            value = value.replace(exp, EMPTY);
          }
          return value;
        };
      }
      var polyStrTrim = /* @__PURE__ */ _createTrimFn(/^\s+|(?=\s)\s+$/g);
      var strTrim = /* @__PURE__ */ _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim);
      var mathFloor = /* @__PURE__ */ _pureRef(MathCls, "floor");
      var _fnToString;
      var _objCtrFnString;
      var _gblWindow;
      // @__NO_SIDE_EFFECTS__
      function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
          return false;
        }
        if (!_gblWindow) {
          _gblWindow = /* @__PURE__ */ hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
          if (!_objCtrFnString) {
            _fnToString = Function[PROTOTYPE][TO_STRING];
            _objCtrFnString = _fnToString[CALL](ObjClass$1);
          }
          try {
            var proto = objGetPrototypeOf(value);
            result = !proto;
            if (!result) {
              if (/* @__PURE__ */ objHasOwnProperty(proto, CONSTRUCTOR)) {
                proto = proto[CONSTRUCTOR];
              }
              result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);
            }
          } catch (ex) {
          }
        }
        return result;
      }
      var _perf;
      // @__NO_SIDE_EFFECTS__
      function getPerformance() {
        !_globalLazyTestHooks && _initTestHooks();
        if (!_perf || _globalLazyTestHooks.lzy) {
          _perf = /* @__PURE__ */ createCachedValue(safe(getInst, ["performance"]).v);
        }
        return _perf.v;
      }
      var mathRound = /* @__PURE__ */ _pureRef(MathCls, "round");
      var objGetOwnPropertyDescriptor = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var strEndsWith = /* @__PURE__ */ _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
      // @__NO_SIDE_EFFECTS__
      function polyStrEndsWith(value, searchString, length) {
        _throwIfNotString(value);
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var end = !/* @__PURE__ */ isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
        return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
      }
      var strIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", StrProto);
      var REF = "ref";
      var UNREF = "unref";
      var HAS_REF = "hasRef";
      var ENABLED = "enabled";
      // @__NO_SIDE_EFFECTS__
      function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
          ref = false;
          timerId && timerId[UNREF] && timerId[UNREF]();
          return theTimerHandler;
        }
        function _cancel() {
          timerId && cancelFn(timerId);
          timerId = NULL_VALUE;
        }
        function _refresh() {
          timerId = refreshFn(timerId);
          if (!ref) {
            _unref();
          }
          return theTimerHandler;
        }
        function _setEnabled(value) {
          !value && timerId && _cancel();
          value && !timerId && _refresh();
        }
        theTimerHandler = {
          cancel: _cancel,
          refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function() {
          if (timerId && timerId[HAS_REF]) {
            return timerId[HAS_REF]();
          }
          return ref;
        };
        theTimerHandler[REF] = function() {
          ref = true;
          timerId && timerId[REF] && timerId[REF]();
          return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
          get: function() {
            return !!timerId;
          },
          set: _setEnabled
        });
        return {
          h: theTimerHandler,
          dn: function() {
            timerId = NULL_VALUE;
          }
        };
      }
      var _setTimeoutFn;
      var _clearTimeoutFn;
      function _resolveTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _setTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 0 && isFunction(globalOverrides[0])) {
            result = globalOverrides[0];
          }
        }
        return result || setTimeout;
      }
      function _resolveClearTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _clearTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 1 && isFunction(globalOverrides[1])) {
            result = globalOverrides[1];
          }
        }
        return result || clearTimeout;
      }
      function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = _resolveTimeoutFn(len > 0 ? overrideFn[0] : !isArr ? overrideFn : UNDEF_VALUE);
        var clearFn = _resolveClearTimeoutFn(len > 1 ? overrideFn[1] : UNDEF_VALUE);
        var timerFn = theArgs[0];
        theArgs[0] = function() {
          handler.dn();
          fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = /* @__PURE__ */ _createTimerHandler(startTimer, function(timerId) {
          if (timerId) {
            if (timerId.refresh) {
              timerId.refresh();
              return timerId;
            }
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
          }
          return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function(timerId) {
          fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
      }
      function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
      }
      var createEnumStyle = createEnum;
      var createValueMap = createTypeMap;
      var _DYN_TO_LOWER_CASE$1 = "toLowerCase";
      var _DYN_LENGTH$1 = "length";
      var _DYN_WARN_TO_CONSOLE = "warnToConsole";
      var _DYN_THROW_INTERNAL = "throwInternal";
      var _DYN_WATCH = "watch";
      var _DYN_APPLY = "apply";
      var _DYN_PUSH = "push";
      var _DYN_SPLICE = "splice";
      var _DYN_LOGGER = "logger";
      var _DYN_CANCEL = "cancel";
      var _DYN_NAME$1 = "name";
      var _DYN_UNLOAD = "unload";
      var _DYN_VERSION = "version";
      var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
      var _DYN_MESSAGE_ID = "messageId";
      var _DYN_MESSAGE$1 = "message";
      var _DYN_DIAG_LOG = "diagLog";
      var _DYN_USER_AGENT = "userAgent";
      var _DYN_SPLIT$1 = "split";
      var _DYN_REPLACE = "replace";
      var _DYN_TYPE = "type";
      var _DYN_EVT_NAME = "evtName";
      var _DYN_INDEX_OF = "indexOf";
      var _DYN_TRACE_FLAGS = "traceFlags";
      var _DYN_GET_ATTRIBUTE = "getAttribute";
      var aggregationErrorType;
      function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
          aggregationErrorType = /* @__PURE__ */ createCustomError("AggregationError", function(self2, args) {
            if (args[_DYN_LENGTH$1] > 1) {
              self2.errors = args[1];
            }
          });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function(srcError, idx) {
          theMessage += "\n".concat(idx, " > ").concat(/* @__PURE__ */ dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
      }
      var strShimFunction = "function";
      var strShimObject = "object";
      var strShimUndefined = "undefined";
      var strShimPrototype = "prototype";
      var ObjClass = Object;
      var ObjProto = ObjClass[strShimPrototype];
      (getGlobal() || {})["Symbol"];
      (getGlobal() || {})["Reflect"];
      var strHasOwnProperty = "hasOwnProperty";
      var __objAssignFnImpl = function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) {
            if (ObjProto[strHasOwnProperty].call(s, p)) {
              t[p] = s[p];
            }
          }
        }
        return t;
      };
      var __assignFn = objAssign || __objAssignFnImpl;
      var extendStaticsFn = function(d, b) {
        extendStaticsFn = ObjClass["setPrototypeOf"] || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2[strHasOwnProperty](p)) {
              d2[p] = b2[p];
            }
          }
        };
        return extendStaticsFn(d, b);
      };
      function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
          throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
          this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
      }
      var _a$1;
      var Constructor = "constructor";
      var Prototype = "prototype";
      var strFunction = "function";
      var DynInstFuncTable = "_dynInstFuncs";
      var DynProxyTag = "_isDynProxy";
      var DynClassName = "_dynClass";
      var DynClassNamePrefix = "_dynCls$";
      var DynInstChkTag = "_dynInstChk";
      var DynAllowInstChkTag = DynInstChkTag;
      var DynProtoDefaultOptions = "_dfOpts";
      var UnknownValue = "_unknown_";
      var str__Proto = "__proto__";
      var DynProtoBaseProto = "_dyn" + str__Proto;
      var DynProtoGlobalSettings = "__dynProto$Gbl";
      var DynProtoCurrent = "_dynInstProto";
      var strUseBaseInst = "useBaseInst";
      var strSetInstFuncs = "setInstFuncs";
      var Obj = Object;
      var _objGetPrototypeOf = Obj["getPrototypeOf"];
      var _objGetOwnProps = Obj["getOwnPropertyNames"];
      var _gbl = getGlobal();
      var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$1 = {}, _a$1[strSetInstFuncs] = true, _a$1[strUseBaseInst] = true, _a$1),
        n: 1e3
      });
      function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
      }
      function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
      }
      function _getObjProto(target) {
        var newProto;
        if (target) {
          if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
          }
          var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
          newProto = target[DynProtoBaseProto] || curProto;
          if (!/* @__PURE__ */ objHasOwnProperty(target, DynProtoBaseProto)) {
            delete target[DynProtoCurrent];
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
          }
        }
        return newProto;
      }
      function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
          props = _objGetOwnProps(target);
        } else {
          for (var name_1 in target) {
            if (typeof name_1 === "string" && /* @__PURE__ */ objHasOwnProperty(target, name_1)) {
              props.push(name_1);
            }
          }
        }
        if (props && props.length > 0) {
          for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
          }
        }
      }
      function _isDynamicCandidate(target, funcName, skipOwn) {
        return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || /* @__PURE__ */ objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
      }
      function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
      }
      function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function(name) {
          if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
            instFuncs[name] = thisTarget[name];
          }
        });
        return instFuncs;
      }
      function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
          if (values[lp] === value) {
            return true;
          }
        }
        return false;
      }
      function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
          var theFunc = funcHost[funcName];
          if (theFunc[DynProxyTag] && useBaseInst) {
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
          }
          return function() {
            return theFunc.apply(target, arguments);
          };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function(name) {
          baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
          _forEachProp(baseProto, function(name) {
            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
              baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
            }
          });
          visited.push(baseProto);
          baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
      }
      function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && /* @__PURE__ */ objHasOwnProperty(proto, DynClassName)) {
          var instFuncTable = target[DynInstFuncTable] || objCreate(null);
          instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
          if (!instFunc) {
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
          }
          if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            var canAddInst = !/* @__PURE__ */ objHasOwnProperty(target, funcName);
            var objProto = _getObjProto(target);
            var visited = [];
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
              var protoFunc = objProto[funcName];
              if (protoFunc) {
                canAddInst = protoFunc === currentDynProtoProxy;
                break;
              }
              visited.push(objProto);
              objProto = _getObjProto(objProto);
            }
            try {
              if (canAddInst) {
                target[funcName] = instFunc;
              }
              instFunc[DynInstChkTag] = 1;
            } catch (e) {
              instFuncTable[DynAllowInstChkTag] = false;
            }
          }
        }
        return instFunc;
      }
      function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
          protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
          _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
      }
      function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto2, funcName) {
          var dynProtoProxy = function() {
            var instFunc = _getInstFunc(this, funcName, proto2, dynProtoProxy) || _getProtoFunc(funcName, proto2, dynProtoProxy);
            return instFunc.apply(this, arguments);
          };
          dynProtoProxy[DynProxyTag] = 1;
          return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
          var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
          if (!_isObjectOrArrayPrototype(instFuncTable)) {
            var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
            }
            if (!_isObjectOrArrayPrototype(instFuncs_1)) {
              _forEachProp(target, function(name) {
                if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                  instFuncs_1[name] = target[name];
                  delete target[name];
                  if (!/* @__PURE__ */ objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) {
                    proto[name] = _createDynamicPrototype(proto, name);
                  }
                }
              });
            }
          }
        }
      }
      function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
          var visited = [];
          var thisProto = _getObjProto(thisTarget);
          while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
              return true;
            }
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
          }
          return false;
        }
        return true;
      }
      function _getObjName(target, unknownValue) {
        if (/* @__PURE__ */ objHasOwnProperty(target, Prototype)) {
          return target.name || unknownValue || UnknownValue;
        }
        return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
      }
      function dynamicProto(theClass, target, delegateFunc, options) {
        if (!/* @__PURE__ */ objHasOwnProperty(theClass, Prototype)) {
          _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
          _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (/* @__PURE__ */ objHasOwnProperty(classProto, DynClassName)) {
          className = classProto[DynClassName];
        } else {
          className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
          _gblInst.n++;
          classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== void 0) {
          useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
          setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
      }
      dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
      var UNDEFINED_VALUE = void 0;
      var STR_EMPTY = "";
      var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";
      var rCamelCase = /-([a-z])/g;
      var rNormalizeInvalid = /([^\w\d_$])/g;
      var rLeadingNumeric = /^(\d+[\w\d_$])/;
      function isNotNullOrUndefined(value) {
        return !/* @__PURE__ */ isNullOrUndefined(value);
      }
      function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
          value = value[_DYN_REPLACE](rCamelCase, function(_all, letter) {
            return letter.toUpperCase();
          });
          value = value[_DYN_REPLACE](rNormalizeInvalid, "_");
          value = value[_DYN_REPLACE](rLeadingNumeric, function(_all, match) {
            return "_" + match;
          });
        }
        return value;
      }
      function strContains(value, search) {
        if (value && search) {
          return strIndexOf(value, search) !== -1;
        }
        return false;
      }
      function toISOString(date) {
        return date && date.toISOString() || "";
      }
      function getExceptionName(object) {
        if (isError(object)) {
          return object[_DYN_NAME$1];
        }
        return STR_EMPTY;
      }
      function createClassFromInterface(defaults) {
        return (
          /** @class */
          /* @__PURE__ */ function() {
            function class_1() {
              var _this = this;
              if (defaults) {
                objForEachKey(defaults, function(field, value) {
                  _this[field] = value;
                });
              }
            }
            return class_1;
          }()
        );
      }
      var strConsole = "console";
      var strJSON = "JSON";
      var strCrypto = "crypto";
      var strMsCrypto = "msCrypto";
      var strMsie = "msie";
      var strTrident = "trident/";
      var _isTrident = null;
      var _navUserAgentCheck = null;
      var _beaconsSupported = null;
      function getConsole() {
        if (typeof console !== strShimUndefined) {
          return console;
        }
        return /* @__PURE__ */ getInst(strConsole);
      }
      function hasJSON() {
        return Boolean(typeof JSON === strShimObject && JSON || /* @__PURE__ */ getInst(strJSON) !== null);
      }
      function getJSON() {
        if (hasJSON()) {
          return JSON || /* @__PURE__ */ getInst(strJSON);
        }
        return null;
      }
      function getCrypto() {
        return /* @__PURE__ */ getInst(strCrypto);
      }
      function getMsCrypto() {
        return /* @__PURE__ */ getInst(strMsCrypto);
      }
      function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
          _navUserAgentCheck = nav[_DYN_USER_AGENT];
          var userAgent = (_navUserAgentCheck || STR_EMPTY)[_DYN_TO_LOWER_CASE$1]();
          _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
        }
        return _isTrident;
      }
      function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
          _beaconsSupported = /* @__PURE__ */ hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
      }
      function _getNamedValue(values, name) {
        if (values) {
          for (var i = 0; i < values[_DYN_LENGTH$1]; i++) {
            var value = values[i];
            if (value[_DYN_NAME$1]) {
              if (value[_DYN_NAME$1] === name) {
                return value;
              }
            }
          }
        }
        return {};
      }
      function findMetaTag(name) {
        var doc = getDocument();
        if (doc && name) {
          return _getNamedValue(doc.querySelectorAll("meta"), name).content;
        }
        return null;
      }
      function findNamedServerTiming(name) {
        var value;
        var perf = /* @__PURE__ */ getPerformance();
        if (perf) {
          var navPerf = perf.getEntriesByType("navigation") || [];
          value = _getNamedValue((navPerf[_DYN_LENGTH$1] > 0 ? navPerf[0] : {}).serverTiming, name).description;
        }
        return value;
      }
      var UInt32Mask = 4294967296;
      var MaxUInt32 = 4294967295;
      var SEED1 = 123456789;
      var SEED2 = 987654321;
      var _mwcSeeded = false;
      var _mwcW = SEED1;
      var _mwcZ = SEED2;
      function _mwcSeed(seedValue) {
        if (seedValue < 0) {
          seedValue >>>= 0;
        }
        _mwcW = SEED1 + seedValue & MaxUInt32;
        _mwcZ = SEED2 - seedValue & MaxUInt32;
        _mwcSeeded = true;
      }
      function _autoSeedMwc() {
        try {
          var now = /* @__PURE__ */ utcNow() & 2147483647;
          _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
        } catch (e) {
        }
      }
      function randomValue(maxValue) {
        if (maxValue > 0) {
          return mathFloor(random32() / MaxUInt32 * (maxValue + 1)) >>> 0;
        }
        return 0;
      }
      function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
          value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
          if (!_mwcSeeded) {
            _autoSeedMwc();
          }
          value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
          value = mathFloor(UInt32Mask * Math.random() | 0);
        }
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function mwcRandom32(signed) {
        _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32;
        _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
        var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function newId(maxLength) {
        if (maxLength === void 0) {
          maxLength = 22;
        }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY;
        while (result[_DYN_LENGTH$1] < maxLength) {
          chars++;
          result += base64chars.charAt(number & 63);
          number >>>= 6;
          if (chars === 5) {
            number = (random32() << 2 & 4294967295 | number & 3) >>> 0;
            chars = 0;
          }
        }
        return result;
      }
      var version = "3.3.7";
      var instanceName = "." + newId(6);
      var _dataUid = 0;
      function _canAcceptData(target) {
        return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
      }
      function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
          theCache = {};
          try {
            if (_canAcceptData(target)) {
              objDefine(target, data.id, {
                e: false,
                v: theCache
              });
            }
          } catch (e) {
          }
        }
        return theCache;
      }
      function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) {
          includeVersion = false;
        }
        return normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY) + instanceName);
      }
      function createElmNodeData(name) {
        var data = {
          id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY) + "." + version),
          accept: function(target) {
            return _canAcceptData(target);
          },
          get: function(target, name2, defValue, addDefault) {
            var theCache = target[data.id];
            if (!theCache) {
              if (addDefault) {
                theCache = _getCache(data, target);
                theCache[normalizeJsName(name2)] = defValue;
              }
              return defValue;
            }
            return theCache[normalizeJsName(name2)];
          },
          kill: function(target, name2) {
            if (target && target[name2]) {
              try {
                delete target[name2];
              } catch (e) {
              }
            }
          }
        };
        return data;
      }
      function _isConfigDefaults(value) {
        return value && /* @__PURE__ */ isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
      }
      function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
          var fallbacks = cfgDefaults.fb;
          if (!isArray(fallbacks)) {
            fallbacks = [fallbacks];
          }
          for (var lp = 0; lp < fallbacks[_DYN_LENGTH$1]; lp++) {
            var fallback = fallbacks[lp];
            var fbValue = theConfig[fallback];
            if (isDefaultValid(fbValue)) {
              defValue = fbValue;
            } else if (dynamicHandler) {
              fbValue = dynamicHandler.cfg[fallback];
              if (isDefaultValid(fbValue)) {
                defValue = fbValue;
              }
              dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
            }
            if (isDefaultValid(defValue)) {
              break;
            }
          }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
          defValue = cfgDefaults.v;
        }
        return defValue;
      }
      function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
          theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
          if (_isConfigDefaults(theValue)) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
          }
          var newValue_1;
          if (isArray(theValue)) {
            newValue_1 = [];
            newValue_1[_DYN_LENGTH$1] = theValue[_DYN_LENGTH$1];
          } else if (/* @__PURE__ */ isPlainObject(theValue)) {
            newValue_1 = {};
          }
          if (newValue_1) {
            objForEachKey(theValue, function(key, value) {
              if (value && _isConfigDefaults(value)) {
                value = _resolveDefaultValue(dynamicHandler, theConfig, value);
              }
              newValue_1[key] = value;
            });
            theValue = newValue_1;
          }
        }
        return theValue;
      }
      function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
          isValid = cfgDefaults.isVal;
          setFn = cfgDefaults.set;
          readOnly = cfgDefaults.rdOnly;
          blkDynamicValue = cfgDefaults.blkVal;
          mergeDf = cfgDefaults.mrg;
          reference = cfgDefaults.ref;
          if (!reference && /* @__PURE__ */ isUndefined(reference)) {
            reference = !!mergeDf;
          }
          defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        } else {
          defValue = defaultValue;
        }
        if (blkDynamicValue) {
          dynamicHandler.blkVal(theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !/* @__PURE__ */ isNullOrUndefined(cfgValue)) {
          theValue = cfgValue;
          usingDefault = false;
          if (isValid && theValue !== defValue && !isValid(theValue)) {
            theValue = defValue;
            usingDefault = true;
          }
          if (setFn) {
            theValue = setFn(theValue, defValue, theConfig);
            usingDefault = theValue === defValue;
          }
        }
        if (!usingDefault) {
          if (/* @__PURE__ */ isPlainObject(theValue) || isArray(defValue)) {
            if (mergeDf && defValue && (/* @__PURE__ */ isPlainObject(defValue) || isArray(defValue))) {
              objForEachKey(defValue, function(dfName, dfValue) {
                _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
              });
            }
          }
        } else if (defValue) {
          theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        } else {
          theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
          dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
          dynamicHandler.rdOnly(theConfig, name);
        }
      }
      var CFG_HANDLER_LINK = /* @__PURE__ */ symbolFor("[[ai_dynCfg_1]]");
      var BLOCK_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_blkDynCfg_1]]");
      var FORCE_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_frcDynCfg_1]]");
      function _cfgDeepCopy(source) {
        if (source) {
          var target_1;
          if (isArray(source)) {
            target_1 = [];
            target_1[_DYN_LENGTH$1] = source[_DYN_LENGTH$1];
          } else if (/* @__PURE__ */ isPlainObject(source)) {
            target_1 = {};
          }
          if (target_1) {
            objForEachKey(source, function(key, value) {
              target_1[key] = _cfgDeepCopy(value);
            });
            return target_1;
          }
        }
        return source;
      }
      function getDynamicConfigHandler(value) {
        if (value) {
          var handler = value[CFG_HANDLER_LINK] || value;
          if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler;
          }
        }
        return null;
      }
      function blockDynamicConversion(value) {
        if (value && (/* @__PURE__ */ isPlainObject(value) || isArray(value))) {
          try {
            value[BLOCK_DYNAMIC] = true;
          } catch (e) {
          }
        }
        return value;
      }
      function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
          result = value[FORCE_DYNAMIC];
          if (!result && !value[BLOCK_DYNAMIC]) {
            result = /* @__PURE__ */ isPlainObject(value) || isArray(value);
          }
        }
        return result;
      }
      function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
      }
      var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
      ];
      var _throwDynamicError = function(logger2, name, desc, e) {
        logger2 && logger2[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + /* @__PURE__ */ dumpObj(e));
      };
      function _patchArray(state, target, name) {
        if (isArray(target)) {
          arrForEach(arrayMethodsToPatch, function(method) {
            var orgMethod = target[method];
            target[method] = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var result = orgMethod[_DYN_APPLY](this, args);
              _makeDynamicObject(state, target, name, "Patching");
              return result;
            };
          });
        }
      }
      function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
      }
      function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
          n: name,
          h: [],
          trk: function(handler) {
            if (handler && handler.fn) {
              if (arrIndexOf(detail.h, handler) === -1) {
                detail.h[_DYN_PUSH](handler);
              }
              state.trk(handler, detail);
            }
          },
          clr: function(handler) {
            var idx = arrIndexOf(detail.h, handler);
            if (idx !== -1) {
              detail.h[_DYN_SPLICE](idx, 1);
            }
          }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
          if (checkDynamic) {
            isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
            if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
              value = _makeDynamicObject(state, value, name, "Converting");
            }
            checkDynamic = false;
          }
          var activeHandler = state.act;
          if (activeHandler) {
            detail.trk(activeHandler);
          }
          return value;
        }
        _getProperty[state.prop] = {
          chng: function() {
            state.add(detail);
          }
        };
        function _setProperty(newValue) {
          if (value !== newValue) {
            if (!!_getProperty[state.ro] && !state.upd) {
              throwInvalidAccess("[" + name + "] is read-only:" + /* @__PURE__ */ dumpObj(theConfig));
            }
            if (checkDynamic) {
              isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
              checkDynamic = false;
            }
            var isReferenced = isObjectOrArray && _getProperty[state.rf];
            if (isObjectOrArray) {
              if (isReferenced) {
                objForEachKey(value, function(key) {
                  value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
                });
                try {
                  objForEachKey(newValue, function(key, theValue) {
                    _setDynamicProperty(state, value, key, theValue);
                  });
                  newValue = value;
                } catch (e) {
                  _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e);
                  isObjectOrArray = false;
                }
              } else if (value && value[CFG_HANDLER_LINK]) {
                objForEachKey(value, function(key) {
                  var getter = _getOwnPropGetter(value, key);
                  if (getter) {
                    var valueState = getter[state.prop];
                    valueState && valueState.chng();
                  }
                });
              }
            }
            if (newValue !== value) {
              var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
              if (!isReferenced && newIsObjectOrArray) {
                newValue = _makeDynamicObject(state, newValue, name, "Converting");
              }
              value = newValue;
              isObjectOrArray = newIsObjectOrArray;
            }
            state.add(detail);
          }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
      }
      function _setDynamicProperty(state, target, name, value) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          if (!isDynamic) {
            _createDynamicProperty(state, target, name, value);
          } else {
            target[name] = value;
          }
        }
        return target;
      }
      function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          var inPlace = flags && flags[0];
          var rdOnly = flags && flags[1];
          var blkProp = flags && flags[2];
          if (!isDynamic) {
            if (blkProp) {
              try {
                blockDynamicConversion(target);
              } catch (e) {
                _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
              }
            }
            try {
              _setDynamicProperty(state, target, name, target[name]);
              getter = _getOwnPropGetter(target, name);
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
            }
          }
          if (inPlace) {
            getter[state.rf] = inPlace;
          }
          if (rdOnly) {
            getter[state.ro] = rdOnly;
          }
          if (blkProp) {
            getter[state.blkVal] = true;
          }
        }
        return target;
      }
      function _makeDynamicObject(state, target, name, desc) {
        try {
          objForEachKey(target, function(key, value) {
            _setDynamicProperty(state, target, key, value);
          });
          if (!target[CFG_HANDLER_LINK]) {
            objDefineProp(target, CFG_HANDLER_LINK, {
              get: function() {
                return state.hdlr;
              }
            });
            _patchArray(state, target, name);
          }
        } catch (e) {
          _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
        }
        return target;
      }
      var symPrefix = "[[ai_";
      var symPostfix = "]]";
      function _createState(cfgHandler) {
        var dynamicPropertySymbol = /* @__PURE__ */ newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = /* @__PURE__ */ newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = /* @__PURE__ */ newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = /* @__PURE__ */ newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = /* @__PURE__ */ newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
          var prevWatcher = theState.act;
          try {
            theState.act = activeHandler;
            if (activeHandler && activeHandler[dynamicPropertyDetail]) {
              arrForEach(activeHandler[dynamicPropertyDetail], function(detail) {
                detail.clr(activeHandler);
              });
              activeHandler[dynamicPropertyDetail] = [];
            }
            callback({
              cfg: cfgHandler.cfg,
              set: cfgHandler.set.bind(cfgHandler),
              setDf: cfgHandler.setDf.bind(cfgHandler),
              ref: cfgHandler.ref.bind(cfgHandler),
              rdOnly: cfgHandler.rdOnly.bind(cfgHandler)
            });
          } catch (e) {
            var logger2 = cfgHandler[_DYN_LOGGER];
            if (logger2) {
              logger2[_DYN_THROW_INTERNAL](1, 107, /* @__PURE__ */ dumpObj(e));
            }
            throw e;
          } finally {
            theState.act = prevWatcher || null;
          }
        }
        function _notifyWatchers() {
          if (_waitingHandlers) {
            var notifyHandlers = _waitingHandlers;
            _waitingHandlers = null;
            _watcherTimer && _watcherTimer[_DYN_CANCEL]();
            _watcherTimer = null;
            var watcherFailures_1 = [];
            arrForEach(notifyHandlers, function(handler) {
              if (handler) {
                if (handler[dynamicPropertyDetail]) {
                  arrForEach(handler[dynamicPropertyDetail], function(detail) {
                    detail.clr(handler);
                  });
                  handler[dynamicPropertyDetail] = null;
                }
                if (handler.fn) {
                  try {
                    _useHandler(handler, handler.fn);
                  } catch (e) {
                    watcherFailures_1[_DYN_PUSH](e);
                  }
                }
              }
            });
            if (_waitingHandlers) {
              try {
                _notifyWatchers();
              } catch (e) {
                watcherFailures_1[_DYN_PUSH](e);
              }
            }
            if (watcherFailures_1[_DYN_LENGTH$1] > 0) {
              throwAggregationError("Watcher error(s): ", watcherFailures_1);
            }
          }
        }
        function _addWatcher(detail) {
          if (detail && detail.h[_DYN_LENGTH$1] > 0) {
            if (!_waitingHandlers) {
              _waitingHandlers = [];
            }
            if (!_watcherTimer) {
              _watcherTimer = scheduleTimeout(function() {
                _watcherTimer = null;
                _notifyWatchers();
              }, 0);
            }
            for (var idx = 0; idx < detail.h[_DYN_LENGTH$1]; idx++) {
              var handler = detail.h[idx];
              if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                _waitingHandlers[_DYN_PUSH](handler);
              }
            }
          }
        }
        function _trackHandler(handler, detail) {
          if (handler) {
            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
            if (arrIndexOf(details, detail) === -1) {
              details[_DYN_PUSH](detail);
            }
          }
        }
        theState = {
          prop: dynamicPropertySymbol,
          ro: dynamicPropertyReadOnly,
          rf: dynamicPropertyReferenced,
          blkVal: dynamicPropertyBlockValue,
          hdlr: cfgHandler,
          add: _addWatcher,
          notify: _notifyWatchers,
          use: _useHandler,
          trk: _trackHandler
        };
        return theState;
      }
      function _createAndUseHandler(state, configHandler) {
        var handler = {
          fn: configHandler,
          rm: function() {
            handler.fn = null;
            state = null;
            configHandler = null;
          }
        };
        objDefine(handler, "toJSON", { v: function() {
          return "WatcherHandler" + (handler.fn ? "" : "[X]");
        } });
        state.use(handler, configHandler);
        return handler;
      }
      function _createDynamicHandler(logger2, target, inPlace) {
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
          return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = target && inPlace !== false ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
          theState.notify();
        }
        function _setValue(target2, name, value) {
          try {
            target2 = _setDynamicProperty(theState, target2, name, value);
          } catch (e) {
            _throwDynamicError(logger2, name, "Setting value", e);
          }
          return target2[name];
        }
        function _watch(configHandler) {
          return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
          theState.use(null, function(details) {
            var prevUpd = theState.upd;
            try {
              if (!/* @__PURE__ */ isUndefined(allowUpdate)) {
                theState.upd = allowUpdate;
              }
              configHandler(details);
            } finally {
              theState.upd = prevUpd;
            }
          });
        }
        function _ref(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[0] = true, _a2))[name];
        }
        function _rdOnly(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[1] = true, _a2))[name];
        }
        function _blkPropValue(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[2] = true, _a2))[name];
        }
        function _applyDefaults(theConfig, defaultValues2) {
          if (defaultValues2) {
            objForEachKey(defaultValues2, function(name, value) {
              _applyDefaultValue(cfgHandler, theConfig, name, value);
            });
          }
          return theConfig;
        }
        var cfgHandler = {
          uid: null,
          cfg: newTarget,
          logger: logger2,
          notify: _notifyWatchers,
          set: _setValue,
          setDf: _applyDefaults,
          watch: _watch,
          ref: _ref,
          rdOnly: _rdOnly,
          blkVal: _blkPropValue,
          _block
        };
        objDefine(cfgHandler, "uid", {
          c: false,
          e: false,
          w: false,
          v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
      }
      function _logInvalidAccess(logger2, message) {
        if (logger2) {
          logger2[_DYN_WARN_TO_CONSOLE](message);
          logger2[_DYN_THROW_INTERNAL](2, 108, message);
        } else {
          throwInvalidAccess(message);
        }
      }
      function createDynamicConfig(config, defaultConfig, logger2, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger2, config || {}, inPlace);
        if (defaultConfig) {
          dynamicHandler.setDf(dynamicHandler.cfg, defaultConfig);
        }
        return dynamicHandler;
      }
      function onConfigChange(config, configHandler, logger2) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
          return handler[_DYN_WATCH](configHandler);
        }
        _logInvalidAccess(logger2, STR_NOT_DYNAMIC_ERROR + /* @__PURE__ */ dumpObj(config));
        return createDynamicConfig(config, null, logger2)[_DYN_WATCH](configHandler);
      }
      var _aiNamespace = null;
      function _getExtensionNamespace() {
        var target = /* @__PURE__ */ getInst("Microsoft");
        if (target) {
          _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
      }
      function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
          ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
      }
      var _a;
      var STR_WARN_TO_CONSOLE = "warnToConsole";
      var AiNonUserActionablePrefix = "AI (Internal): ";
      var AiUserActionablePrefix = "AI: ";
      var AIInternalMessagePrefix = "AITR_";
      var defaultValues = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
      };
      var _logFuncs = (_a = {}, _a[0] = null, _a[1] = "errorToConsole", _a[2] = STR_WARN_TO_CONSOLE, _a[3] = "debugToConsole", _a);
      function _sanitizeDiagnosticText(text) {
        if (text) {
          return '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY) + '"';
        }
        return STR_EMPTY;
      }
      function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
          var logFunc = "log";
          if (theConsole[func]) {
            logFunc = func;
          }
          if (isFunction(theConsole[logFunc])) {
            theConsole[logFunc](message);
          }
        }
      }
      var _InternalLogMessage = (
        /** @class */
        function() {
          function _InternalLogMessage2(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) {
              isUserAct = false;
            }
            var _self = this;
            _self[_DYN_MESSAGE_ID] = msgId;
            _self[_DYN_MESSAGE$1] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
            var strProps = STR_EMPTY;
            if (hasJSON()) {
              strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);
            _self[_DYN_MESSAGE$1] += diagnosticText;
          }
          _InternalLogMessage2.dataType = "MessageData";
          return _InternalLogMessage2;
        }()
      );
      function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
      }
      var DiagnosticLogger = (
        /** @class */
        function() {
          function DiagnosticLogger2(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger2, this, function(_self) {
              _unloadHandler = _setDefaultsFromConfig(config || {});
              _self.consoleLoggingLevel = function() {
                return _loggingLevelConsole;
              };
              _self[_DYN_THROW_INTERNAL] = function(severity, msgId, msg, properties, isUserAct) {
                if (isUserAct === void 0) {
                  isUserAct = false;
                }
                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                if (_enableDebug) {
                  throw /* @__PURE__ */ dumpObj(message);
                } else {
                  var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                  if (!/* @__PURE__ */ isUndefined(message[_DYN_MESSAGE$1])) {
                    if (isUserAct) {
                      var messageKey = +message[_DYN_MESSAGE_ID];
                      if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE$1]);
                        _messageLogged[messageKey] = true;
                      }
                    } else {
                      if (_loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE$1]);
                      }
                    }
                    _logInternalMessage(severity, message);
                  } else {
                    _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);
                  }
                }
              };
              _self.debugToConsole = function(message) {
                _logToConsole("debug", message);
                _debugExtMsg("warning", message);
              };
              _self[_DYN_WARN_TO_CONSOLE] = function(message) {
                _logToConsole("warn", message);
                _debugExtMsg("warning", message);
              };
              _self.errorToConsole = function(message) {
                _logToConsole("error", message);
                _debugExtMsg("error", message);
              };
              _self.resetInternalMessageCount = function() {
                _messageCount = 0;
                _messageLogged = {};
              };
              _self.logInternalMessage = _logInternalMessage;
              _self[_DYN_UNLOAD] = function(isAsync) {
                _unloadHandler && _unloadHandler.rm();
                _unloadHandler = null;
              };
              function _logInternalMessage(severity, message) {
                if (_areInternalMessagesThrottled()) {
                  return;
                }
                var logMessage = true;
                var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
                if (_messageLogged[messageKey]) {
                  logMessage = false;
                } else {
                  _messageLogged[messageKey] = true;
                }
                if (logMessage) {
                  if (severity <= _loggingLevelTelemetry) {
                    _self.queue[_DYN_PUSH](message);
                    _messageCount++;
                    _debugExtMsg(severity === 1 ? "error" : "warn", message);
                  }
                  if (_messageCount === _maxInternalMessageLimit) {
                    var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                    var throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, false);
                    _self.queue[_DYN_PUSH](throttleMessage);
                    if (severity === 1) {
                      _self.errorToConsole(throttleLimitMessage);
                    } else {
                      _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
                    }
                  }
                }
              }
              function _setDefaultsFromConfig(config2) {
                return onConfigChange(createDynamicConfig(config2, defaultValues, _self).cfg, function(details) {
                  var config3 = details.cfg;
                  _loggingLevelConsole = config3[_DYN_LOGGING_LEVEL_CONSOL4];
                  _loggingLevelTelemetry = config3.loggingLevelTelemetry;
                  _maxInternalMessageLimit = config3.maxMessageLimit;
                  _enableDebug = config3.enableDebug;
                });
              }
              function _areInternalMessagesThrottled() {
                return _messageCount >= _maxInternalMessageLimit;
              }
              function _debugExtMsg(name, data) {
                var dbgExt = getDebugExt(config || {});
                if (dbgExt && dbgExt[_DYN_DIAG_LOG]) {
                  dbgExt[_DYN_DIAG_LOG](name, data);
                }
              }
            });
          }
          DiagnosticLogger2.__ieDyn = 1;
          return DiagnosticLogger2;
        }()
      );
      function _getLogger(logger2) {
        return logger2 || new DiagnosticLogger();
      }
      function _throwInternal(logger2, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) {
          isUserAct = false;
        }
        _getLogger(logger2)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
      }
      function generateW3CId() {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        var oct = STR_EMPTY, tmp;
        for (var a = 0; a < 4; a++) {
          tmp = random32();
          oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
        }
        var clockSequenceHi = hexValues[8 + (random32() & 3) | 0];
        return strSubstr(oct, 0, 8) + strSubstr(oct, 9, 4) + "4" + strSubstr(oct, 13, 3) + clockSequenceHi + strSubstr(oct, 16, 3) + strSubstr(oct, 19, 12);
      }
      var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i;
      var DEFAULT_VERSION = "00";
      var INVALID_VERSION = "ff";
      var INVALID_TRACE_ID = "00000000000000000000000000000000";
      var INVALID_SPAN_ID = "0000000000000000";
      var SAMPLED_FLAG = 1;
      function _isValid(value, len, invalidValue) {
        if (value && value[_DYN_LENGTH$1] === len && value !== invalidValue) {
          return !!value.match(/^[\da-f]*$/i);
        }
        return false;
      }
      function _formatValue(value, len, defValue) {
        if (_isValid(value, len)) {
          return value;
        }
        return defValue;
      }
      function _formatFlags(value) {
        if (isNaN(value) || value < 0 || value > 255) {
          value = 1;
        }
        var result = value.toString(16);
        while (result[_DYN_LENGTH$1] < 2) {
          result = "0" + result;
        }
        return result;
      }
      function createTraceParent(traceId, spanId, flags, version2) {
        return {
          version: _isValid(version2, 2, INVALID_VERSION) ? version2 : DEFAULT_VERSION,
          traceId: isValidTraceId(traceId) ? traceId : generateW3CId(),
          spanId: isValidSpanId(spanId) ? spanId : /* @__PURE__ */ strLeft(generateW3CId(), 16),
          traceFlags: flags >= 0 && flags <= 255 ? flags : 1
        };
      }
      function parseTraceParent(value, selectIdx) {
        if (!value) {
          return null;
        }
        if (isArray(value)) {
          value = value[0] || "";
        }
        if (!value || !isString(value) || value[_DYN_LENGTH$1] > 8192) {
          return null;
        }
        if (value[_DYN_INDEX_OF](",") !== -1) {
          var values = value[_DYN_SPLIT$1](",");
          value = values[selectIdx > 0 && values[_DYN_LENGTH$1] > selectIdx ? selectIdx : 0];
        }
        var match = TRACE_PARENT_REGEX.exec(strTrim(value));
        if (!match || match[1] === INVALID_VERSION || match[2] === INVALID_TRACE_ID || match[3] === INVALID_SPAN_ID) {
          return null;
        }
        return {
          version: (match[1] || STR_EMPTY)[_DYN_TO_LOWER_CASE$1](),
          traceId: (match[2] || STR_EMPTY)[_DYN_TO_LOWER_CASE$1](),
          spanId: (match[3] || STR_EMPTY)[_DYN_TO_LOWER_CASE$1](),
          traceFlags: parseInt(match[4], 16)
        };
      }
      function isValidTraceId(value) {
        return _isValid(value, 32, INVALID_TRACE_ID);
      }
      function isValidSpanId(value) {
        return _isValid(value, 16, INVALID_SPAN_ID);
      }
      function isValidTraceParent(value) {
        if (!value || !_isValid(value[_DYN_VERSION], 2, INVALID_VERSION) || !_isValid(value.traceId, 32, INVALID_TRACE_ID) || !_isValid(value.spanId, 16, INVALID_SPAN_ID) || !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS]), 2)) {
          return false;
        }
        return true;
      }
      function isSampledFlag(value) {
        if (isValidTraceParent(value)) {
          return (value[_DYN_TRACE_FLAGS] & SAMPLED_FLAG) === SAMPLED_FLAG;
        }
        return false;
      }
      function formatTraceParent(value) {
        if (value) {
          var flags = _formatFlags(value[_DYN_TRACE_FLAGS]);
          if (!_isValid(flags, 2)) {
            flags = "01";
          }
          var version2 = value[_DYN_VERSION] || DEFAULT_VERSION;
          if (version2 !== "00" && version2 !== "ff") {
            version2 = DEFAULT_VERSION;
          }
          return "".concat(version2.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
        }
        return "";
      }
      function findW3cTraceParent(selectIdx) {
        var name = "traceparent";
        var traceParent = parseTraceParent(findMetaTag(name), selectIdx);
        if (!traceParent) {
          traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx);
        }
        return traceParent;
      }
      function findAllScripts(doc) {
        var scripts = doc.getElementsByTagName("script");
        var result = [];
        arrForEach(scripts, function(script) {
          var src = script[_DYN_GET_ATTRIBUTE]("src");
          if (src) {
            var crossOrigin = script[_DYN_GET_ATTRIBUTE]("crossorigin");
            var async = script.hasAttribute("async") === true;
            var defer = script.hasAttribute("defer") === true;
            var referrerPolicy = script[_DYN_GET_ATTRIBUTE]("referrerpolicy");
            var info = { url: src };
            if (crossOrigin) {
              info.crossOrigin = crossOrigin;
            }
            if (async) {
              info.async = async;
            }
            if (defer) {
              info.defer = defer;
            }
            if (referrerPolicy) {
              info.referrerPolicy = referrerPolicy;
            }
            result[_DYN_PUSH](info);
          }
        });
        return result;
      }
      var strOnPrefix = "on";
      var strAttachEvent = "attachEvent";
      var strAddEventHelper = "addEventListener";
      var strDetachEvent = "detachEvent";
      var strRemoveEventListener = "removeEventListener";
      var strEvents = "events";
      createUniqueNamespace("aiEvtPageHide");
      createUniqueNamespace("aiEvtPageShow");
      var rRemoveEmptyNs = /\.[\.]+/g;
      var rRemoveTrailingEmptyNs = /[\.]+$/;
      var _guid = 1;
      var elmNodeData = createElmNodeData("events");
      var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
      function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE]) {
          return name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY);
        }
        return name;
      }
      function _getEvtNamespace(eventName, evtNamespace) {
        if (evtNamespace) {
          var theNamespace_1 = STR_EMPTY;
          if (isArray(evtNamespace)) {
            theNamespace_1 = STR_EMPTY;
            arrForEach(evtNamespace, function(name) {
              name = _normalizeNamespace(name);
              if (name) {
                if (name[0] !== ".") {
                  name = "." + name;
                }
                theNamespace_1 += name;
              }
            });
          } else {
            theNamespace_1 = _normalizeNamespace(evtNamespace);
          }
          if (theNamespace_1) {
            if (theNamespace_1[0] !== ".") {
              theNamespace_1 = "." + theNamespace_1;
            }
            eventName = (eventName || STR_EMPTY) + theNamespace_1;
          }
        }
        var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY) || [];
        return {
          type: parsedEvent[1],
          ns: (parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT$1](".").sort().join(".")
        };
      }
      function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) {
          addDefault = true;
        }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
          registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
      }
      function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE]) {
          if (obj[strRemoveEventListener]) {
            obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture);
          } else if (obj[strDetachEvent]) {
            obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
          }
        }
      }
      function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE] && handlerRef) {
          if (obj[strAddEventHelper]) {
            obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture);
            result = true;
          } else if (obj[strAttachEvent]) {
            obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
            result = true;
          }
        }
        return result;
      }
      function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$1];
        while (idx--) {
          var theEvent = events[idx];
          if (theEvent) {
            if (!evtName.ns || evtName.ns === theEvent[_DYN_EVT_NAME].ns) {
              if (!unRegFn || unRegFn(theEvent)) {
                _doDetach(target, theEvent[_DYN_EVT_NAME], theEvent.handler, theEvent.capture);
                events[_DYN_SPLICE](idx, 1);
              }
            }
          }
        }
      }
      function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE]) {
          _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);
        } else {
          var eventCache = elmNodeData.get(target, strEvents, {});
          objForEachKey(eventCache, function(evtType, events) {
            _doUnregister(target, events, evtName, unRegFn);
          });
          if (objKeys(eventCache)[_DYN_LENGTH$1] === 0) {
            elmNodeData.kill(target, strEvents);
          }
        }
      }
      function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
          if (isArray(namespaces)) {
            newNamespaces = [theNamespace].concat(namespaces);
          } else {
            newNamespaces = [theNamespace, namespaces];
          }
          newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT$1](".");
        } else {
          newNamespaces = theNamespace;
        }
        return newNamespaces;
      }
      function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        var result = false;
        if (target) {
          try {
            var evtName = _getEvtNamespace(eventName, evtNamespace);
            result = _doAttach(target, evtName, handlerRef, useCapture);
            if (result && elmNodeData.accept(target)) {
              var registeredEvent = {
                guid: _guid++,
                evtName,
                handler: handlerRef,
                capture: useCapture
              };
              _getRegisteredEvents(target, evtName.type)[_DYN_PUSH](registeredEvent);
            }
          } catch (e) {
          }
        }
        return result;
      }
      function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        if (target) {
          try {
            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
            var found_1 = false;
            _unregisterEvents(target, evtName_1, function(regEvent) {
              if (evtName_1.ns && !handlerRef || regEvent.handler === handlerRef) {
                found_1 = true;
                return true;
              }
              return false;
            });
            if (!found_1) {
              _doDetach(target, evtName_1, handlerRef, useCapture);
            }
          } catch (e) {
          }
        }
      }
      var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var SampleRate = "sampleRate";
      var ProcessLegacy = "ProcessLegacy";
      var HttpMethod = "http.method";
      var DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
      var DEFAULT_BREEZE_PATH = "/v2/track";
      var strNotSpecified = "not_specified";
      var strIkey = "iKey";
      var RequestHeaders = createValueMap({
        requestContextHeader: [0, "Request-Context"],
        requestContextTargetKey: [1, "appId"],
        requestContextAppIdFormat: [2, "appId=cid-v1:"],
        requestIdHeader: [3, "Request-Id"],
        traceParentHeader: [4, "traceparent"],
        traceStateHeader: [5, "tracestate"],
        sdkContextHeader: [6, "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7, "appId"],
        requestContextHeaderLowerCase: [8, "request-context"]
      });
      var _DYN_SPLIT = "split";
      var _DYN_LENGTH = "length";
      var _DYN_TO_LOWER_CASE = "toLowerCase";
      var _DYN_INGESTIONENDPOINT = "ingestionendpoint";
      var _DYN_TO_STRING = "toString";
      var _DYN_REMOVE_ITEM = "removeItem";
      var _DYN_MESSAGE = "message";
      var _DYN_COUNT = "count";
      var _DYN_PRE_TRIGGER_DATE = "preTriggerDate";
      var _DYN_GET_UTCDATE = "getUTCDate";
      var _DYN_STRINGIFY = "stringify";
      var _DYN_PATHNAME = "pathname";
      var _DYN_MATCH = "match";
      var _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns";
      var _DYN_NAME = "name";
      var _DYN_EXTENSION_CONFIG = "extensionConfig";
      var _DYN_PROPERTIES = "properties";
      var _DYN_MEASUREMENTS = "measurements";
      var _DYN_SIZE_IN_BYTES = "sizeInBytes";
      var _DYN_TYPE_NAME = "typeName";
      var _DYN_EXCEPTIONS = "exceptions";
      var _DYN_SEVERITY_LEVEL = "severityLevel";
      var _DYN_PROBLEM_GROUP = "problemGroup";
      var _DYN_PARSED_STACK = "parsedStack";
      var _DYN_HAS_FULL_STACK = "hasFullStack";
      var _DYN_ASSEMBLY = "assembly";
      var _DYN_FILE_NAME = "fileName";
      var _DYN_LINE = "line";
      var _DYN_AI_DATA_CONTRACT = "aiDataContract";
      var _DYN_DURATION = "duration";
      function dataSanitizeKeyAndAddUniqueness(logger2, key, map) {
        var origLength = key[_DYN_LENGTH];
        var field = dataSanitizeKey(logger2, key);
        if (field[_DYN_LENGTH] !== origLength) {
          var i = 0;
          var uniqueField = field;
          while (map[uniqueField] !== void 0) {
            i++;
            uniqueField = strSubstring(field, 0, 150 - 3) + dsPadNumber(i);
          }
          field = uniqueField;
        }
        return field;
      }
      function dataSanitizeKey(logger2, name) {
        var nameTrunc;
        if (name) {
          name = strTrim(asString(name));
          if (name[_DYN_LENGTH] > 150) {
            nameTrunc = strSubstring(name, 0, 150);
            _throwInternal(logger2, 2, 57, "name is too long.  It has been truncated to 150 characters.", { name }, true);
          }
        }
        return nameTrunc || name;
      }
      function dataSanitizeString(logger2, value, maxLength) {
        if (maxLength === void 0) {
          maxLength = 1024;
        }
        var valueTrunc;
        if (value) {
          maxLength = maxLength ? maxLength : 1024;
          value = strTrim(asString(value));
          if (value[_DYN_LENGTH] > maxLength) {
            valueTrunc = strSubstring(value, 0, maxLength);
            _throwInternal(logger2, 2, 61, "string value is too long. It has been truncated to " + maxLength + " characters.", { value }, true);
          }
        }
        return valueTrunc || value;
      }
      function dataSanitizeUrl(logger2, url) {
        return dataSanitizeInput(logger2, url, 2048, 66);
      }
      function dataSanitizeMessage(logger2, message) {
        var messageTrunc;
        if (message) {
          if (message[_DYN_LENGTH] > 32768) {
            messageTrunc = strSubstring(message, 0, 32768);
            _throwInternal(logger2, 2, 56, "message is too long, it has been truncated to 32768 characters.", { message }, true);
          }
        }
        return messageTrunc || message;
      }
      function dataSanitizeException(logger2, exception) {
        var exceptionTrunc;
        if (exception) {
          var value = "" + exception;
          if (value[_DYN_LENGTH] > 32768) {
            exceptionTrunc = strSubstring(value, 0, 32768);
            _throwInternal(logger2, 2, 52, "exception is too long, it has been truncated to 32768 characters.", { exception }, true);
          }
        }
        return exceptionTrunc || exception;
      }
      function dataSanitizeProperties(logger2, properties) {
        if (properties) {
          var tempProps_1 = {};
          objForEachKey(properties, function(prop, value) {
            if (/* @__PURE__ */ isObject(value) && hasJSON()) {
              try {
                value = getJSON()[_DYN_STRINGIFY](value);
              } catch (e) {
                _throwInternal(logger2, 2, 49, "custom property is not valid", { exception: e }, true);
              }
            }
            value = dataSanitizeString(logger2, value, 8192);
            prop = dataSanitizeKeyAndAddUniqueness(logger2, prop, tempProps_1);
            tempProps_1[prop] = value;
          });
          properties = tempProps_1;
        }
        return properties;
      }
      function dataSanitizeMeasurements(logger2, measurements) {
        if (measurements) {
          var tempMeasurements_1 = {};
          objForEachKey(measurements, function(measure, value) {
            measure = dataSanitizeKeyAndAddUniqueness(logger2, measure, tempMeasurements_1);
            tempMeasurements_1[measure] = value;
          });
          measurements = tempMeasurements_1;
        }
        return measurements;
      }
      function dataSanitizeId(logger2, id) {
        return id ? dataSanitizeInput(logger2, id, 128, 69)[_DYN_TO_STRING]() : id;
      }
      function dataSanitizeInput(logger2, input, maxLength, _msgId) {
        var inputTrunc;
        if (input) {
          input = strTrim(asString(input));
          if (input[_DYN_LENGTH] > maxLength) {
            inputTrunc = strSubstring(input, 0, maxLength);
            _throwInternal(logger2, 2, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
          }
        }
        return inputTrunc || input;
      }
      function dsPadNumber(num) {
        var s = "00" + num;
        return strSubstr(s, s[_DYN_LENGTH] - 3);
      }
      var _document = getDocument() || {};
      var _htmlAnchorIdx = 0;
      var _htmlAnchorElement = [null, null, null, null, null];
      function urlParseUrl(url) {
        var anchorIdx = _htmlAnchorIdx;
        var anchorCache = _htmlAnchorElement;
        var tempAnchor = anchorCache[anchorIdx];
        if (!_document.createElement) {
          tempAnchor = { host: urlParseHost(url, true) };
        } else if (!anchorCache[anchorIdx]) {
          tempAnchor = anchorCache[anchorIdx] = _document.createElement("a");
        }
        tempAnchor.href = url;
        anchorIdx++;
        if (anchorIdx >= anchorCache[_DYN_LENGTH]) {
          anchorIdx = 0;
        }
        _htmlAnchorIdx = anchorIdx;
        return tempAnchor;
      }
      function urlGetAbsoluteUrl(url) {
        var result;
        var a = urlParseUrl(url);
        if (a) {
          result = a.href;
        }
        return result;
      }
      function urlGetPathName(url) {
        var result;
        var a = urlParseUrl(url);
        if (a) {
          result = a[_DYN_PATHNAME];
        }
        return result;
      }
      function urlGetCompleteUrl(method, absoluteUrl) {
        if (method) {
          return method.toUpperCase() + " " + absoluteUrl;
        }
        return absoluteUrl;
      }
      function urlParseHost(url, inclPort) {
        var fullHost = urlParseFullHost(url, inclPort) || "";
        if (fullHost) {
          var match = fullHost[_DYN_MATCH](/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
          if (match != null && match[_DYN_LENGTH] > 3 && isString(match[2]) && match[2][_DYN_LENGTH] > 0) {
            return match[2] + (match[3] || "");
          }
        }
        return fullHost;
      }
      function urlParseFullHost(url, inclPort) {
        var result = null;
        if (url) {
          var match = url[_DYN_MATCH](/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
          if (match != null && match[_DYN_LENGTH] > 2 && isString(match[2]) && match[2][_DYN_LENGTH] > 0) {
            result = match[2] || "";
            if (inclPort && match[_DYN_LENGTH] > 2) {
              var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE]();
              var port = match[3] || "";
              if (protocol === "http" && port === ":80") {
                port = "";
              } else if (protocol === "https" && port === ":443") {
                port = "";
              }
              result += port;
            }
          }
        }
        return result;
      }
      var _internalEndpoints = [
        DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH,
        "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH,
        "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH
      ];
      var _correlationIdPrefix = "cid-v1:";
      function isInternalApplicationInsightsEndpoint(endpointUrl) {
        return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE]()) !== -1;
      }
      function correlationIdSetPrefix(prefix) {
        _correlationIdPrefix = prefix;
      }
      function correlationIdGetPrefix() {
        return _correlationIdPrefix;
      }
      function correlationIdCanIncludeCorrelationHeader(config, requestUrl, currentHost) {
        if (!requestUrl || config && config.disableCorrelationHeaders) {
          return false;
        }
        if (config && config[_DYN_CORRELATION_HEADER_E0]) {
          for (var i = 0; i < config.correlationHeaderExcludePatterns[_DYN_LENGTH]; i++) {
            if (config[_DYN_CORRELATION_HEADER_E0][i].test(requestUrl)) {
              return false;
            }
          }
        }
        var requestHost = urlParseUrl(requestUrl).host[_DYN_TO_LOWER_CASE]();
        if (requestHost && (strIndexOf(requestHost, ":443") !== -1 || strIndexOf(requestHost, ":80") !== -1)) {
          requestHost = (urlParseFullHost(requestUrl, true) || "")[_DYN_TO_LOWER_CASE]();
        }
        if ((!config || !config.enableCorsCorrelation) && (requestHost && requestHost !== currentHost)) {
          return false;
        }
        var includedDomains = config && config.correlationHeaderDomains;
        if (includedDomains) {
          var matchExists_1;
          arrForEach(includedDomains, function(domain) {
            var regex2 = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
            matchExists_1 = matchExists_1 || regex2.test(requestHost);
          });
          if (!matchExists_1) {
            return false;
          }
        }
        var excludedDomains = config && config.correlationHeaderExcludedDomains;
        if (!excludedDomains || excludedDomains[_DYN_LENGTH] === 0) {
          return true;
        }
        for (var i = 0; i < excludedDomains[_DYN_LENGTH]; i++) {
          var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
          if (regex.test(requestHost)) {
            return false;
          }
        }
        return requestHost && requestHost[_DYN_LENGTH] > 0;
      }
      function correlationIdGetCorrelationContext(responseHeader) {
        if (responseHeader) {
          var correlationId = correlationIdGetCorrelationContextValue(responseHeader, RequestHeaders[1]);
          if (correlationId && correlationId !== _correlationIdPrefix) {
            return correlationId;
          }
        }
      }
      function correlationIdGetCorrelationContextValue(responseHeader, key) {
        if (responseHeader) {
          var keyValues = responseHeader[_DYN_SPLIT](",");
          for (var i = 0; i < keyValues[_DYN_LENGTH]; ++i) {
            var keyValue = keyValues[i][_DYN_SPLIT]("=");
            if (keyValue[_DYN_LENGTH] === 2 && keyValue[0] === key) {
              return keyValue[1];
            }
          }
        }
      }
      function AjaxHelperParseDependencyPath(logger2, absoluteUrl, method, commandName) {
        var target, name = commandName, data = commandName;
        if (absoluteUrl && absoluteUrl[_DYN_LENGTH] > 0) {
          var parsedUrl = urlParseUrl(absoluteUrl);
          target = parsedUrl.host;
          if (!name) {
            if (parsedUrl[_DYN_PATHNAME] != null) {
              var pathName = parsedUrl.pathname[_DYN_LENGTH] === 0 ? "/" : parsedUrl[_DYN_PATHNAME];
              if (pathName.charAt(0) !== "/") {
                pathName = "/" + pathName;
              }
              data = parsedUrl[_DYN_PATHNAME];
              name = dataSanitizeString(logger2, method ? method + " " + pathName : pathName);
            } else {
              name = dataSanitizeString(logger2, absoluteUrl);
            }
          }
        } else {
          target = commandName;
          name = commandName;
        }
        return {
          target,
          name,
          data
        };
      }
      function dateTimeUtilsNow() {
        var perf = /* @__PURE__ */ getPerformance();
        if (perf && perf.now && perf.timing) {
          var now = perf.now() + perf.timing.navigationStart;
          if (now > 0) {
            return now;
          }
        }
        return /* @__PURE__ */ utcNow();
      }
      function dateTimeUtilsDuration(start, end) {
        var result = null;
        if (start !== 0 && end !== 0 && !/* @__PURE__ */ isNullOrUndefined(start) && !/* @__PURE__ */ isNullOrUndefined(end)) {
          result = end - start;
        }
        return result;
      }
      function createDistributedTraceContextFromTrace(telemetryTrace, parentCtx) {
        var trace = telemetryTrace || {};
        return {
          getName: function() {
            return trace[_DYN_NAME];
          },
          setName: function(newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DYN_NAME] = newValue;
          },
          getTraceId: function() {
            return trace.traceID;
          },
          setTraceId: function(newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if (isValidTraceId(newValue)) {
              trace.traceID = newValue;
            }
          },
          getSpanId: function() {
            return trace.parentID;
          },
          setSpanId: function(newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if (isValidSpanId(newValue)) {
              trace.parentID = newValue;
            }
          },
          getTraceFlags: function() {
            return trace.traceFlags;
          },
          setTraceFlags: function(newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace.traceFlags = newTraceFlags;
          }
        };
      }
      var StorageType = createEnumStyle({
        LocalStorage: 0,
        SessionStorage: 1
      });
      var DistributedTracingModes = createEnumStyle({
        AI: 0,
        AI_AND_W3C: 1,
        W3C: 2
      });
      var EventPersistence = createEnumStyle({
        Normal: 1,
        Critical: 2
      });
      var _canUseLocalStorage = void 0;
      var _canUseSessionStorage = void 0;
      var _storagePrefix = "";
      function _getLocalStorageObject() {
        if (utlCanUseLocalStorage()) {
          return _getVerifiedStorageObject(StorageType.LocalStorage);
        }
        return null;
      }
      function _getVerifiedStorageObject(storageType) {
        try {
          if (/* @__PURE__ */ isNullOrUndefined(getGlobal())) {
            return null;
          }
          var uid = (/* @__PURE__ */ new Date())[_DYN_TO_STRING]();
          var storage = /* @__PURE__ */ getInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage");
          var name_1 = _storagePrefix + uid;
          storage.setItem(name_1, uid);
          var fail = storage.getItem(name_1) !== uid;
          storage[_DYN_REMOVE_ITEM](name_1);
          if (!fail) {
            return storage;
          }
        } catch (exception) {
        }
        return null;
      }
      function _getSessionStorageObject() {
        if (utlCanUseSessionStorage()) {
          return _getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return null;
      }
      function utlDisableStorage() {
        _canUseLocalStorage = false;
        _canUseSessionStorage = false;
      }
      function utlSetStoragePrefix(storagePrefix) {
        _storagePrefix = storagePrefix || "";
      }
      function utlEnableStorage() {
        _canUseLocalStorage = utlCanUseLocalStorage(true);
        _canUseSessionStorage = utlCanUseSessionStorage(true);
      }
      function utlCanUseLocalStorage(reset) {
        if (reset || _canUseLocalStorage === void 0) {
          _canUseLocalStorage = !!_getVerifiedStorageObject(StorageType.LocalStorage);
        }
        return _canUseLocalStorage;
      }
      function utlGetLocalStorage(logger2, name) {
        var storage = _getLocalStorageObject();
        if (storage !== null) {
          try {
            return storage.getItem(name);
          } catch (e) {
            _canUseLocalStorage = false;
            _throwInternal(logger2, 2, 1, "Browser failed read of local storage. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return null;
      }
      function utlSetLocalStorage(logger2, name, data) {
        var storage = _getLocalStorageObject();
        if (storage !== null) {
          try {
            storage.setItem(name, data);
            return true;
          } catch (e) {
            _canUseLocalStorage = false;
            _throwInternal(logger2, 2, 3, "Browser failed write to local storage. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return false;
      }
      function utlRemoveStorage(logger2, name) {
        var storage = _getLocalStorageObject();
        if (storage !== null) {
          try {
            storage[_DYN_REMOVE_ITEM](name);
            return true;
          } catch (e) {
            _canUseLocalStorage = false;
            _throwInternal(logger2, 2, 5, "Browser failed removal of local storage item. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return false;
      }
      function utlCanUseSessionStorage(reset) {
        if (reset || _canUseSessionStorage === void 0) {
          _canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return _canUseSessionStorage;
      }
      function utlGetSessionStorageKeys() {
        var keys = [];
        if (utlCanUseSessionStorage()) {
          objForEachKey(/* @__PURE__ */ getInst("sessionStorage"), function(key) {
            keys.push(key);
          });
        }
        return keys;
      }
      function utlGetSessionStorage(logger2, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
          try {
            return storage.getItem(name);
          } catch (e) {
            _canUseSessionStorage = false;
            _throwInternal(logger2, 2, 2, "Browser failed read of session storage. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return null;
      }
      function utlSetSessionStorage(logger2, name, data) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
          try {
            storage.setItem(name, data);
            return true;
          } catch (e) {
            _canUseSessionStorage = false;
            _throwInternal(logger2, 2, 4, "Browser failed write to session storage. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return false;
      }
      function utlRemoveSessionStorage(logger2, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
          try {
            storage[_DYN_REMOVE_ITEM](name);
            return true;
          } catch (e) {
            _canUseSessionStorage = false;
            _throwInternal(logger2, 2, 6, "Browser failed removal of session storage item. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return false;
      }
      var THROTTLE_STORAGE_PREFIX = "appInsightsThrottle";
      var ThrottleMgr = (
        /** @class */
        /* @__PURE__ */ function() {
          function ThrottleMgr2(core, namePrefix) {
            var _self = this;
            var _canUseLocalStorage2;
            var _logger;
            var _config;
            var _localStorageObj;
            var _isTriggered;
            var _namePrefix;
            var _queue;
            var _isReady = false;
            var _isSpecificDaysGiven = false;
            _initConfig();
            _self["_getDbgPlgTargets"] = function() {
              return [_queue];
            };
            _self.getConfig = function() {
              return _config;
            };
            _self.canThrottle = function(msgId) {
              var localObj = _getLocalStorageObjByKey(msgId);
              var cfg = _getCfgByKey(msgId);
              return _canThrottle(cfg, _canUseLocalStorage2, localObj);
            };
            _self.isTriggered = function(msgId) {
              return _isTrigger(msgId);
            };
            _self.isReady = function() {
              return _isReady;
            };
            _self.flush = function(msgId) {
              try {
                var queue = _getQueueByKey(msgId);
                if (queue && queue[_DYN_LENGTH] > 0) {
                  var items = queue.slice(0);
                  _queue[msgId] = [];
                  arrForEach(items, function(item) {
                    _flushMessage(item.msgID, item[_DYN_MESSAGE], item.severity, false);
                  });
                  return true;
                }
              } catch (err) {
              }
              return false;
            };
            _self.flushAll = function() {
              try {
                if (_queue) {
                  var result_1 = true;
                  objForEachKey(_queue, function(key) {
                    var isFlushed = _self.flush(parseInt(key));
                    result_1 = result_1 && isFlushed;
                  });
                  return result_1;
                }
              } catch (err) {
              }
              return false;
            };
            _self.onReadyState = function(isReady, flushAll) {
              if (flushAll === void 0) {
                flushAll = true;
              }
              _isReady = /* @__PURE__ */ isNullOrUndefined(isReady) ? true : isReady;
              if (_isReady && flushAll) {
                return _self.flushAll();
              }
              return null;
            };
            _self.sendMessage = function(msgID, message, severity) {
              return _flushMessage(msgID, message, severity, true);
            };
            function _flushMessage(msgID, message, severity, saveUnsentMsg) {
              if (_isReady) {
                var isSampledIn = _canSampledIn(msgID);
                if (!isSampledIn) {
                  return;
                }
                var cfg = _getCfgByKey(msgID);
                var localStorageObj = _getLocalStorageObjByKey(msgID);
                var canThrottle = _canThrottle(cfg, _canUseLocalStorage2, localStorageObj);
                var throttled = false;
                var number = 0;
                var isTriggered = _isTrigger(msgID);
                try {
                  if (canThrottle && !isTriggered) {
                    number = mathMin(cfg.limit.maxSendNumber, localStorageObj[_DYN_COUNT] + 1);
                    localStorageObj[_DYN_COUNT] = 0;
                    throttled = true;
                    _isTriggered[msgID] = true;
                    localStorageObj[_DYN_PRE_TRIGGER_DATE] = /* @__PURE__ */ new Date();
                  } else {
                    _isTriggered[msgID] = canThrottle;
                    localStorageObj[_DYN_COUNT] += 1;
                  }
                  var localStorageName = _getLocalStorageName(msgID);
                  _resetLocalStorage(_logger, localStorageName, localStorageObj);
                  for (var i = 0; i < number; i++) {
                    _sendMessage(msgID, _logger, message, severity);
                  }
                } catch (e) {
                }
                return {
                  isThrottled: throttled,
                  throttleNum: number
                };
              } else {
                if (!!saveUnsentMsg) {
                  var queue = _getQueueByKey(msgID);
                  queue.push({
                    msgID,
                    message,
                    severity
                  });
                }
              }
              return null;
            }
            function _initConfig() {
              _logger = safeGetLogger(core);
              _isTriggered = {};
              _localStorageObj = {};
              _queue = {};
              _config = {};
              _setCfgByKey(109);
              _namePrefix = isNotNullOrUndefined(namePrefix) ? namePrefix : "";
              core.addUnloadHook(onConfigChange(core.config, function(details) {
                var coreConfig = details.cfg;
                _canUseLocalStorage2 = utlCanUseLocalStorage();
                var configMgr = coreConfig.throttleMgrCfg || {};
                objForEachKey(configMgr, function(key, cfg) {
                  _setCfgByKey(parseInt(key), cfg);
                });
              }));
            }
            function _getCfgByKey(msgID) {
              return _config[msgID] || _config[109];
            }
            function _setCfgByKey(msgID, config) {
              var _a2, _b;
              try {
                var cfg = config || {};
                var curCfg = {};
                curCfg.disabled = !!cfg.disabled;
                var configInterval = cfg.interval || {};
                _isSpecificDaysGiven = (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth) && (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth[_DYN_LENGTH]) > 0;
                curCfg.interval = _getIntervalConfig(configInterval);
                var limit = {
                  samplingRate: ((_a2 = cfg.limit) === null || _a2 === void 0 ? void 0 : _a2.samplingRate) || 100,
                  maxSendNumber: ((_b = cfg.limit) === null || _b === void 0 ? void 0 : _b.maxSendNumber) || 1
                };
                curCfg.limit = limit;
                _config[msgID] = curCfg;
              } catch (e) {
              }
            }
            function _getIntervalConfig(interval) {
              interval = interval || {};
              var monthInterval = interval === null || interval === void 0 ? void 0 : interval.monthInterval;
              var dayInterval = interval === null || interval === void 0 ? void 0 : interval.dayInterval;
              if (/* @__PURE__ */ isNullOrUndefined(monthInterval) && /* @__PURE__ */ isNullOrUndefined(dayInterval)) {
                interval.monthInterval = 3;
                if (!_isSpecificDaysGiven) {
                  interval.daysOfMonth = [28];
                  _isSpecificDaysGiven = true;
                }
              }
              interval = {
                monthInterval: interval === null || interval === void 0 ? void 0 : interval.monthInterval,
                dayInterval: interval === null || interval === void 0 ? void 0 : interval.dayInterval,
                daysOfMonth: interval === null || interval === void 0 ? void 0 : interval.daysOfMonth
              };
              return interval;
            }
            function _canThrottle(config, canUseLocalStorage, localStorageObj) {
              if (config && !config.disabled && canUseLocalStorage && isNotNullOrUndefined(localStorageObj)) {
                var curDate = _getThrottleDate();
                var date = localStorageObj.date;
                var interval = config.interval;
                var monthCheck = 1;
                if (interval === null || interval === void 0 ? void 0 : interval.monthInterval) {
                  var monthExpand = (curDate.getUTCFullYear() - date.getUTCFullYear()) * 12 + curDate.getUTCMonth() - date.getUTCMonth();
                  monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);
                }
                var dayCheck = 1;
                if (_isSpecificDaysGiven) {
                  dayCheck = arrIndexOf(interval.daysOfMonth, curDate[_DYN_GET_UTCDATE]());
                } else if (interval === null || interval === void 0 ? void 0 : interval.dayInterval) {
                  var daySpan = mathFloor((curDate.getTime() - date.getTime()) / 864e5);
                  dayCheck = _checkInterval(interval.dayInterval, 0, daySpan);
                }
                return monthCheck >= 0 && dayCheck >= 0;
              }
              return false;
            }
            function _getLocalStorageName(msgKey, prefix) {
              var fix = isNotNullOrUndefined(prefix) ? prefix : "";
              if (msgKey) {
                return THROTTLE_STORAGE_PREFIX + fix + "-" + msgKey;
              }
              return null;
            }
            function _isTriggeredOnCurDate(preTriggerDate) {
              try {
                if (preTriggerDate) {
                  var curDate = /* @__PURE__ */ new Date();
                  return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() && preTriggerDate.getUTCMonth() === curDate.getUTCMonth() && preTriggerDate[_DYN_GET_UTCDATE]() === curDate[_DYN_GET_UTCDATE]();
                }
              } catch (e) {
              }
              return false;
            }
            function _getLocalStorageObj(value, logger2, storageName) {
              try {
                var storageObj = {
                  date: _getThrottleDate(),
                  count: 0
                };
                if (value) {
                  var obj = JSON.parse(value);
                  var curObj = {
                    date: _getThrottleDate(obj.date) || storageObj.date,
                    count: obj[_DYN_COUNT] || storageObj[_DYN_COUNT],
                    preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DYN_PRE_TRIGGER_DATE]) : void 0
                  };
                  return curObj;
                } else {
                  _resetLocalStorage(logger2, storageName, storageObj);
                  return storageObj;
                }
              } catch (e) {
              }
              return null;
            }
            function _getThrottleDate(dateStr) {
              try {
                if (dateStr) {
                  var date = new Date(dateStr);
                  if (!isNaN(date.getDate())) {
                    return date;
                  }
                } else {
                  return /* @__PURE__ */ new Date();
                }
              } catch (e) {
              }
              return null;
            }
            function _resetLocalStorage(logger2, storageName, obj) {
              try {
                return utlSetLocalStorage(logger2, storageName, strTrim(JSON[_DYN_STRINGIFY](obj)));
              } catch (e) {
              }
              return false;
            }
            function _checkInterval(interval, start, current) {
              if (interval <= 0) {
                return 1;
              }
              return current >= start && (current - start) % interval == 0 ? mathFloor((current - start) / interval) + 1 : -1;
            }
            function _sendMessage(msgID, logger2, message, severity) {
              _throwInternal(logger2, severity || 1, msgID, message);
            }
            function _canSampledIn(msgID) {
              try {
                var cfg = _getCfgByKey(msgID);
                return randomValue(1e6) <= cfg.limit.samplingRate;
              } catch (e) {
              }
              return false;
            }
            function _getLocalStorageObjByKey(key) {
              try {
                var curObj = _localStorageObj[key];
                if (!curObj) {
                  var localStorageName = _getLocalStorageName(key, _namePrefix);
                  curObj = _getLocalStorageObj(utlGetLocalStorage(_logger, localStorageName), _logger, localStorageName);
                  _localStorageObj[key] = curObj;
                }
                return _localStorageObj[key];
              } catch (e) {
              }
              return null;
            }
            function _isTrigger(key) {
              var isTrigger = _isTriggered[key];
              if (/* @__PURE__ */ isNullOrUndefined(isTrigger)) {
                isTrigger = false;
                var localStorageObj = _getLocalStorageObjByKey(key);
                if (localStorageObj) {
                  isTrigger = _isTriggeredOnCurDate(localStorageObj[_DYN_PRE_TRIGGER_DATE]);
                }
                _isTriggered[key] = isTrigger;
              }
              return _isTriggered[key];
            }
            function _getQueueByKey(key) {
              _queue = _queue || {};
              if (/* @__PURE__ */ isNullOrUndefined(_queue[key])) {
                _queue[key] = [];
              }
              return _queue[key];
            }
          }
          return ThrottleMgr2;
        }()
      );
      var _FIELDS_SEPARATOR = ";";
      var _FIELD_KEY_VALUE_SEPARATOR = "=";
      function parseConnectionString(connectionString) {
        if (!connectionString) {
          return {};
        }
        var kvPairs = connectionString[_DYN_SPLIT](_FIELDS_SEPARATOR);
        var result = arrReduce(kvPairs, function(fields, kv) {
          var kvParts = kv[_DYN_SPLIT](_FIELD_KEY_VALUE_SEPARATOR);
          if (kvParts[_DYN_LENGTH] === 2) {
            var key = kvParts[0][_DYN_TO_LOWER_CASE]();
            var value = kvParts[1];
            fields[key] = value;
          }
          return fields;
        }, {});
        if (objKeys(result)[_DYN_LENGTH] > 0) {
          if (result.endpointsuffix) {
            var locationPrefix = result.location ? result.location + "." : "";
            result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || "https://" + locationPrefix + "dc." + result.endpointsuffix;
          }
          result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || DEFAULT_BREEZE_ENDPOINT;
          if (strEndsWith(result[_DYN_INGESTIONENDPOINT], "/")) {
            result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT].slice(0, -1);
          }
        }
        return result;
      }
      var ConnectionStringParser = {
        parse: parseConnectionString
      };
      var Envelope = (
        /** @class */
        /* @__PURE__ */ function() {
          function Envelope2(logger2, data, name) {
            var _this = this;
            var _self = this;
            _self.ver = 1;
            _self.sampleRate = 100;
            _self.tags = {};
            _self[_DYN_NAME] = dataSanitizeString(logger2, name) || strNotSpecified;
            _self.data = data;
            _self.time = toISOString(/* @__PURE__ */ new Date());
            _self[_DYN_AI_DATA_CONTRACT] = {
              time: 1,
              iKey: 1,
              name: 1,
              sampleRate: function() {
                return _this.sampleRate === 100 ? 4 : 1;
              },
              tags: 1,
              data: 1
            };
          }
          return Envelope2;
        }()
      );
      var Event$1 = (
        /** @class */
        function() {
          function Event2(logger2, name, properties, measurements) {
            this.aiDataContract = {
              ver: 1,
              name: 1,
              properties: 0,
              measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self[_DYN_NAME] = dataSanitizeString(logger2, name) || strNotSpecified;
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger2, measurements);
          }
          Event2.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
          Event2.dataType = "EventData";
          return Event2;
        }()
      );
      var STACKFRAME_BASE_SIZE = 58;
      var IS_FRAME = /^\s{0,50}(from\s|at\s|Line\s{1,5}\d{1,10}\s{1,5}of|\w{1,50}@\w{1,80}|[^\(\s\n]+:[0-9\?]+(?::[0-9\?]+)?)/;
      var FULL_STACK_FRAME_1 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+):([0-9\?]+)\)?$/;
      var FULL_STACK_FRAME_2 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+)\)?$/;
      var FULL_STACK_FRAME_3 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\)\]]+)\)?$/;
      var EXTRACT_FILENAME = /(?:^|\(|\s{0,10}[\w\)]+\@)?([^\(\n\s\]\)]+)(?:\:([0-9]+)(?:\:([0-9]+))?)?\)?(?:,|$)/;
      var PARSE_FILENAME_LINE_COL = /([^\(\s\n]+):([0-9]+):([0-9]+)$/;
      var PARSE_FILENAME_LINE_ONLY = /([^\(\s\n]+):([0-9]+)$/;
      var NoMethod = "<no_method>";
      var strError = "error";
      var strStack = "stack";
      var strStackDetails = "stackDetails";
      var strErrorSrc = "errorSrc";
      var strMessage = "message";
      var strDescription = "description";
      var _parseSequence = [
        { re: FULL_STACK_FRAME_1, len: 5, m: 1, fn: 2, ln: 3, col: 4 },
        { chk: _ignoreNative, pre: _scrubAnonymous, re: FULL_STACK_FRAME_2, len: 4, m: 1, fn: 2, ln: 3 },
        { re: FULL_STACK_FRAME_3, len: 3, m: 1, fn: 2, hdl: _handleFilename },
        { re: EXTRACT_FILENAME, len: 2, fn: 1, hdl: _handleFilename }
      ];
      function _scrubAnonymous(frame) {
        return frame.replace(/(\(anonymous\))/, "<anonymous>");
      }
      function _ignoreNative(frame) {
        return strIndexOf(frame, "[native") < 0;
      }
      function _stringify(value, convertToString) {
        var result = value;
        if (result && !isString(result)) {
          if (JSON && JSON[_DYN_STRINGIFY]) {
            result = JSON[_DYN_STRINGIFY](value);
            if (convertToString && (!result || result === "{}")) {
              if (isFunction(value[_DYN_TO_STRING])) {
                result = value[_DYN_TO_STRING]();
              } else {
                result = "" + value;
              }
            }
          } else {
            result = "" + value + " - (Missing JSON.stringify)";
          }
        }
        return result || "";
      }
      function _formatMessage(theEvent, errorType) {
        var evtMessage = theEvent;
        if (theEvent) {
          if (evtMessage && !isString(evtMessage)) {
            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;
          }
          if (evtMessage && !isString(evtMessage)) {
            evtMessage = _stringify(evtMessage, true);
          }
          if (theEvent["filename"]) {
            evtMessage = evtMessage + " @" + (theEvent["filename"] || "") + ":" + (theEvent["lineno"] || "?") + ":" + (theEvent["colno"] || "?");
          }
        }
        if (errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1) {
          evtMessage = errorType + ": " + evtMessage;
        }
        return evtMessage || "";
      }
      function _isExceptionDetailsInternal(value) {
        try {
          if (/* @__PURE__ */ isObject(value)) {
            return "hasFullStack" in value && "typeName" in value;
          }
        } catch (e) {
        }
        return false;
      }
      function _isExceptionInternal(value) {
        try {
          if (/* @__PURE__ */ isObject(value)) {
            return "ver" in value && "exceptions" in value && "properties" in value;
          }
        } catch (e) {
        }
        return false;
      }
      function _isStackDetails(details) {
        return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
      }
      function _convertStackObj(errorStack) {
        var src = errorStack || "";
        if (!isString(src)) {
          if (isString(src[strStack])) {
            src = src[strStack];
          } else {
            src = "" + src;
          }
        }
        var items = src[_DYN_SPLIT]("\n");
        return {
          src,
          obj: items
        };
      }
      function _getOperaStack(errorMessage) {
        var stack = [];
        var lines = errorMessage[_DYN_SPLIT]("\n");
        for (var lp = 0; lp < lines[_DYN_LENGTH]; lp++) {
          var entry = lines[lp];
          if (lines[lp + 1]) {
            entry += "@" + lines[lp + 1];
            lp++;
          }
          stack.push(entry);
        }
        return {
          src: errorMessage,
          obj: stack
        };
      }
      function _getStackFromErrorObj(errorObj) {
        var details = null;
        if (errorObj) {
          try {
            if (errorObj[strStack]) {
              details = _convertStackObj(errorObj[strStack]);
            } else if (errorObj[strError] && errorObj[strError][strStack]) {
              details = _convertStackObj(errorObj[strError][strStack]);
            } else if (errorObj["exception"] && errorObj.exception[strStack]) {
              details = _convertStackObj(errorObj.exception[strStack]);
            } else if (_isStackDetails(errorObj)) {
              details = errorObj;
            } else if (_isStackDetails(errorObj[strStackDetails])) {
              details = errorObj[strStackDetails];
            } else if (getWindow() && getWindow()["opera"] && errorObj[strMessage]) {
              details = _getOperaStack(errorObj[_DYN_MESSAGE]);
            } else if (errorObj["reason"] && errorObj.reason[strStack]) {
              details = _convertStackObj(errorObj.reason[strStack]);
            } else if (isString(errorObj)) {
              details = _convertStackObj(errorObj);
            } else {
              var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
              if (isString(errorObj[strErrorSrc])) {
                if (evtMessage) {
                  evtMessage += "\n";
                }
                evtMessage += " from " + errorObj[strErrorSrc];
              }
              if (evtMessage) {
                details = _convertStackObj(evtMessage);
              }
            }
          } catch (e) {
            details = _convertStackObj(e);
          }
        }
        return details || {
          src: "",
          obj: null
        };
      }
      function _formatStackTrace(stackDetails) {
        var stack = "";
        if (stackDetails) {
          if (stackDetails.obj) {
            stack = stackDetails.obj.join("\n");
          } else {
            stack = stackDetails.src || "";
          }
        }
        return stack;
      }
      function _parseStack(stack) {
        var parsedStack;
        var frames = stack.obj;
        if (frames && frames[_DYN_LENGTH] > 0) {
          parsedStack = [];
          var level_1 = 0;
          var foundStackStart_1 = false;
          var totalSizeInBytes_1 = 0;
          arrForEach(frames, function(frame) {
            if (foundStackStart_1 || _isStackFrame(frame)) {
              var theFrame = asString(frame);
              foundStackStart_1 = true;
              var parsedFrame = _extractStackFrame(theFrame, level_1);
              if (parsedFrame) {
                totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES];
                parsedStack.push(parsedFrame);
                level_1++;
              }
            }
          });
          var exceptionParsedStackThreshold = 32 * 1024;
          if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {
            var left = 0;
            var right = parsedStack[_DYN_LENGTH] - 1;
            var size = 0;
            var acceptedLeft = left;
            var acceptedRight = right;
            while (left < right) {
              var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES];
              var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES];
              size += lSize + rSize;
              if (size > exceptionParsedStackThreshold) {
                var howMany = acceptedRight - acceptedLeft + 1;
                parsedStack.splice(acceptedLeft, howMany);
                break;
              }
              acceptedLeft = left;
              acceptedRight = right;
              left++;
              right--;
            }
          }
        }
        return parsedStack;
      }
      function _getErrorType(errorType) {
        var typeName = "";
        if (errorType) {
          typeName = errorType.typeName || errorType[_DYN_NAME] || "";
          if (!typeName) {
            try {
              var funcNameRegex = /function (.{1,200})\(/;
              var results = funcNameRegex.exec(errorType.constructor[_DYN_TO_STRING]());
              typeName = results && results[_DYN_LENGTH] > 1 ? results[1] : "";
            } catch (e) {
            }
          }
        }
        return typeName;
      }
      function _formatErrorCode(errorObj) {
        if (errorObj) {
          try {
            if (!isString(errorObj)) {
              var errorType = _getErrorType(errorObj);
              var result = _stringify(errorObj, false);
              if (!result || result === "{}") {
                if (errorObj[strError]) {
                  errorObj = errorObj[strError];
                  errorType = _getErrorType(errorObj);
                }
                result = _stringify(errorObj, true);
              }
              if (strIndexOf(result, errorType) !== 0 && errorType !== "String") {
                return errorType + ":" + result;
              }
              return result;
            }
          } catch (e) {
          }
        }
        return "" + (errorObj || "");
      }
      var Exception = (
        /** @class */
        function() {
          function Exception2(logger2, exception, properties, measurements, severityLevel, id) {
            this.aiDataContract = {
              ver: 1,
              exceptions: 1,
              severityLevel: 0,
              properties: 0,
              measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            if (!_isExceptionInternal(exception)) {
              if (!properties) {
                properties = {};
              }
              if (id) {
                properties.id = id;
              }
              _self[_DYN_EXCEPTIONS] = [_createExceptionDetails(logger2, exception, properties)];
              _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
              _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger2, measurements);
              if (severityLevel) {
                _self[_DYN_SEVERITY_LEVEL] = severityLevel;
              }
              if (id) {
                _self.id = id;
              }
            } else {
              _self[_DYN_EXCEPTIONS] = exception[_DYN_EXCEPTIONS] || [];
              _self[_DYN_PROPERTIES] = exception[_DYN_PROPERTIES];
              _self[_DYN_MEASUREMENTS] = exception[_DYN_MEASUREMENTS];
              if (exception[_DYN_SEVERITY_LEVEL]) {
                _self[_DYN_SEVERITY_LEVEL] = exception[_DYN_SEVERITY_LEVEL];
              }
              if (exception.id) {
                _self.id = exception.id;
                exception[_DYN_PROPERTIES].id = exception.id;
              }
              if (exception[_DYN_PROBLEM_GROUP]) {
                _self[_DYN_PROBLEM_GROUP] = exception[_DYN_PROBLEM_GROUP];
              }
              if (!/* @__PURE__ */ isNullOrUndefined(exception.isManual)) {
                _self.isManual = exception.isManual;
              }
            }
          }
          Exception2.CreateAutoException = function(message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
            var errorType = _getErrorType(error || evt || message);
            return {
              message: _formatMessage(message, errorType),
              url,
              lineNumber,
              columnNumber,
              error: _formatErrorCode(error || evt || message),
              evt: _formatErrorCode(evt || message),
              typeName: errorType,
              stackDetails: _getStackFromErrorObj(stack || error || evt),
              errorSrc
            };
          };
          Exception2.CreateFromInterface = function(logger2, exception, properties, measurements) {
            var exceptions = exception[_DYN_EXCEPTIONS] && arrMap(exception[_DYN_EXCEPTIONS], function(ex) {
              return _createExDetailsFromInterface(logger2, ex);
            });
            var exceptionData = new Exception2(logger2, __assignFn(__assignFn({}, exception), { exceptions }), properties, measurements);
            return exceptionData;
          };
          Exception2.prototype.toInterface = function() {
            var _a2 = this, exceptions = _a2.exceptions, properties = _a2.properties, measurements = _a2.measurements, severityLevel = _a2.severityLevel, problemGroup = _a2.problemGroup, id = _a2.id, isManual = _a2.isManual;
            var exceptionDetailsInterface = exceptions instanceof Array && arrMap(exceptions, function(exception) {
              return exception.toInterface();
            }) || void 0;
            return {
              ver: "4.0",
              exceptions: exceptionDetailsInterface,
              severityLevel,
              properties,
              measurements,
              problemGroup,
              id,
              isManual
            };
          };
          Exception2.CreateSimpleException = function(message, typeName, assembly, fileName, details, line) {
            var _a2;
            return {
              exceptions: [
                (_a2 = {}, _a2[_DYN_HAS_FULL_STACK] = true, _a2.message = message, _a2.stack = details, _a2.typeName = typeName, _a2)
              ]
            };
          };
          Exception2.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
          Exception2.dataType = "ExceptionData";
          Exception2.formatError = _formatErrorCode;
          return Exception2;
        }()
      );
      var exDetailsAiDataContract = objFreeze({
        id: 0,
        outerId: 0,
        typeName: 1,
        message: 1,
        hasFullStack: 0,
        stack: 0,
        parsedStack: 2
      });
      function _toInterface() {
        var _self = this;
        var parsedStack = isArray(_self[_DYN_PARSED_STACK]) && arrMap(_self[_DYN_PARSED_STACK], function(frame) {
          return _parsedFrameToInterface(frame);
        });
        var exceptionDetailsInterface = {
          id: _self.id,
          outerId: _self.outerId,
          typeName: _self[_DYN_TYPE_NAME],
          message: _self[_DYN_MESSAGE],
          hasFullStack: _self[_DYN_HAS_FULL_STACK],
          stack: _self[strStack],
          parsedStack: parsedStack || void 0
        };
        return exceptionDetailsInterface;
      }
      function _createExceptionDetails(logger2, exception, properties) {
        var _a2;
        var id;
        var outerId;
        var typeName;
        var message;
        var hasFullStack;
        var theStack;
        var parsedStack;
        if (!_isExceptionDetailsInternal(exception)) {
          var error = exception;
          var evt = error && error.evt;
          if (!isError(error)) {
            error = error[strError] || evt || error;
          }
          typeName = dataSanitizeString(logger2, _getErrorType(error)) || strNotSpecified;
          message = dataSanitizeMessage(logger2, _formatMessage(exception || error, typeName)) || strNotSpecified;
          var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
          parsedStack = _parseStack(stack);
          if (isArray(parsedStack)) {
            arrMap(parsedStack, function(frame) {
              frame[_DYN_ASSEMBLY] = dataSanitizeString(logger2, frame[_DYN_ASSEMBLY]);
              frame[_DYN_FILE_NAME] = dataSanitizeString(logger2, frame[_DYN_FILE_NAME]);
            });
          }
          theStack = dataSanitizeException(logger2, _formatStackTrace(stack));
          hasFullStack = isArray(parsedStack) && parsedStack[_DYN_LENGTH] > 0;
          if (properties) {
            properties[_DYN_TYPE_NAME] = properties[_DYN_TYPE_NAME] || typeName;
          }
        } else {
          typeName = exception[_DYN_TYPE_NAME];
          message = exception[_DYN_MESSAGE];
          theStack = exception[strStack];
          parsedStack = exception[_DYN_PARSED_STACK] || [];
          hasFullStack = exception[_DYN_HAS_FULL_STACK];
        }
        return _a2 = {}, _a2[_DYN_AI_DATA_CONTRACT] = exDetailsAiDataContract, _a2.id = id, _a2.outerId = outerId, _a2.typeName = typeName, _a2.message = message, _a2[_DYN_HAS_FULL_STACK] = hasFullStack, _a2.stack = theStack, _a2.parsedStack = parsedStack, _a2.toInterface = _toInterface, _a2;
      }
      function _createExDetailsFromInterface(logger2, exception) {
        var parsedStack = isArray(exception[_DYN_PARSED_STACK]) && arrMap(exception[_DYN_PARSED_STACK], function(frame) {
          return _stackFrameFromInterface(frame);
        }) || exception[_DYN_PARSED_STACK];
        var exceptionDetails = _createExceptionDetails(logger2, __assignFn(__assignFn({}, exception), { parsedStack }));
        return exceptionDetails;
      }
      function _parseFilename(theFrame, fileName) {
        var lineCol = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_COL);
        if (lineCol && lineCol[_DYN_LENGTH] >= 4) {
          theFrame[_DYN_FILE_NAME] = lineCol[1];
          theFrame[_DYN_LINE] = parseInt(lineCol[2]);
        } else {
          var lineNo = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_ONLY);
          if (lineNo && lineNo[_DYN_LENGTH] >= 3) {
            theFrame[_DYN_FILE_NAME] = lineNo[1];
            theFrame[_DYN_LINE] = parseInt(lineNo[2]);
          } else {
            theFrame[_DYN_FILE_NAME] = fileName;
          }
        }
      }
      function _handleFilename(theFrame, sequence, matches) {
        var filename = theFrame[_DYN_FILE_NAME];
        if (sequence.fn && matches && matches[_DYN_LENGTH] > sequence.fn) {
          if (sequence.ln && matches[_DYN_LENGTH] > sequence.ln) {
            filename = strTrim(matches[sequence.fn] || "");
            theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0;
          } else {
            filename = strTrim(matches[sequence.fn] || "");
          }
        }
        if (filename) {
          _parseFilename(theFrame, filename);
        }
      }
      function _isStackFrame(frame) {
        var result = false;
        if (frame && isString(frame)) {
          var trimmedFrame = strTrim(frame);
          if (trimmedFrame) {
            result = IS_FRAME.test(trimmedFrame);
          }
        }
        return result;
      }
      var stackFrameAiDataContract = objFreeze({
        level: 1,
        method: 1,
        assembly: 0,
        fileName: 0,
        line: 0
      });
      function _extractStackFrame(frame, level) {
        var _a2;
        var theFrame;
        if (frame && isString(frame) && strTrim(frame)) {
          theFrame = (_a2 = {}, _a2[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a2.level = level, _a2.assembly = strTrim(frame), _a2.method = NoMethod, _a2.fileName = "", _a2.line = 0, _a2.sizeInBytes = 0, _a2);
          var idx = 0;
          while (idx < _parseSequence[_DYN_LENGTH]) {
            var sequence = _parseSequence[idx];
            if (sequence.chk && !sequence.chk(frame)) {
              break;
            }
            if (sequence.pre) {
              frame = sequence.pre(frame);
            }
            var matches = frame[_DYN_MATCH](sequence.re);
            if (matches && matches[_DYN_LENGTH] >= sequence.len) {
              if (sequence.m) {
                theFrame.method = strTrim(matches[sequence.m] || NoMethod);
              }
              if (sequence.hdl) {
                sequence.hdl(theFrame, sequence, matches);
              } else if (sequence.fn) {
                if (sequence.ln) {
                  theFrame[_DYN_FILE_NAME] = strTrim(matches[sequence.fn] || "");
                  theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0;
                } else {
                  _parseFilename(theFrame, matches[sequence.fn] || "");
                }
              }
              break;
            }
            idx++;
          }
        }
        return _populateFrameSizeInBytes(theFrame);
      }
      function _stackFrameFromInterface(frame) {
        var _a2;
        var parsedFrame = (_a2 = {}, _a2[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a2.level = frame.level, _a2.method = frame.method, _a2.assembly = frame[_DYN_ASSEMBLY], _a2.fileName = frame[_DYN_FILE_NAME], _a2.line = frame[_DYN_LINE], _a2.sizeInBytes = 0, _a2);
        return _populateFrameSizeInBytes(parsedFrame);
      }
      function _populateFrameSizeInBytes(frame) {
        var sizeInBytes = STACKFRAME_BASE_SIZE;
        if (frame) {
          sizeInBytes += frame.method[_DYN_LENGTH];
          sizeInBytes += frame.assembly[_DYN_LENGTH];
          sizeInBytes += frame.fileName[_DYN_LENGTH];
          sizeInBytes += frame.level.toString()[_DYN_LENGTH];
          sizeInBytes += frame.line.toString()[_DYN_LENGTH];
          frame[_DYN_SIZE_IN_BYTES] = sizeInBytes;
        }
        return frame;
      }
      function _parsedFrameToInterface(frame) {
        return {
          level: frame.level,
          method: frame.method,
          assembly: frame[_DYN_ASSEMBLY],
          fileName: frame[_DYN_FILE_NAME],
          line: frame[_DYN_LINE]
        };
      }
      var DataPoint = (
        /** @class */
        /* @__PURE__ */ function() {
          function DataPoint2() {
            this.aiDataContract = {
              name: 1,
              kind: 0,
              value: 1,
              count: 0,
              min: 0,
              max: 0,
              stdDev: 0
            };
            this.kind = 0;
          }
          return DataPoint2;
        }()
      );
      var Metric = (
        /** @class */
        function() {
          function Metric2(logger2, name, value, count, min, max, stdDev, properties, measurements) {
            this.aiDataContract = {
              ver: 1,
              metrics: 1,
              properties: 0
            };
            var _self = this;
            _self.ver = 2;
            var dataPoint = new DataPoint();
            dataPoint[_DYN_COUNT] = count > 0 ? count : void 0;
            dataPoint.max = isNaN(max) || max === null ? void 0 : max;
            dataPoint.min = isNaN(min) || min === null ? void 0 : min;
            dataPoint[_DYN_NAME] = dataSanitizeString(logger2, name) || strNotSpecified;
            dataPoint.value = value;
            dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? void 0 : stdDev;
            _self.metrics = [dataPoint];
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger2, measurements);
          }
          Metric2.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
          Metric2.dataType = "MetricData";
          return Metric2;
        }()
      );
      var strEmpty = "";
      function stringToBoolOrDefault(str, defaultValue) {
        if (defaultValue === void 0) {
          defaultValue = false;
        }
        if (str === void 0 || str === null) {
          return defaultValue;
        }
        return str.toString()[_DYN_TO_LOWER_CASE]() === "true";
      }
      function msToTimeSpan(totalms) {
        if (isNaN(totalms) || totalms < 0) {
          totalms = 0;
        }
        totalms = mathRound(totalms);
        var ms = strEmpty + totalms % 1e3;
        var sec = strEmpty + mathFloor(totalms / 1e3) % 60;
        var min = strEmpty + mathFloor(totalms / (1e3 * 60)) % 60;
        var hour = strEmpty + mathFloor(totalms / (1e3 * 60 * 60)) % 24;
        var days = mathFloor(totalms / (1e3 * 60 * 60 * 24));
        ms = ms[_DYN_LENGTH] === 1 ? "00" + ms : ms[_DYN_LENGTH] === 2 ? "0" + ms : ms;
        sec = sec[_DYN_LENGTH] < 2 ? "0" + sec : sec;
        min = min[_DYN_LENGTH] < 2 ? "0" + min : min;
        hour = hour[_DYN_LENGTH] < 2 ? "0" + hour : hour;
        return (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
      }
      function getExtensionByName(extensions3, identifier) {
        var extension = null;
        arrForEach(extensions3, function(value) {
          if (value.identifier === identifier) {
            extension = value;
            return -1;
          }
        });
        return extension;
      }
      function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
        return !error && isString(message) && (message === "Script error." || message === "Script error");
      }
      var PageView = (
        /** @class */
        function() {
          function PageView2(logger2, name, url, durationMs, properties, measurements, id) {
            this.aiDataContract = {
              ver: 1,
              name: 0,
              url: 0,
              duration: 0,
              properties: 0,
              measurements: 0,
              id: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = dataSanitizeId(logger2, id);
            _self.url = dataSanitizeUrl(logger2, url);
            _self[_DYN_NAME] = dataSanitizeString(logger2, name) || strNotSpecified;
            if (!isNaN(durationMs)) {
              _self[_DYN_DURATION] = msToTimeSpan(durationMs);
            }
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger2, measurements);
          }
          PageView2.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
          PageView2.dataType = "PageviewData";
          return PageView2;
        }()
      );
      var RemoteDependencyData = (
        /** @class */
        function() {
          function RemoteDependencyData2(logger2, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
            if (requestAPI === void 0) {
              requestAPI = "Ajax";
            }
            this.aiDataContract = {
              id: 1,
              ver: 1,
              name: 0,
              resultCode: 0,
              duration: 0,
              success: 0,
              data: 0,
              target: 0,
              type: 0,
              properties: 0,
              measurements: 0,
              kind: 0,
              value: 0,
              count: 0,
              min: 0,
              max: 0,
              stdDev: 0,
              dependencyKind: 0,
              dependencySource: 0,
              commandName: 0,
              dependencyTypeName: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = id;
            _self[_DYN_DURATION] = msToTimeSpan(value);
            _self.success = success;
            _self.resultCode = resultCode + "";
            _self.type = dataSanitizeString(logger2, requestAPI);
            var dependencyFields = AjaxHelperParseDependencyPath(logger2, absoluteUrl, method, commandName);
            _self.data = dataSanitizeUrl(logger2, commandName) || dependencyFields.data;
            _self.target = dataSanitizeString(logger2, dependencyFields.target);
            if (correlationContext) {
              _self.target = "".concat(_self.target, " | ").concat(correlationContext);
            }
            _self[_DYN_NAME] = dataSanitizeString(logger2, dependencyFields[_DYN_NAME]);
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger2, measurements);
          }
          RemoteDependencyData2.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
          RemoteDependencyData2.dataType = "RemoteDependencyData";
          return RemoteDependencyData2;
        }()
      );
      var Trace = (
        /** @class */
        function() {
          function Trace2(logger2, message, severityLevel, properties, measurements) {
            this.aiDataContract = {
              ver: 1,
              message: 1,
              severityLevel: 0,
              properties: 0
            };
            var _self = this;
            _self.ver = 2;
            message = message || strNotSpecified;
            _self[_DYN_MESSAGE] = dataSanitizeMessage(logger2, message);
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger2, measurements);
            if (severityLevel) {
              _self[_DYN_SEVERITY_LEVEL] = severityLevel;
            }
          }
          Trace2.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
          Trace2.dataType = "MessageData";
          return Trace2;
        }()
      );
      var PageViewPerformance = (
        /** @class */
        function() {
          function PageViewPerformance2(logger2, name, url, unused, properties, measurements, cs4BaseData) {
            this.aiDataContract = {
              ver: 1,
              name: 0,
              url: 0,
              duration: 0,
              perfTotal: 0,
              networkConnect: 0,
              sentRequest: 0,
              receivedResponse: 0,
              domProcessing: 0,
              properties: 0,
              measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.url = dataSanitizeUrl(logger2, url);
            _self[_DYN_NAME] = dataSanitizeString(logger2, name) || strNotSpecified;
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger2, measurements);
            if (cs4BaseData) {
              _self.domProcessing = cs4BaseData.domProcessing;
              _self[_DYN_DURATION] = cs4BaseData[_DYN_DURATION];
              _self.networkConnect = cs4BaseData.networkConnect;
              _self.perfTotal = cs4BaseData.perfTotal;
              _self.receivedResponse = cs4BaseData.receivedResponse;
              _self.sentRequest = cs4BaseData.sentRequest;
            }
          }
          PageViewPerformance2.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
          PageViewPerformance2.dataType = "PageviewPerformanceData";
          return PageViewPerformance2;
        }()
      );
      var Data = (
        /** @class */
        /* @__PURE__ */ function() {
          function Data2(baseType, data) {
            this.aiDataContract = {
              baseType: 1,
              baseData: 1
            };
            this.baseType = baseType;
            this.baseData = data;
          }
          return Data2;
        }()
      );
      var SeverityLevel = createEnumStyle({
        Verbose: 0,
        Information: 1,
        Warning: 2,
        Error: 3,
        Critical: 4
      });
      var ConfigurationManager = (
        /** @class */
        function() {
          function ConfigurationManager2() {
          }
          ConfigurationManager2.getConfig = function(config, field, identifier, defaultValue) {
            if (defaultValue === void 0) {
              defaultValue = false;
            }
            var configValue;
            if (identifier && config[_DYN_EXTENSION_CONFIG] && config[_DYN_EXTENSION_CONFIG][identifier] && !/* @__PURE__ */ isNullOrUndefined(config[_DYN_EXTENSION_CONFIG][identifier][field])) {
              configValue = config[_DYN_EXTENSION_CONFIG][identifier][field];
            } else {
              configValue = config[field];
            }
            return !/* @__PURE__ */ isNullOrUndefined(configValue) ? configValue : defaultValue;
          };
          return ConfigurationManager2;
        }()
      );
      function _aiNameFunc(baseName) {
        var aiName = "ai." + baseName + ".";
        return function(name) {
          return aiName + name;
        };
      }
      var _aiApplication = _aiNameFunc("application");
      var _aiDevice = _aiNameFunc("device");
      var _aiLocation = _aiNameFunc("location");
      var _aiOperation = _aiNameFunc("operation");
      var _aiSession = _aiNameFunc("session");
      var _aiUser = _aiNameFunc("user");
      var _aiCloud = _aiNameFunc("cloud");
      var _aiInternal = _aiNameFunc("internal");
      var ContextTagKeys = (
        /** @class */
        function(_super) {
          __extendsFn(ContextTagKeys2, _super);
          function ContextTagKeys2() {
            return _super.call(this) || this;
          }
          return ContextTagKeys2;
        }(createClassFromInterface({
          applicationVersion: _aiApplication("ver"),
          applicationBuild: _aiApplication("build"),
          applicationTypeId: _aiApplication("typeId"),
          applicationId: _aiApplication("applicationId"),
          applicationLayer: _aiApplication("layer"),
          deviceId: _aiDevice("id"),
          deviceIp: _aiDevice("ip"),
          deviceLanguage: _aiDevice("language"),
          deviceLocale: _aiDevice("locale"),
          deviceModel: _aiDevice("model"),
          deviceFriendlyName: _aiDevice("friendlyName"),
          deviceNetwork: _aiDevice("network"),
          deviceNetworkName: _aiDevice("networkName"),
          deviceOEMName: _aiDevice("oemName"),
          deviceOS: _aiDevice("os"),
          deviceOSVersion: _aiDevice("osVersion"),
          deviceRoleInstance: _aiDevice("roleInstance"),
          deviceRoleName: _aiDevice("roleName"),
          deviceScreenResolution: _aiDevice("screenResolution"),
          deviceType: _aiDevice("type"),
          deviceMachineName: _aiDevice("machineName"),
          deviceVMName: _aiDevice("vmName"),
          deviceBrowser: _aiDevice("browser"),
          deviceBrowserVersion: _aiDevice("browserVersion"),
          locationIp: _aiLocation("ip"),
          locationCountry: _aiLocation("country"),
          locationProvince: _aiLocation("province"),
          locationCity: _aiLocation("city"),
          operationId: _aiOperation("id"),
          operationName: _aiOperation("name"),
          operationParentId: _aiOperation("parentId"),
          operationRootId: _aiOperation("rootId"),
          operationSyntheticSource: _aiOperation("syntheticSource"),
          operationCorrelationVector: _aiOperation("correlationVector"),
          sessionId: _aiSession("id"),
          sessionIsFirst: _aiSession("isFirst"),
          sessionIsNew: _aiSession("isNew"),
          userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
          userAccountId: _aiUser("accountId"),
          userAgent: _aiUser("userAgent"),
          userId: _aiUser("id"),
          userStoreRegion: _aiUser("storeRegion"),
          userAuthUserId: _aiUser("authUserId"),
          userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
          userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
          cloudName: _aiCloud("name"),
          cloudRole: _aiCloud("role"),
          cloudRoleVer: _aiCloud("roleVer"),
          cloudRoleInstance: _aiCloud("roleInstance"),
          cloudEnvironment: _aiCloud("environment"),
          cloudLocation: _aiCloud("location"),
          cloudDeploymentUnit: _aiCloud("deploymentUnit"),
          internalNodeName: _aiInternal("nodeName"),
          internalSdkVersion: _aiInternal("sdkVersion"),
          internalAgentVersion: _aiInternal("agentVersion"),
          internalSnippet: _aiInternal("snippet"),
          internalSdkSrc: _aiInternal("sdkSrc")
        }))
      );
      function createTelemetryItem(item, baseType, envelopeName, logger2, customProperties, systemProperties) {
        envelopeName = dataSanitizeString(logger2, envelopeName) || strNotSpecified;
        if (/* @__PURE__ */ isNullOrUndefined(item) || /* @__PURE__ */ isNullOrUndefined(baseType) || /* @__PURE__ */ isNullOrUndefined(envelopeName)) {
          throwError("Input doesn't contain all required fields");
        }
        var iKey = "";
        if (item[strIkey]) {
          iKey = item[strIkey];
          delete item[strIkey];
        }
        var telemetryItem = {
          name: envelopeName,
          time: toISOString(/* @__PURE__ */ new Date()),
          iKey,
          ext: systemProperties ? systemProperties : {},
          tags: [],
          data: {},
          baseType,
          baseData: item
        };
        if (!/* @__PURE__ */ isNullOrUndefined(customProperties)) {
          objForEachKey(customProperties, function(prop, value) {
            telemetryItem.data[prop] = value;
          });
        }
        return telemetryItem;
      }
      var TelemetryItemCreator = (
        /** @class */
        function() {
          function TelemetryItemCreator2() {
          }
          TelemetryItemCreator2.create = createTelemetryItem;
          return TelemetryItemCreator2;
        }()
      );
      var Extensions = {
        UserExt: "user",
        DeviceExt: "device",
        TraceExt: "trace",
        WebExt: "web",
        AppExt: "app",
        OSExt: "os",
        SessionExt: "ses",
        SDKExt: "sdk"
      };
      var CtxTagKeys = new ContextTagKeys();
      function createDomEvent(eventName) {
        var event = null;
        if (isFunction(Event)) {
          event = new Event(eventName);
        } else {
          var doc = getDocument();
          if (doc && doc.createEvent) {
            event = doc.createEvent("Event");
            event.initEvent(eventName, true, true);
          }
        }
        return event;
      }
      function _disableEvents(target, evtNamespace) {
        eventOff(target, null, null, evtNamespace);
      }
      function createOfflineListener(parentEvtNamespace) {
        var _document2 = getDocument();
        var _navigator = getNavigator();
        var _isListening = false;
        var listenerList = [];
        var rState = 1;
        if (_navigator && !/* @__PURE__ */ isNullOrUndefined(_navigator.onLine) && !_navigator.onLine) {
          rState = 2;
        }
        var uState = 0;
        var _currentState = calCurrentState();
        var _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
        try {
          if (_enableEvents(getWindow())) {
            _isListening = true;
          }
          if (_document2) {
            var target = _document2.body || _document2;
            if (target.ononline) {
              if (_enableEvents(target)) {
                _isListening = true;
              }
            }
          }
        } catch (e) {
          _isListening = false;
        }
        function _enableEvents(target2) {
          var enabled = false;
          if (target2) {
            enabled = eventOn(target2, "online", _setOnline, _evtNamespace);
            if (enabled) {
              eventOn(target2, "offline", _setOffline, _evtNamespace);
            }
          }
          return enabled;
        }
        function _isOnline() {
          return _currentState;
        }
        function calCurrentState() {
          if (uState === 2 || rState === 2) {
            return false;
          }
          return true;
        }
        function listnerNoticeCheck() {
          var newState = calCurrentState();
          if (_currentState !== newState) {
            _currentState = newState;
            arrForEach(listenerList, function(callback) {
              var offlineState = {
                isOnline: _currentState,
                rState,
                uState
              };
              try {
                callback(offlineState);
              } catch (e) {
              }
            });
          }
        }
        function setOnlineState(newState) {
          uState = newState;
          listnerNoticeCheck();
        }
        function _setOnline() {
          rState = 1;
          listnerNoticeCheck();
        }
        function _setOffline() {
          rState = 2;
          listnerNoticeCheck();
        }
        function _unload() {
          var win = getWindow();
          if (win && _isListening) {
            _disableEvents(win, _evtNamespace);
            if (_document2) {
              var target2 = _document2.body || _document2;
              if (!/* @__PURE__ */ isUndefined(target2.ononline)) {
                _disableEvents(target2, _evtNamespace);
              }
            }
            _isListening = false;
          }
        }
        function addListener(callback) {
          listenerList.push(callback);
          return {
            rm: function() {
              var index = listenerList.indexOf(callback);
              if (index > -1) {
                return listenerList.splice(index, 1);
              } else {
                return;
              }
            }
          };
        }
        return {
          isOnline: _isOnline,
          isListening: function() {
            return _isListening;
          },
          unload: _unload,
          addListener,
          setOnlineState
        };
      }
      var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin";
      var BreezeChannelIdentifier = "AppInsightsChannelPlugin";
      var AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";
      exports3.AnalyticsPluginIdentifier = AnalyticsPluginIdentifier;
      exports3.BreezeChannelIdentifier = BreezeChannelIdentifier;
      exports3.ConfigurationManager = ConfigurationManager;
      exports3.ConnectionStringParser = ConnectionStringParser;
      exports3.ContextTagKeys = ContextTagKeys;
      exports3.CtxTagKeys = CtxTagKeys;
      exports3.DEFAULT_BREEZE_ENDPOINT = DEFAULT_BREEZE_ENDPOINT;
      exports3.DEFAULT_BREEZE_PATH = DEFAULT_BREEZE_PATH;
      exports3.Data = Data;
      exports3.DisabledPropertyName = DisabledPropertyName;
      exports3.DistributedTracingModes = DistributedTracingModes;
      exports3.Envelope = Envelope;
      exports3.Event = Event$1;
      exports3.EventPersistence = EventPersistence;
      exports3.Exception = Exception;
      exports3.Extensions = Extensions;
      exports3.HttpMethod = HttpMethod;
      exports3.Metric = Metric;
      exports3.PageView = PageView;
      exports3.PageViewPerformance = PageViewPerformance;
      exports3.ProcessLegacy = ProcessLegacy;
      exports3.PropertiesPluginIdentifier = PropertiesPluginIdentifier;
      exports3.RemoteDependencyData = RemoteDependencyData;
      exports3.RequestHeaders = RequestHeaders;
      exports3.SampleRate = SampleRate;
      exports3.SeverityLevel = SeverityLevel;
      exports3.TelemetryItemCreator = TelemetryItemCreator;
      exports3.ThrottleMgr = ThrottleMgr;
      exports3.Trace = Trace;
      exports3.correlationIdCanIncludeCorrelationHeader = correlationIdCanIncludeCorrelationHeader;
      exports3.correlationIdGetCorrelationContext = correlationIdGetCorrelationContext;
      exports3.correlationIdGetCorrelationContextValue = correlationIdGetCorrelationContextValue;
      exports3.correlationIdGetPrefix = correlationIdGetPrefix;
      exports3.correlationIdSetPrefix = correlationIdSetPrefix;
      exports3.createDistributedTraceContextFromTrace = createDistributedTraceContextFromTrace;
      exports3.createDomEvent = createDomEvent;
      exports3.createOfflineListener = createOfflineListener;
      exports3.createTelemetryItem = createTelemetryItem;
      exports3.createTraceParent = createTraceParent;
      exports3.dataSanitizeException = dataSanitizeException;
      exports3.dataSanitizeId = dataSanitizeId;
      exports3.dataSanitizeInput = dataSanitizeInput;
      exports3.dataSanitizeKey = dataSanitizeKey;
      exports3.dataSanitizeKeyAndAddUniqueness = dataSanitizeKeyAndAddUniqueness;
      exports3.dataSanitizeMeasurements = dataSanitizeMeasurements;
      exports3.dataSanitizeMessage = dataSanitizeMessage;
      exports3.dataSanitizeProperties = dataSanitizeProperties;
      exports3.dataSanitizeString = dataSanitizeString;
      exports3.dataSanitizeUrl = dataSanitizeUrl;
      exports3.dateTimeUtilsDuration = dateTimeUtilsDuration;
      exports3.dateTimeUtilsNow = dateTimeUtilsNow;
      exports3.dsPadNumber = dsPadNumber;
      exports3.findAllScripts = findAllScripts;
      exports3.findW3cTraceParent = findW3cTraceParent;
      exports3.formatTraceParent = formatTraceParent;
      exports3.getExtensionByName = getExtensionByName;
      exports3.isBeaconApiSupported = isBeaconsSupported;
      exports3.isCrossOriginError = isCrossOriginError;
      exports3.isInternalApplicationInsightsEndpoint = isInternalApplicationInsightsEndpoint;
      exports3.isSampledFlag = isSampledFlag;
      exports3.isValidSpanId = isValidSpanId;
      exports3.isValidTraceId = isValidTraceId;
      exports3.isValidTraceParent = isValidTraceParent;
      exports3.msToTimeSpan = msToTimeSpan;
      exports3.parseConnectionString = parseConnectionString;
      exports3.parseTraceParent = parseTraceParent;
      exports3.strNotSpecified = strNotSpecified;
      exports3.stringToBoolOrDefault = stringToBoolOrDefault;
      exports3.urlGetAbsoluteUrl = urlGetAbsoluteUrl;
      exports3.urlGetCompleteUrl = urlGetCompleteUrl;
      exports3.urlGetPathName = urlGetPathName;
      exports3.urlParseFullHost = urlParseFullHost;
      exports3.urlParseHost = urlParseHost;
      exports3.urlParseUrl = urlParseUrl;
      exports3.utlCanUseLocalStorage = utlCanUseLocalStorage;
      exports3.utlCanUseSessionStorage = utlCanUseSessionStorage;
      exports3.utlDisableStorage = utlDisableStorage;
      exports3.utlEnableStorage = utlEnableStorage;
      exports3.utlGetLocalStorage = utlGetLocalStorage;
      exports3.utlGetSessionStorage = utlGetSessionStorage;
      exports3.utlGetSessionStorageKeys = utlGetSessionStorageKeys;
      exports3.utlRemoveSessionStorage = utlRemoveSessionStorage;
      exports3.utlRemoveStorage = utlRemoveStorage;
      exports3.utlSetLocalStorage = utlSetLocalStorage;
      exports3.utlSetSessionStorage = utlSetSessionStorage;
      exports3.utlSetStoragePrefix = utlSetStoragePrefix;
    });
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/util.js
var require_util = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetryUtil = void 0;
    var TelemetryUtil = class _TelemetryUtil {
      static applyReplacements(data, replacementOptions) {
        for (const key of Object.keys(data)) {
          for (const option of replacementOptions) {
            if (option.lookup.test(key)) {
              if (option.replacementString !== void 0) {
                data[key] = option.replacementString;
              } else {
                delete data[key];
              }
            }
          }
        }
      }
      /**
       * Given a key / connection string checks if it is a valid 1DS key
       * @param key The key to check if it's a valid 1DS key
       */
      static shouldUseOneDataSystemSDK(key) {
        return key.length === 74 && key[32] === "-" && key[41] === "-" && key[46] === "-" && key[51] === "-" && key[56] === "-" && key[69] === "-";
      }
      // This also includes the common properties which core mixes in
      // __GDPR__COMMON__ "common.os" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.nodeArch" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.platformversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.extname" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.extversion" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.vscodemachineid" : { "endPoint": "MacAddressHash", "classification": "EndUserPseudonymizedInformation", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.vscodesessionid" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.vscodecommithash" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.vscodeversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.uikind" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.remotename" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.isnewappinstall" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.product" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.telemetryclientversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      static getAdditionalCommonProperties(osShim) {
        return {
          "common.os": osShim.platform,
          "common.nodeArch": osShim.architecture,
          "common.platformversion": (osShim.release || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"),
          // Do not change this string as it gets found and replaced upon packaging
          "common.telemetryclientversion": "0.9.9"
        };
      }
      // Get singleton instance of TelemetryUtil
      static getInstance() {
        if (!_TelemetryUtil._instance) {
          _TelemetryUtil._instance = new _TelemetryUtil();
        }
        return _TelemetryUtil._instance;
      }
    };
    exports2.TelemetryUtil = TelemetryUtil;
  }
});

// node_modules/@microsoft/applicationinsights-web-basic/dist/es5/applicationinsights-web-basic.js
var require_applicationinsights_web_basic = __commonJS({
  "node_modules/@microsoft/applicationinsights-web-basic/dist/es5/applicationinsights-web-basic.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory((global2.Microsoft = global2.Microsoft || {}, global2.Microsoft.ApplicationInsights = global2.Microsoft.ApplicationInsights || {})));
    })(exports2, function(exports3) {
      "use strict";
      // @__NO_SIDE_EFFECTS__
      function _pureAssign(func1, func2) {
        return func1 || func2;
      }
      // @__NO_SIDE_EFFECTS__
      function _pureRef(value, name) {
        return value[name];
      }
      var UNDEF_VALUE = void 0;
      var NULL_VALUE = null;
      var EMPTY = "";
      var FUNCTION = "function";
      var OBJECT = "object";
      var PROTOTYPE = "prototype";
      var __PROTO__ = "__proto__";
      var UNDEFINED = "undefined";
      var CONSTRUCTOR = "constructor";
      var SYMBOL = "Symbol";
      var LENGTH = "length";
      var NAME = "name";
      var CALL = "call";
      var TO_STRING = "toString";
      var GET_OWN_PROPERTY_DESCRIPTOR = "getOwnPropertyDescriptor";
      var ObjClass$1 = /* @__PURE__ */ _pureAssign(Object);
      var ObjProto$1 = /* @__PURE__ */ _pureRef(ObjClass$1, PROTOTYPE);
      var StrCls = /* @__PURE__ */ _pureAssign(String);
      var StrProto = /* @__PURE__ */ _pureRef(StrCls, PROTOTYPE);
      var MathCls = /* @__PURE__ */ _pureAssign(Math);
      var ArrCls = /* @__PURE__ */ _pureAssign(Array);
      var ArrProto = /* @__PURE__ */ _pureRef(ArrCls, PROTOTYPE);
      var ArrSlice = /* @__PURE__ */ _pureRef(ArrProto, "slice");
      var POLYFILL_TAG = "_polyfill";
      var POLYFILL_TYPE_NAME = "__nw21$polytype__";
      function safe(func, argArray) {
        try {
          return {
            v: func.apply(this, argArray)
          };
        } catch (e) {
          return { e };
        }
      }
      // @__NO_SIDE_EFFECTS__
      function safeGet(cb, defValue, argArray) {
        var result = safe(cb, argArray);
        return result.e ? defValue : result.v;
      }
      var _primitiveTypes;
      // @__NO_SIDE_EFFECTS__
      function _createIs(theType) {
        return function(value) {
          return typeof value === theType;
        };
      }
      // @__NO_SIDE_EFFECTS__
      function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function(value) {
          return !!(value && /* @__PURE__ */ objToString(value) === theType);
        };
      }
      // @__NO_SIDE_EFFECTS__
      function objToString(value) {
        return ObjProto$1[TO_STRING].call(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictUndefined(arg) {
        return arg === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isNullOrUndefined(value) {
        return value === NULL_VALUE || /* @__PURE__ */ isUndefined(value);
      }
      // @__NO_SIDE_EFFECTS__
      function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || value === UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function isPrimitiveType(theType) {
        !_primitiveTypes && (_primitiveTypes = ["string", "number", "boolean", UNDEFINED, "symbol", "bigint"]);
        return !!(theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1);
      }
      var isString = /* @__PURE__ */ _createIs("string");
      var isFunction = /* @__PURE__ */ _createIs(FUNCTION);
      // @__NO_SIDE_EFFECTS__
      function isObject(value) {
        if (!value && /* @__PURE__ */ isNullOrUndefined(value)) {
          return false;
        }
        return !!value && typeof value === OBJECT;
      }
      var isArray = /* @__PURE__ */ _pureRef(ArrCls, "isArray");
      var isDate = /* @__PURE__ */ _createObjIs("Date");
      var isNumber = /* @__PURE__ */ _createIs("number");
      var isBoolean = /* @__PURE__ */ _createIs("boolean");
      var isError = /* @__PURE__ */ _createObjIs("Error");
      // @__NO_SIDE_EFFECTS__
      function isPromiseLike(value) {
        return !!(value && value.then && isFunction(value.then));
      }
      // @__NO_SIDE_EFFECTS__
      function isTruthy(value) {
        return !(!value || /* @__PURE__ */ safeGet(function() {
          return !(value && 0 + value);
        }, !value));
      }
      function _returnNothing() {
        return;
      }
      function _returnFalse() {
        return false;
      }
      var asString = /* @__PURE__ */ _pureAssign(StrCls);
      var ERROR_TYPE = "[object Error]";
      // @__NO_SIDE_EFFECTS__
      function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        var objType = ObjProto$1[TO_STRING][CALL](object);
        if (objType === ERROR_TYPE) {
          object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
        }
        try {
          propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format === "number" ? format : 4 : UNDEF_VALUE);
          propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
        } catch (e) {
          propertyValueDump = " - " + /* @__PURE__ */ dumpObj(e, format);
        }
        return objType + ": " + propertyValueDump;
      }
      function throwError(message) {
        throw new Error(message);
      }
      function throwTypeError(message) {
        throw new TypeError(message);
      }
      function _throwIfNullOrUndefined(obj) {
        if (/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          throwTypeError("Cannot convert undefined or null to object");
        }
      }
      function _throwIfNotString(value) {
        if (!isString(value)) {
          throwTypeError("'" + /* @__PURE__ */ dumpObj(value) + "' is not a string");
        }
      }
      // @__NO_SIDE_EFFECTS__
      function objHasOwnProperty(obj, prop) {
        return !!obj && ObjProto$1.hasOwnProperty[CALL](obj, prop);
      }
      var _objGetOwnPropertyDescriptor$2 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var objHasOwn = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "hasOwn"), polyObjHasOwn);
      // @__NO_SIDE_EFFECTS__
      function polyObjHasOwn(obj, prop) {
        _throwIfNullOrUndefined(obj);
        return /* @__PURE__ */ objHasOwnProperty(obj, prop) || !!_objGetOwnPropertyDescriptor$2(obj, prop);
      }
      function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && (/* @__PURE__ */ isObject(theObject) || isFunction(theObject))) {
          for (var prop in theObject) {
            if (objHasOwn(theObject, prop)) {
              if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                break;
              }
            }
          }
        }
      }
      function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
          var len = theArray[LENGTH] >>> 0;
          for (var idx = 0; idx < len; idx++) {
            if (idx in theArray) {
              if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                break;
              }
            }
          }
        }
      }
      var _unwrapFunction = _unwrapFunctionWithPoly;
      // @__NO_SIDE_EFFECTS__
      function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
        var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
        return function(thisArg) {
          var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
          if (theFunc || polyFunc) {
            var theArgs = arguments;
            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
          }
          throwTypeError('"' + asString(funcName) + '" not defined for ' + /* @__PURE__ */ dumpObj(thisArg));
        };
      }
      // @__NO_SIDE_EFFECTS__
      function _unwrapProp(propName) {
        return function(thisArg) {
          return thisArg[propName];
        };
      }
      var _objGetOwnPropertyDescriptor$1 = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var propMap = {
        e: "enumerable",
        c: "configurable",
        v: "value",
        w: "writable",
        g: "get",
        s: "set"
      };
      // @__NO_SIDE_EFFECTS__
      function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
          prop.get = function() {
            return value.l.v;
          };
          var desc = _objGetOwnPropertyDescriptor$1(value.l, "v");
          if (desc && desc.set) {
            prop.set = function(newValue) {
              value.l.v = newValue;
            };
          }
        }
        objForEachKey(value, function(key, value2) {
          prop[propMap[key]] = /* @__PURE__ */ isStrictUndefined(value2) ? prop[propMap[key]] : value2;
        });
        return prop;
      }
      var objDefineProp = /* @__PURE__ */ _pureRef(ObjClass$1, "defineProperty");
      var objDefineProperties = /* @__PURE__ */ _pureRef(ObjClass$1, "defineProperties");
      function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, /* @__PURE__ */ _createProp(propDesc));
      }
      // @__NO_SIDE_EFFECTS__
      function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
        var theMap = {};
        objForEachKey(values, function(key, value) {
          _assignMapValue(theMap, key, keyType ? value : key);
          _assignMapValue(theMap, value, valueType ? value : key);
        });
        return completeFn ? completeFn(theMap) : theMap;
      }
      function _assignMapValue(theMap, key, value, writable) {
        objDefineProp(theMap, key, {
          value,
          enumerable: true,
          writable: false
        });
      }
      var objIsFrozen = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "isFrozen"), _returnFalse);
      var _objFreeze = /* @__PURE__ */ _pureRef(ObjClass$1, "freeze");
      function _doNothing(value) {
        return value;
      }
      // @__NO_SIDE_EFFECTS__
      function _getProto(value) {
        _throwIfNullOrUndefined(value);
        return value[__PROTO__] || NULL_VALUE;
      }
      var objAssign = /* @__PURE__ */ _pureRef(ObjClass$1, "assign");
      var objKeys = /* @__PURE__ */ _pureRef(ObjClass$1, "keys");
      function _deepFreeze(val, visited) {
        if ((isArray(val) || /* @__PURE__ */ isObject(val) || isFunction(val)) && !objIsFrozen(val)) {
          for (var lp = 0; lp < visited.length; lp++) {
            if (visited[lp] === val) {
              return val;
            }
          }
          visited.push(val);
          objForEachKey(val, function(_key, propValue) {
            _deepFreeze(propValue, visited);
          });
          objFreeze(val);
        }
        return val;
      }
      function objDeepFreeze(value) {
        return _objFreeze ? _deepFreeze(value, []) : value;
      }
      var objFreeze = /* @__PURE__ */ _pureAssign(_objFreeze, _doNothing);
      var objGetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "getPrototypeOf"), _getProto);
      // @__NO_SIDE_EFFECTS__
      function createEnum(values) {
        return /* @__PURE__ */ _createKeyValueMap(values, 1, 0, objFreeze);
      }
      // @__NO_SIDE_EFFECTS__
      function createEnumKeyMap(values) {
        return /* @__PURE__ */ _createKeyValueMap(values, 0, 0, objFreeze);
      }
      // @__NO_SIDE_EFFECTS__
      function createSimpleMap(values) {
        var mapClass = {};
        objForEachKey(values, function(key, value) {
          _assignMapValue(mapClass, key, value[1]);
          _assignMapValue(mapClass, value[0], value[1]);
        });
        return objFreeze(mapClass);
      }
      // @__NO_SIDE_EFFECTS__
      function createTypeMap(values) {
        return /* @__PURE__ */ createSimpleMap(values);
      }
      var _wellKnownSymbolMap = /* @__PURE__ */ createEnumKeyMap({
        asyncIterator: 0,
        hasInstance: 1,
        isConcatSpreadable: 2,
        iterator: 3,
        match: 4,
        matchAll: 5,
        replace: 6,
        search: 7,
        species: 8,
        split: 9,
        toPrimitive: 10,
        toStringTag: 11,
        unscopables: 12
      });
      var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
      var _globalCfg;
      // @__NO_SIDE_EFFECTS__
      function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
          result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
          result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
          result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
          result = global;
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function _getGlobalConfig() {
        if (!_globalCfg) {
          var gbl = safe(_getGlobalValue).v || {};
          _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
      }
      var mathMin = /* @__PURE__ */ _pureRef(MathCls, "min");
      var mathMax = /* @__PURE__ */ _pureRef(MathCls, "max");
      var strSlice = /* @__PURE__ */ _unwrapFunction("slice", StrProto);
      var strSubstring = /* @__PURE__ */ _unwrapFunction("substring", StrProto);
      var strSubstr = /* @__PURE__ */ _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
      // @__NO_SIDE_EFFECTS__
      function polyStrSubstr(value, start, length) {
        _throwIfNullOrUndefined(value);
        if (length < 0) {
          return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
          start = mathMax(start + value[LENGTH], 0);
        }
        if (/* @__PURE__ */ isUndefined(length)) {
          return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
      }
      // @__NO_SIDE_EFFECTS__
      function strLeft(value, count) {
        return strSubstring(value, 0, count);
      }
      function _tagAsPolyfill(target, polyfillTypeName) {
        if (target) {
          safe(function() {
            target[POLYFILL_TAG] = true;
            target[POLYFILL_TYPE_NAME] = polyfillTypeName;
          });
          safe(objDefine, [target, POLYFILL_TAG, {
            v: true,
            w: false,
            e: false
          }]);
          safe(objDefine, [target, POLYFILL_TYPE_NAME, {
            v: polyfillTypeName,
            w: false,
            e: false
          }]);
        }
        return target;
      }
      var objCreate = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "create"), polyObjCreate);
      // @__NO_SIDE_EFFECTS__
      function polyObjCreate(obj, properties) {
        var newObj = null;
        function tempFunc() {
        }
        if (!/* @__PURE__ */ isStrictNullOrUndefined(obj)) {
          var type = typeof obj;
          if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + /* @__PURE__ */ dumpObj(obj));
          }
          tempFunc[PROTOTYPE] = obj;
          safe(function() {
            tempFunc[__PROTO__] = obj;
          });
          newObj = new tempFunc();
        } else {
          newObj = {};
        }
        if (properties) {
          safe(objDefineProperties, [newObj, properties]);
        }
        return newObj;
      }
      // @__NO_SIDE_EFFECTS__
      function utcNow() {
        return (Date.now || polyUtcNow)();
      }
      // @__NO_SIDE_EFFECTS__
      function polyUtcNow() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
      function fnApply(fn, thisArg, argArray) {
        return fn.apply(thisArg, argArray);
      }
      var _globalLazyTestHooks;
      function _initTestHooks() {
        _globalLazyTestHooks = /* @__PURE__ */ _getGlobalConfig();
      }
      // @__NO_SIDE_EFFECTS__
      function getLazy(cb, argArray) {
        var lazyValue = {};
        !_globalLazyTestHooks && _initTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
          configurable: true,
          get: function() {
            var result = fnApply(cb, null, argArray);
            if (!_globalLazyTestHooks.lzy) {
              objDefineProp(lazyValue, "v", {
                value: result
              });
            }
            lazyValue.b = _globalLazyTestHooks.lzy;
            return result;
          }
        });
        return lazyValue;
      }
      var mathRandom = /* @__PURE__ */ _pureRef(MathCls, "random");
      var _uniqueInstanceId = /* @__PURE__ */ getLazy(function() {
        var value = (/* @__PURE__ */ utcNow()).toString(36).slice(2);
        while (value.length < 16) {
          value += mathRandom().toString(36).slice(2);
        }
        value = value.substring(0, 16);
        return value;
      });
      var UNIQUE_REGISTRY_ID = "_urid";
      var POLY_SYM = "$nw21sym";
      var _polySymbols;
      var _polyId = 0;
      // @__NO_SIDE_EFFECTS__
      function _globalSymbolRegistry() {
        if (!_polySymbols) {
          var gblCfg = /* @__PURE__ */ _getGlobalConfig();
          _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
      }
      var _wellKnownSymbolCache;
      // @__NO_SIDE_EFFECTS__
      function polyNewSymbol(description) {
        var uniqueId = "_" + _polyId++ + "_" + _uniqueInstanceId.v;
        var symString = SYMBOL + "(" + description + ")";
        function _setProp(name, value) {
          objDefine(theSymbol, name, {
            v: value,
            e: false,
            w: false
          });
        }
        var theSymbol = objCreate(null);
        _setProp("description", asString(description));
        _setProp(TO_STRING, function() {
          return symString + POLY_SYM + uniqueId;
        });
        _setProp("valueOf", function() {
          return theSymbol;
        });
        _setProp("v", symString);
        _setProp("_uid", uniqueId);
        return _tagAsPolyfill(theSymbol, "symbol");
      }
      // @__NO_SIDE_EFFECTS__
      function polySymbolFor(key) {
        var registry = /* @__PURE__ */ _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
          var newSymbol_1 = /* @__PURE__ */ polyNewSymbol(key);
          var regId_1 = objKeys(registry.s).length;
          newSymbol_1[UNIQUE_REGISTRY_ID] = function() {
            return regId_1 + "_" + newSymbol_1[TO_STRING]();
          };
          registry.k[key] = newSymbol_1;
          registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
      }
      // @__NO_SIDE_EFFECTS__
      function polyGetKnownSymbol(name) {
        !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
          result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || /* @__PURE__ */ polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function createCachedValue(value) {
        return objDefineProp({
          toJSON: function() {
            return value;
          }
        }, "v", { value });
      }
      var WINDOW = "window";
      var _cachedGlobal;
      function _getGlobalInstFn(getFn, theArgs) {
        var cachedValue;
        return function() {
          !_globalLazyTestHooks && _initTestHooks();
          if (!cachedValue || _globalLazyTestHooks.lzy) {
            cachedValue = /* @__PURE__ */ createCachedValue(safe(getFn, theArgs).v);
          }
          return cachedValue.v;
        };
      }
      function getGlobal(useCached) {
        !_globalLazyTestHooks && _initTestHooks();
        if (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) {
          _cachedGlobal = /* @__PURE__ */ createCachedValue(safe(_getGlobalValue).v || NULL_VALUE);
        }
        return _cachedGlobal.v;
      }
      // @__NO_SIDE_EFFECTS__
      function getInst(name, useCached) {
        var gbl;
        if (!_cachedGlobal || useCached === false) {
          gbl = getGlobal(useCached);
        } else {
          gbl = _cachedGlobal.v;
        }
        if (gbl && gbl[name]) {
          return gbl[name];
        }
        if (name === WINDOW) {
          try {
            return window;
          } catch (e) {
          }
        }
        return NULL_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function hasDocument() {
        return !!/* @__PURE__ */ getDocument();
      }
      var getDocument = /* @__PURE__ */ _getGlobalInstFn(getInst, ["document"]);
      // @__NO_SIDE_EFFECTS__
      function hasWindow() {
        return !!/* @__PURE__ */ getWindow();
      }
      var getWindow = /* @__PURE__ */ _getGlobalInstFn(getInst, [WINDOW]);
      // @__NO_SIDE_EFFECTS__
      function hasNavigator() {
        return !!/* @__PURE__ */ getNavigator();
      }
      var getNavigator = /* @__PURE__ */ _getGlobalInstFn(getInst, ["navigator"]);
      var isNode = /* @__PURE__ */ _getGlobalInstFn(function() {
        return !!safe(function() {
          return process && (process.versions || {}).node;
        }).v;
      });
      var _symbol;
      var _symbolFor;
      // @__NO_SIDE_EFFECTS__
      function _initSymbol() {
        _symbol = /* @__PURE__ */ createCachedValue(safe(getInst, [SYMBOL]).v);
        return _symbol;
      }
      function _getSymbolKey(key) {
        var gblSym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return gblSym.v ? gblSym.v[key] : UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function hasSymbol() {
        return !!/* @__PURE__ */ getSymbol();
      }
      // @__NO_SIDE_EFFECTS__
      function getSymbol() {
        !_globalLazyTestHooks && _initTestHooks();
        return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol()).v;
      }
      // @__NO_SIDE_EFFECTS__
      function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        !_globalLazyTestHooks && _initTestHooks();
        var sym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return sym.v ? sym.v[knownName || name] : !noPoly ? /* @__PURE__ */ polyGetKnownSymbol(name) : UNDEF_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function newSymbol(description, noPoly) {
        !_globalLazyTestHooks && _initTestHooks();
        var sym = (!_globalLazyTestHooks.lzy ? _symbol : 0) || /* @__PURE__ */ _initSymbol();
        return sym.v ? sym.v(description) : !noPoly ? /* @__PURE__ */ polyNewSymbol(description) : NULL_VALUE;
      }
      // @__NO_SIDE_EFFECTS__
      function symbolFor(key) {
        !_globalLazyTestHooks && _initTestHooks();
        _symbolFor = (!_globalLazyTestHooks.lzy ? _symbolFor : 0) || /* @__PURE__ */ createCachedValue(safe(_getSymbolKey, ["for"]).v);
        return (_symbolFor.v || polySymbolFor)(key);
      }
      // @__NO_SIDE_EFFECTS__
      function isIterator(value) {
        return !!value && isFunction(value.next);
      }
      // @__NO_SIDE_EFFECTS__
      function isIterable(value) {
        return !/* @__PURE__ */ isStrictNullOrUndefined(value) && isFunction(value[/* @__PURE__ */ getKnownSymbol(3)]);
      }
      var _iterSymbol$1;
      function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
          if (!/* @__PURE__ */ isIterator(iter)) {
            !_iterSymbol$1 && (_iterSymbol$1 = /* @__PURE__ */ createCachedValue(/* @__PURE__ */ getKnownSymbol(3)));
            iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : NULL_VALUE;
          }
          if (/* @__PURE__ */ isIterator(iter)) {
            var err = UNDEF_VALUE;
            var iterResult = UNDEF_VALUE;
            try {
              var count = 0;
              while (!(iterResult = iter.next()).done) {
                if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                  break;
                }
                count++;
              }
            } catch (failed) {
              err = { e: failed };
              if (iter.throw) {
                iterResult = NULL_VALUE;
                iter.throw(err);
              }
            } finally {
              try {
                if (iterResult && !iterResult.done) {
                  iter.return && iter.return(iterResult);
                }
              } finally {
                if (err) {
                  throw err.e;
                }
              }
            }
          }
        }
      }
      function arrAppend(target, elms) {
        if (!/* @__PURE__ */ isUndefined(elms) && target) {
          if (isArray(elms)) {
            fnApply(target.push, target, elms);
          } else if (/* @__PURE__ */ isIterator(elms) || /* @__PURE__ */ isIterable(elms)) {
            iterForOf(elms, function(elm) {
              target.push(elm);
            });
          } else {
            target.push(elms);
          }
        }
        return target;
      }
      var arrIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", ArrProto);
      var arrMap = /* @__PURE__ */ _unwrapFunction("map", ArrProto);
      function arrSlice(theArray, start, end) {
        return ((theArray ? theArray["slice"] : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
      }
      var arrReduce = /* @__PURE__ */ _unwrapFunction("reduce", ArrProto);
      var _isProtoArray;
      var objSetPrototypeOf = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, "setPrototypeOf"), _polyObjSetPrototypeOf);
      function _polyObjSetPrototypeOf(obj, proto) {
        var _a2;
        !_isProtoArray && (_isProtoArray = /* @__PURE__ */ createCachedValue((_a2 = {}, _a2[__PROTO__] = [], _a2) instanceof Array));
        _isProtoArray.v ? obj[__PROTO__] = proto : objForEachKey(proto, function(key, value) {
          return obj[key] = value;
        });
        return obj;
      }
      // @__NO_SIDE_EFFECTS__
      function _createCustomError(name, d, b) {
        safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
        d = objSetPrototypeOf(d, b);
        function __() {
          this[CONSTRUCTOR] = d;
          safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
      }
      function _setName(baseClass, name) {
        name && (baseClass[NAME] = name);
      }
      // @__NO_SIDE_EFFECTS__
      function createCustomError(name, constructCb, errorBase) {
        var theBaseClass = errorBase || Error;
        var orgName = theBaseClass[PROTOTYPE][NAME];
        var captureFn = Error.captureStackTrace;
        return /* @__PURE__ */ _createCustomError(name, function() {
          var _this = this;
          var theArgs = arguments;
          try {
            safe(_setName, [theBaseClass, name]);
            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
            if (_self !== _this) {
              var orgProto = objGetPrototypeOf(_this);
              if (orgProto !== objGetPrototypeOf(_self)) {
                objSetPrototypeOf(_self, orgProto);
              }
            }
            captureFn && captureFn(_self, _this[CONSTRUCTOR]);
            constructCb && constructCb(_self, theArgs);
            return _self;
          } finally {
            safe(_setName, [theBaseClass, orgName]);
          }
        }, theBaseClass);
      }
      // @__NO_SIDE_EFFECTS__
      function _createTrimFn(exp) {
        return function _doTrim(value) {
          _throwIfNullOrUndefined(value);
          if (value && value.replace) {
            value = value.replace(exp, EMPTY);
          }
          return value;
        };
      }
      var polyStrTrim = /* @__PURE__ */ _createTrimFn(/^\s+|(?=\s)\s+$/g);
      var strTrim = /* @__PURE__ */ _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim);
      var mathFloor = /* @__PURE__ */ _pureRef(MathCls, "floor");
      var _fnToString;
      var _objCtrFnString;
      var _gblWindow;
      // @__NO_SIDE_EFFECTS__
      function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
          return false;
        }
        if (!_gblWindow) {
          _gblWindow = /* @__PURE__ */ hasWindow() ? getWindow() : true;
        }
        var result = false;
        if (value !== _gblWindow) {
          if (!_objCtrFnString) {
            _fnToString = Function[PROTOTYPE][TO_STRING];
            _objCtrFnString = _fnToString[CALL](ObjClass$1);
          }
          try {
            var proto = objGetPrototypeOf(value);
            result = !proto;
            if (!result) {
              if (/* @__PURE__ */ objHasOwnProperty(proto, CONSTRUCTOR)) {
                proto = proto[CONSTRUCTOR];
              }
              result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);
            }
          } catch (ex) {
          }
        }
        return result;
      }
      // @__NO_SIDE_EFFECTS__
      function _defaultDeepCopyHandler(details) {
        details.value && plainObjDeepCopyHandler(details);
        return true;
      }
      var defaultDeepCopyHandlers = [
        arrayDeepCopyHandler,
        plainObjDeepCopyHandler,
        functionDeepCopyHandler,
        dateDeepCopyHandler
      ];
      // @__NO_SIDE_EFFECTS__
      function _getSetVisited(visitMap, source, newPath, cb) {
        var theEntry;
        arrForEach(visitMap, function(entry) {
          if (entry.k === source) {
            theEntry = entry;
            return -1;
          }
        });
        if (!theEntry) {
          theEntry = { k: source, v: source };
          visitMap.push(theEntry);
          cb(theEntry);
        }
        return theEntry.v;
      }
      function _deepCopy(visitMap, value, ctx, key) {
        var userHandler = ctx.handler;
        var newPath = ctx.path ? key ? ctx.path.concat(key) : ctx.path : [];
        var newCtx = {
          handler: ctx.handler,
          src: ctx.src,
          path: newPath
        };
        var theType = typeof value;
        var isPlain = false;
        var isPrim = value === NULL_VALUE;
        if (!isPrim) {
          if (value && theType === OBJECT) {
            isPlain = /* @__PURE__ */ isPlainObject(value);
          } else {
            isPrim = /* @__PURE__ */ isPrimitiveType(theType);
          }
        }
        var details = {
          type: theType,
          isPrim,
          isPlain,
          value,
          result: value,
          path: newPath,
          origin: ctx.src,
          copy: function(source, newKey) {
            return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
          },
          copyTo: function(target, source) {
            return _copyProps(visitMap, target, source, newCtx);
          }
        };
        if (!details.isPrim) {
          return /* @__PURE__ */ _getSetVisited(visitMap, value, newPath, function(newEntry) {
            objDefine(details, "result", {
              g: function() {
                return newEntry.v;
              },
              s: function(newValue) {
                newEntry.v = newValue;
              }
            });
            var idx = 0;
            var handler = userHandler;
            while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {
              handler = NULL_VALUE;
            }
          });
        }
        if (userHandler && userHandler[CALL](ctx, details)) {
          return details.result;
        }
        return value;
      }
      function _copyProps(visitMap, target, source, ctx) {
        if (!/* @__PURE__ */ isNullOrUndefined(source)) {
          for (var key in source) {
            target[key] = _deepCopy(visitMap, source[key], ctx, key);
          }
        }
        return target;
      }
      function objCopyProps(target, source, handler) {
        var ctx = {
          handler,
          src: source,
          path: []
        };
        return _copyProps([], target, source, ctx);
      }
      // @__NO_SIDE_EFFECTS__
      function objDeepCopy(source, handler) {
        var ctx = {
          handler,
          src: source
        };
        return _deepCopy([], source, ctx);
      }
      function arrayDeepCopyHandler(details) {
        var value = details.value;
        if (isArray(value)) {
          var target = details.result = [];
          target.length = value.length;
          details.copyTo(target, value);
          return true;
        }
        return false;
      }
      function dateDeepCopyHandler(details) {
        var value = details.value;
        if (isDate(value)) {
          details.result = new Date(value.getTime());
          return true;
        }
        return false;
      }
      function functionDeepCopyHandler(details) {
        if (details.type === FUNCTION) {
          return true;
        }
        return false;
      }
      function plainObjDeepCopyHandler(details) {
        var value = details.value;
        if (value && details.isPlain) {
          var target = details.result = {};
          details.copyTo(target, value);
          return true;
        }
        return false;
      }
      function _doExtend(target, theArgs) {
        arrForEach(theArgs, function(theArg) {
          objCopyProps(target, theArg);
        });
        return target;
      }
      function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
        return _doExtend(/* @__PURE__ */ objDeepCopy(target) || {}, ArrSlice[CALL](arguments));
      }
      var getLength = /* @__PURE__ */ _unwrapProp(LENGTH);
      var mathRound = /* @__PURE__ */ _pureRef(MathCls, "round");
      var objGetOwnPropertyDescriptor = /* @__PURE__ */ _pureAssign(/* @__PURE__ */ _pureRef(ObjClass$1, GET_OWN_PROPERTY_DESCRIPTOR), _returnNothing);
      var strEndsWith = /* @__PURE__ */ _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
      // @__NO_SIDE_EFFECTS__
      function polyStrEndsWith(value, searchString, length) {
        _throwIfNotString(value);
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var end = !/* @__PURE__ */ isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
        return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
      }
      var strIndexOf = /* @__PURE__ */ _unwrapFunction("indexOf", StrProto);
      var REF = "ref";
      var UNREF = "unref";
      var HAS_REF = "hasRef";
      var ENABLED = "enabled";
      // @__NO_SIDE_EFFECTS__
      function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        function _unref() {
          ref = false;
          timerId && timerId[UNREF] && timerId[UNREF]();
          return theTimerHandler;
        }
        function _cancel() {
          timerId && cancelFn(timerId);
          timerId = NULL_VALUE;
        }
        function _refresh() {
          timerId = refreshFn(timerId);
          if (!ref) {
            _unref();
          }
          return theTimerHandler;
        }
        function _setEnabled(value) {
          !value && timerId && _cancel();
          value && !timerId && _refresh();
        }
        theTimerHandler = {
          cancel: _cancel,
          refresh: _refresh
        };
        theTimerHandler[HAS_REF] = function() {
          if (timerId && timerId[HAS_REF]) {
            return timerId[HAS_REF]();
          }
          return ref;
        };
        theTimerHandler[REF] = function() {
          ref = true;
          timerId && timerId[REF] && timerId[REF]();
          return theTimerHandler;
        };
        theTimerHandler[UNREF] = _unref;
        theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
          get: function() {
            return !!timerId;
          },
          set: _setEnabled
        });
        return {
          h: theTimerHandler,
          dn: function() {
            timerId = NULL_VALUE;
          }
        };
      }
      var _setTimeoutFn;
      var _clearTimeoutFn;
      function _resolveTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _setTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 0 && isFunction(globalOverrides[0])) {
            result = globalOverrides[0];
          }
        }
        return result || setTimeout;
      }
      function _resolveClearTimeoutFn(timeoutFn) {
        var result = isFunction(timeoutFn) ? timeoutFn : _clearTimeoutFn;
        if (!result) {
          var globalOverrides = (/* @__PURE__ */ _getGlobalConfig()).tmOut || [];
          if (isArray(globalOverrides) && globalOverrides.length > 1 && isFunction(globalOverrides[1])) {
            result = globalOverrides[1];
          }
        }
        return result || clearTimeout;
      }
      function _createTimeoutWith(startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = _resolveTimeoutFn(len > 0 ? overrideFn[0] : !isArr ? overrideFn : UNDEF_VALUE);
        var clearFn = _resolveClearTimeoutFn(len > 1 ? overrideFn[1] : UNDEF_VALUE);
        var timerFn = theArgs[0];
        theArgs[0] = function() {
          handler.dn();
          fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
        };
        var handler = /* @__PURE__ */ _createTimerHandler(startTimer, function(timerId) {
          if (timerId) {
            if (timerId.refresh) {
              timerId.refresh();
              return timerId;
            }
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
          }
          return fnApply(setFn, UNDEF_VALUE, theArgs);
        }, function(timerId) {
          fnApply(clearFn, UNDEF_VALUE, [timerId]);
        });
        return handler.h;
      }
      function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
      }
      function createTimeout(callback, timeout) {
        return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));
      }
      var _a$6;
      var Constructor = "constructor";
      var Prototype = "prototype";
      var strFunction = "function";
      var DynInstFuncTable = "_dynInstFuncs";
      var DynProxyTag = "_isDynProxy";
      var DynClassName = "_dynClass";
      var DynClassNamePrefix = "_dynCls$";
      var DynInstChkTag = "_dynInstChk";
      var DynAllowInstChkTag = DynInstChkTag;
      var DynProtoDefaultOptions = "_dfOpts";
      var UnknownValue = "_unknown_";
      var str__Proto = "__proto__";
      var DynProtoBaseProto = "_dyn" + str__Proto;
      var DynProtoGlobalSettings = "__dynProto$Gbl";
      var DynProtoCurrent = "_dynInstProto";
      var strUseBaseInst = "useBaseInst";
      var strSetInstFuncs = "setInstFuncs";
      var Obj = Object;
      var _objGetPrototypeOf = Obj["getPrototypeOf"];
      var _objGetOwnProps = Obj["getOwnPropertyNames"];
      var _gbl = getGlobal();
      var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$6 = {}, _a$6[strSetInstFuncs] = true, _a$6[strUseBaseInst] = true, _a$6),
        n: 1e3
      });
      function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
      }
      function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
      }
      function _getObjProto(target) {
        var newProto;
        if (target) {
          if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
          }
          var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
          newProto = target[DynProtoBaseProto] || curProto;
          if (!/* @__PURE__ */ objHasOwnProperty(target, DynProtoBaseProto)) {
            delete target[DynProtoCurrent];
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
          }
        }
        return newProto;
      }
      function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
          props = _objGetOwnProps(target);
        } else {
          for (var name_1 in target) {
            if (typeof name_1 === "string" && /* @__PURE__ */ objHasOwnProperty(target, name_1)) {
              props.push(name_1);
            }
          }
        }
        if (props && props.length > 0) {
          for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
          }
        }
      }
      function _isDynamicCandidate(target, funcName, skipOwn) {
        return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || /* @__PURE__ */ objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
      }
      function _throwTypeError(message) {
        throwTypeError("DynamicProto: " + message);
      }
      function _getInstanceFuncs(thisTarget) {
        var instFuncs = objCreate(null);
        _forEachProp(thisTarget, function(name) {
          if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
            instFuncs[name] = thisTarget[name];
          }
        });
        return instFuncs;
      }
      function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
          if (values[lp] === value) {
            return true;
          }
        }
        return false;
      }
      function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
          var theFunc = funcHost[funcName];
          if (theFunc[DynProxyTag] && useBaseInst) {
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
          }
          return function() {
            return theFunc.apply(target, arguments);
          };
        }
        var baseFuncs = objCreate(null);
        _forEachProp(instFuncs, function(name) {
          baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
          _forEachProp(baseProto, function(name) {
            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
              baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
            }
          });
          visited.push(baseProto);
          baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
      }
      function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && /* @__PURE__ */ objHasOwnProperty(proto, DynClassName)) {
          var instFuncTable = target[DynInstFuncTable] || objCreate(null);
          instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];
          if (!instFunc) {
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
          }
          if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            var canAddInst = !/* @__PURE__ */ objHasOwnProperty(target, funcName);
            var objProto = _getObjProto(target);
            var visited = [];
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
              var protoFunc = objProto[funcName];
              if (protoFunc) {
                canAddInst = protoFunc === currentDynProtoProxy;
                break;
              }
              visited.push(objProto);
              objProto = _getObjProto(objProto);
            }
            try {
              if (canAddInst) {
                target[funcName] = instFunc;
              }
              instFunc[DynInstChkTag] = 1;
            } catch (e) {
              instFuncTable[DynAllowInstChkTag] = false;
            }
          }
        }
        return instFunc;
      }
      function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
          protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
          _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
      }
      function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto2, funcName) {
          var dynProtoProxy = function() {
            var instFunc = _getInstFunc(this, funcName, proto2, dynProtoProxy) || _getProtoFunc(funcName, proto2, dynProtoProxy);
            return instFunc.apply(this, arguments);
          };
          dynProtoProxy[DynProxyTag] = 1;
          return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
          var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
          if (!_isObjectOrArrayPrototype(instFuncTable)) {
            var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
            }
            if (!_isObjectOrArrayPrototype(instFuncs_1)) {
              _forEachProp(target, function(name) {
                if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                  instFuncs_1[name] = target[name];
                  delete target[name];
                  if (!/* @__PURE__ */ objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) {
                    proto[name] = _createDynamicPrototype(proto, name);
                  }
                }
              });
            }
          }
        }
      }
      function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
          var visited = [];
          var thisProto = _getObjProto(thisTarget);
          while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
              return true;
            }
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
          }
          return false;
        }
        return true;
      }
      function _getObjName(target, unknownValue) {
        if (/* @__PURE__ */ objHasOwnProperty(target, Prototype)) {
          return target.name || unknownValue || UnknownValue;
        }
        return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
      }
      function dynamicProto(theClass, target, delegateFunc, options) {
        if (!/* @__PURE__ */ objHasOwnProperty(theClass, Prototype)) {
          _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
          _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (/* @__PURE__ */ objHasOwnProperty(classProto, DynClassName)) {
          className = classProto[DynClassName];
        } else {
          className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
          _gblInst.n++;
          classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== void 0) {
          useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
          setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
      }
      dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
      var strShimFunction = "function";
      var strShimObject = "object";
      var strShimUndefined = "undefined";
      var strShimPrototype = "prototype";
      var ObjClass = Object;
      var ObjProto = ObjClass[strShimPrototype];
      (getGlobal() || {})["Symbol"];
      (getGlobal() || {})["Reflect"];
      var strHasOwnProperty = "hasOwnProperty";
      var __objAssignFnImpl = function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) {
            if (ObjProto[strHasOwnProperty].call(s, p)) {
              t[p] = s[p];
            }
          }
        }
        return t;
      };
      var __assignFn = objAssign || __objAssignFnImpl;
      var extendStaticsFn = function(d, b) {
        extendStaticsFn = ObjClass["setPrototypeOf"] || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2[strHasOwnProperty](p)) {
              d2[p] = b2[p];
            }
          }
        };
        return extendStaticsFn(d, b);
      };
      function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
          throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
          this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
      }
      function __spreadArrayFn(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
          to[j] = from[i];
        }
        return to;
      }
      var createEnumStyle = createEnum;
      var createValueMap = createTypeMap;
      var ActiveStatus = createEnumStyle({
        NONE: 0,
        PENDING: 3,
        INACTIVE: 1,
        ACTIVE: 2
      });
      var _DYN_TO_LOWER_CASE$1 = "toLowerCase";
      var _DYN_LENGTH$2 = "length";
      var _DYN_WARN_TO_CONSOLE = "warnToConsole";
      var _DYN_THROW_INTERNAL = "throwInternal";
      var _DYN_WATCH = "watch";
      var _DYN_APPLY = "apply";
      var _DYN_PUSH$1 = "push";
      var _DYN_SPLICE = "splice";
      var _DYN_LOGGER = "logger";
      var _DYN_CANCEL = "cancel";
      var _DYN_INITIALIZE$1 = "initialize";
      var _DYN_IDENTIFIER = "identifier";
      var _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener";
      var _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener";
      var _DYN_IS_INITIALIZED = "isInitialized";
      var _DYN_GET_NOTIFY_MGR = "getNotifyMgr";
      var _DYN_GET_PLUGIN = "getPlugin";
      var _DYN_NAME$2 = "name";
      var _DYN_PROCESS_NEXT = "processNext";
      var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext";
      var _DYN_VALUE = "value";
      var _DYN_ENABLED = "enabled";
      var _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs";
      var _DYN_UNLOAD = "unload";
      var _DYN_ON_COMPLETE = "onComplete";
      var _DYN_VERSION = "version";
      var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole";
      var _DYN_CREATE_NEW = "createNew";
      var _DYN_TEARDOWN = "teardown";
      var _DYN_MESSAGE_ID = "messageId";
      var _DYN_MESSAGE$1 = "message";
      var _DYN_DIAG_LOG$1 = "diagLog";
      var _DYN__DO_TEARDOWN = "_doTeardown";
      var _DYN_UPDATE = "update";
      var _DYN_GET_NEXT = "getNext";
      var _DYN_SET_NEXT_PLUGIN = "setNextPlugin";
      var _DYN_USER_AGENT = "userAgent";
      var _DYN_SPLIT$1 = "split";
      var _DYN_REPLACE = "replace";
      var _DYN_TYPE = "type";
      var _DYN_EVT_NAME = "evtName";
      var _DYN_STATUS = "status";
      var _DYN_INDEX_OF = "indexOf";
      var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders";
      var _DYN_IS_CHILD_EVT = "isChildEvt";
      var _DYN_DATA$1 = "data";
      var _DYN_GET_CTX = "getCtx";
      var _DYN_SET_CTX = "setCtx";
      var _DYN_ITEMS_RECEIVED$1 = "itemsReceived";
      var _DYN_HEADERS = "headers";
      var _DYN_URL_STRING = "urlString";
      var _DYN_TIMEOUT = "timeout";
      var _DYN_TRACE_FLAGS = "traceFlags";
      var aggregationErrorType;
      function throwAggregationError(message, sourceErrors) {
        if (!aggregationErrorType) {
          aggregationErrorType = /* @__PURE__ */ createCustomError("AggregationError", function(self2, args) {
            if (args[_DYN_LENGTH$2] > 1) {
              self2.errors = args[1];
            }
          });
        }
        var theMessage = message || "One or more errors occurred.";
        arrForEach(sourceErrors, function(srcError, idx) {
          theMessage += "\n".concat(idx, " > ").concat(/* @__PURE__ */ dumpObj(srcError));
        });
        throw new aggregationErrorType(theMessage, sourceErrors || []);
      }
      var STR_PROMISE = "Promise";
      var REJECTED = "rejected";
      function doAwaitResponse(value, cb) {
        return doAwait(value, function(value2) {
          return cb ? cb({
            status: "fulfilled",
            rejected: false,
            value: value2
          }) : value2;
        }, function(reason) {
          return cb ? cb({
            status: REJECTED,
            rejected: true,
            reason
          }) : reason;
        });
      }
      function doAwait(value, resolveFn, rejectFn, finallyFn) {
        var result = value;
        try {
          if (/* @__PURE__ */ isPromiseLike(value)) {
            if (resolveFn || rejectFn) {
              result = value.then(resolveFn, rejectFn);
            }
          } else {
            try {
              if (resolveFn) {
                result = resolveFn(value);
              }
            } catch (err) {
              if (rejectFn) {
                result = rejectFn(err);
              } else {
                throw err;
              }
            }
          }
        } finally {
          if (finallyFn) {
            doFinally(result, finallyFn);
          }
        }
        return result;
      }
      function doFinally(value, finallyFn) {
        var result = value;
        if (finallyFn) {
          if (/* @__PURE__ */ isPromiseLike(value)) {
            if (value.finally) {
              result = value.finally(finallyFn);
            } else {
              result = value.then(function(value2) {
                finallyFn();
                return value2;
              }, function(reason) {
                finallyFn();
                throw reason;
              });
            }
          } else {
            finallyFn();
          }
        }
        return result;
      }
      var STRING_STATES = [
        "pending",
        "resolving",
        "resolved",
        REJECTED
      ];
      var DISPATCH_EVENT = "dispatchEvent";
      var _hasInitEvent;
      function _hasInitEventFn(doc) {
        var evt;
        if (doc && doc.createEvent) {
          evt = doc.createEvent("Event");
        }
        return !!evt && evt.initEvent;
      }
      function emitEvent(target, evtName, populateEvent, useNewEvent) {
        var doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = /* @__PURE__ */ createCachedValue(!!safe(_hasInitEventFn, [doc]).v));
        var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : useNewEvent ? new Event(evtName) : {};
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
          theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
          target[DISPATCH_EVENT](theEvt);
        } else {
          var handler = target["on" + evtName];
          if (handler) {
            handler(theEvt);
          } else {
            var theConsole = /* @__PURE__ */ getInst("console");
            theConsole && (theConsole["error"] || theConsole["log"])(evtName, /* @__PURE__ */ dumpObj(theEvt));
          }
        }
      }
      var NODE_UNHANDLED_REJECTION = "unhandledRejection";
      var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
      var _unhandledRejectionTimeout = 10;
      var _hasPromiseRejectionEvent;
      function dumpFnObj(value) {
        if (isFunction(value)) {
          return value.toString();
        }
        return /* @__PURE__ */ dumpObj(value);
      }
      function _createPromise(newPromise, processor, executor) {
        var additionalArgs = arrSlice(arguments, 3);
        var _state = 0;
        var _hasResolved = false;
        var _settledValue;
        var _queue = [];
        var _handled = false;
        var _unHandledRejectionHandler = null;
        var _thePromise;
        function _then(onResolved, onRejected) {
          try {
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            var thenPromise = newPromise(function(resolve3, reject) {
              _queue.push(function() {
                try {
                  var handler = _state === 2 ? onResolved : onRejected;
                  var value = /* @__PURE__ */ isUndefined(handler) ? _settledValue : isFunction(handler) ? handler(_settledValue) : handler;
                  if (/* @__PURE__ */ isPromiseLike(value)) {
                    value.then(resolve3, reject);
                  } else if (handler) {
                    resolve3(value);
                  } else if (_state === 3) {
                    reject(value);
                  } else {
                    resolve3(value);
                  }
                } catch (e) {
                  reject(e);
                }
              });
              if (_hasResolved) {
                _processQueue();
              }
            }, additionalArgs);
            return thenPromise;
          } finally {
          }
        }
        function _catch(onRejected) {
          return _then(void 0, onRejected);
        }
        function _finally(onFinally) {
          var thenFinally = onFinally;
          var catchFinally = onFinally;
          if (isFunction(onFinally)) {
            thenFinally = function(value) {
              onFinally && onFinally();
              return value;
            };
            catchFinally = function(reason) {
              onFinally && onFinally();
              throw reason;
            };
          }
          return _then(thenFinally, catchFinally);
        }
        function _strState() {
          return STRING_STATES[_state];
        }
        function _processQueue() {
          if (_queue.length > 0) {
            var pending = _queue.slice();
            _queue = [];
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            processor(pending);
          }
        }
        function _createSettleIfFn(newState, allowState) {
          return function(theValue) {
            if (_state === allowState) {
              if (newState === 2 && /* @__PURE__ */ isPromiseLike(theValue)) {
                _state = 1;
                theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
                return;
              }
              _state = newState;
              _hasResolved = true;
              _settledValue = theValue;
              _processQueue();
              if (!_handled && newState === 3 && !_unHandledRejectionHandler) {
                _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
              }
            }
          };
        }
        function _notifyUnhandledRejection() {
          if (!_handled) {
            _handled = true;
            if (isNode()) {
              process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            } else {
              var gbl = getWindow() || getGlobal();
              !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = /* @__PURE__ */ createCachedValue(safe(getInst, [STR_PROMISE + "RejectionEvent"]).v));
              emitEvent(gbl, UNHANDLED_REJECTION, function(theEvt) {
                objDefine(theEvt, "promise", { g: function() {
                  return _thePromise;
                } });
                theEvt.reason = _settledValue;
                return theEvt;
              }, !!_hasPromiseRejectionEvent.v);
            }
          }
        }
        _thePromise = {
          then: _then,
          "catch": _catch,
          finally: _finally
        };
        objDefineProp(_thePromise, "state", {
          get: _strState
        });
        if (/* @__PURE__ */ hasSymbol()) {
          _thePromise[/* @__PURE__ */ getKnownSymbol(11)] = "IPromise";
        }
        function _toString() {
          return "IPromise " + _strState() + (_hasResolved ? " - " + dumpFnObj(_settledValue) : "");
        }
        _thePromise.toString = _toString;
        (function _initialize() {
          if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
          }
          var _rejectFn = _createSettleIfFn(3, 0);
          try {
            executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
          } catch (e) {
            _rejectFn(e);
          }
        })();
        return _thePromise;
      }
      // @__NO_SIDE_EFFECTS__
      function _createAllPromise(newPromise) {
        return function(input) {
          var additionalArgs = arrSlice(arguments, 1);
          return newPromise(function(resolve3, reject) {
            try {
              var values_1 = [];
              var pending_1 = 1;
              iterForOf(input, function(item, idx) {
                if (item) {
                  pending_1++;
                  doAwait(item, function(value) {
                    values_1[idx] = value;
                    if (--pending_1 === 0) {
                      resolve3(values_1);
                    }
                  }, reject);
                }
              });
              pending_1--;
              if (pending_1 === 0) {
                resolve3(values_1);
              }
            } catch (e) {
              reject(e);
            }
          }, additionalArgs);
        };
      }
      // @__NO_SIDE_EFFECTS__
      function _createAllSettledPromise(newPromise) {
        return /* @__PURE__ */ createCachedValue(function(input) {
          var additionalArgs = arrSlice(arguments, 1);
          return newPromise(function(resolve3, reject) {
            var values = [];
            var pending = 1;
            function processItem(item, idx) {
              pending++;
              doAwaitResponse(item, function(value) {
                if (value.rejected) {
                  values[idx] = {
                    status: REJECTED,
                    reason: value.reason
                  };
                } else {
                  values[idx] = {
                    status: "fulfilled",
                    value: value.value
                  };
                }
                if (--pending === 0) {
                  resolve3(values);
                }
              });
            }
            try {
              if (isArray(input)) {
                arrForEach(input, processItem);
              } else if (/* @__PURE__ */ isIterable(input)) {
                iterForOf(input, processItem);
              } else {
                throwTypeError("Input is not an iterable");
              }
              pending--;
              if (pending === 0) {
                resolve3(values);
              }
            } catch (e) {
              reject(e);
            }
          }, additionalArgs);
        });
      }
      function syncItemProcessor(pending) {
        arrForEach(pending, function(fn) {
          try {
            fn();
          } catch (e) {
          }
        });
      }
      function timeoutItemProcessor(timeout) {
        var callbackTimeout = isNumber(timeout) ? timeout : 0;
        return function(pending) {
          scheduleTimeout(function() {
            syncItemProcessor(pending);
          }, callbackTimeout);
        };
      }
      function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
      }
      var _promiseCls;
      function createNativePromise(executor, timeout) {
        !_promiseCls && (_promiseCls = /* @__PURE__ */ createCachedValue(safe(getInst, [STR_PROMISE]).v || null));
        var PrmCls = _promiseCls.v;
        if (!PrmCls) {
          return createAsyncPromise(executor);
        }
        if (!isFunction(executor)) {
          throwTypeError(STR_PROMISE + ": executor is not a function - " + /* @__PURE__ */ dumpObj(executor));
        }
        var _state = 0;
        function _strState() {
          return STRING_STATES[_state];
        }
        var thePromise = new PrmCls(function(resolve3, reject) {
          function _resolve(value) {
            _state = 2;
            resolve3(value);
          }
          function _reject(reason) {
            _state = 3;
            reject(reason);
          }
          executor(_resolve, _reject);
        });
        objDefineProp(thePromise, "state", {
          get: _strState
        });
        return thePromise;
      }
      var _allSyncSettledCreator;
      function createSyncPromise(executor) {
        return _createPromise(createSyncPromise, syncItemProcessor, executor);
      }
      function createSyncAllSettledPromise(input, timeout) {
        !_allSyncSettledCreator && (_allSyncSettledCreator = /* @__PURE__ */ _createAllSettledPromise(createSyncPromise));
        return _allSyncSettledCreator.v(input, timeout);
      }
      var _promiseCreator;
      function createPromise(executor, timeout) {
        !_promiseCreator && (_promiseCreator = /* @__PURE__ */ createCachedValue(createNativePromise));
        return _promiseCreator.v.call(this, executor, timeout);
      }
      var createAllPromise = /* @__PURE__ */ _createAllPromise(createPromise);
      var UNDEFINED_VALUE$2 = void 0;
      var STR_EMPTY$1 = "";
      var STR_CHANNELS = "channels";
      var STR_CORE = "core";
      var STR_CREATE_PERF_MGR = "createPerfMgr";
      var STR_DISABLED = "disabled";
      var STR_EXTENSION_CONFIG = "extensionConfig";
      var STR_EXTENSIONS = "extensions";
      var STR_PROCESS_TELEMETRY = "processTelemetry";
      var STR_PRIORITY = "priority";
      var STR_EVENTS_SENT = "eventsSent";
      var STR_EVENTS_DISCARDED = "eventsDiscarded";
      var STR_EVENTS_SEND_REQUEST = "eventsSendRequest";
      var STR_PERF_EVENT = "perfEvent";
      var STR_OFFLINE_STORE = "offlineEventsStored";
      var STR_OFFLINE_SENT = "offlineBatchSent";
      var STR_OFFLINE_DROP = "offlineBatchDrop";
      var STR_GET_PERF_MGR = "getPerfMgr";
      var STR_DOMAIN = "domain";
      var STR_PATH = "path";
      var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";
      var rCamelCase = /-([a-z])/g;
      var rNormalizeInvalid = /([^\w\d_$])/g;
      var rLeadingNumeric = /^(\d+[\w\d_$])/;
      function isNotNullOrUndefined(value) {
        return !/* @__PURE__ */ isNullOrUndefined(value);
      }
      function normalizeJsName(name) {
        var value = name;
        if (value && isString(value)) {
          value = value[_DYN_REPLACE](rCamelCase, function(_all, letter) {
            return letter.toUpperCase();
          });
          value = value[_DYN_REPLACE](rNormalizeInvalid, "_");
          value = value[_DYN_REPLACE](rLeadingNumeric, function(_all, match) {
            return "_" + match;
          });
        }
        return value;
      }
      function strContains(value, search) {
        if (value && search) {
          return strIndexOf(value, search) !== -1;
        }
        return false;
      }
      function toISOString(date) {
        return date && date.toISOString() || "";
      }
      function getExceptionName(object) {
        if (isError(object)) {
          return object[_DYN_NAME$2];
        }
        return STR_EMPTY$1;
      }
      function setValue(target, field, value, valChk, srcChk) {
        var theValue = value;
        if (target) {
          theValue = target[field];
          if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
            theValue = value;
            target[field] = theValue;
          }
        }
        return theValue;
      }
      function getSetValue(target, field, defValue) {
        var theValue;
        if (target) {
          theValue = target[field];
          if (!theValue && /* @__PURE__ */ isNullOrUndefined(theValue)) {
            theValue = !/* @__PURE__ */ isUndefined(defValue) ? defValue : {};
            target[field] = theValue;
          }
        } else {
          theValue = !/* @__PURE__ */ isUndefined(defValue) ? defValue : {};
        }
        return theValue;
      }
      function _createProxyFunction(source, funcName) {
        var srcFunc = null;
        var src = null;
        if (isFunction(source)) {
          srcFunc = source;
        } else {
          src = source;
        }
        return function() {
          var originalArguments = arguments;
          if (srcFunc) {
            src = srcFunc();
          }
          if (src) {
            return src[funcName][_DYN_APPLY](src, originalArguments);
          }
        };
      }
      function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
        if (target && name && source) {
          if (overwriteTarget !== false || /* @__PURE__ */ isUndefined(target[name])) {
            target[name] = _createProxyFunction(source, theFunc);
          }
        }
      }
      function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
        if (target && source && /* @__PURE__ */ isObject(target) && isArray(functionsToProxy)) {
          arrForEach(functionsToProxy, function(theFuncName) {
            if (isString(theFuncName)) {
              proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
            }
          });
        }
        return target;
      }
      function createClassFromInterface(defaults) {
        return (
          /** @class */
          /* @__PURE__ */ function() {
            function class_1() {
              var _this = this;
              if (defaults) {
                objForEachKey(defaults, function(field, value) {
                  _this[field] = value;
                });
              }
            }
            return class_1;
          }()
        );
      }
      function optimizeObject(theObject) {
        if (theObject && objAssign) {
          theObject = ObjClass(objAssign({}, theObject));
        }
        return theObject;
      }
      function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
        var theArgs = arguments;
        var extended = theArgs[0] || {};
        var argLen = theArgs[_DYN_LENGTH$2];
        var deep = false;
        var idx = 1;
        if (argLen > 0 && isBoolean(extended)) {
          deep = extended;
          extended = theArgs[idx] || {};
          idx++;
        }
        if (!/* @__PURE__ */ isObject(extended)) {
          extended = {};
        }
        for (; idx < argLen; idx++) {
          var arg = theArgs[idx];
          var isArgArray = isArray(arg);
          var isArgObj = /* @__PURE__ */ isObject(arg);
          for (var prop in arg) {
            var propOk = isArgArray && prop in arg || isArgObj && objHasOwn(arg, prop);
            if (!propOk) {
              continue;
            }
            var newValue = arg[prop];
            var isNewArray = void 0;
            if (deep && newValue && ((isNewArray = isArray(newValue)) || /* @__PURE__ */ isPlainObject(newValue))) {
              var clone = extended[prop];
              if (isNewArray) {
                if (!isArray(clone)) {
                  clone = [];
                }
              } else if (!/* @__PURE__ */ isPlainObject(clone)) {
                clone = {};
              }
              newValue = objExtend(deep, clone, newValue);
            }
            if (newValue !== void 0) {
              extended[prop] = newValue;
            }
          }
        }
        return extended;
      }
      function isFeatureEnabled(feature, cfg, sdkDefaultState) {
        var ft = cfg && cfg.featureOptIn && cfg.featureOptIn[feature];
        if (feature && ft) {
          var mode = ft.mode;
          if (mode === 3) {
            return true;
          } else if (mode === 2) {
            return false;
          }
        }
        return sdkDefaultState;
      }
      function getResponseText(xhr) {
        try {
          return xhr.responseText;
        } catch (e) {
        }
        return null;
      }
      function formatErrorMessageXdr(xdr, message) {
        if (xdr) {
          return "XDomainRequest,Response:" + getResponseText(xdr) || "";
        }
        return message;
      }
      function formatErrorMessageXhr(xhr, message) {
        if (xhr) {
          return "XMLHttpRequest,Status:" + xhr[_DYN_STATUS] + ",Response:" + getResponseText(xhr) || xhr.response || "";
        }
        return message;
      }
      function prependTransports(theTransports, newTransports) {
        if (newTransports) {
          if (isNumber(newTransports)) {
            theTransports = [newTransports].concat(theTransports);
          } else if (isArray(newTransports)) {
            theTransports = newTransports.concat(theTransports);
          }
        }
        return theTransports;
      }
      var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var strWithCredentials = "withCredentials";
      var strTimeout = "timeout";
      function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) {
          disabled = false;
        }
        if (isSync === void 0) {
          isSync = false;
        }
        function _wrapSetXhrProp(xhr2, prop, value) {
          try {
            xhr2[prop] = value;
          } catch (e) {
          }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
          _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
        }
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        if (!isSync && timeout) {
          _wrapSetXhrProp(xhr, strTimeout, timeout);
        }
        return xhr;
      }
      function convertAllHeadersToMap(headersString) {
        var headers = {};
        if (isString(headersString)) {
          var headersArray = strTrim(headersString)[_DYN_SPLIT$1](/[\r\n]+/);
          arrForEach(headersArray, function(headerEntry) {
            if (headerEntry) {
              var idx = headerEntry[_DYN_INDEX_OF](": ");
              if (idx !== -1) {
                var header = strTrim(headerEntry.substring(0, idx))[_DYN_TO_LOWER_CASE$1]();
                var value = strTrim(headerEntry.substring(idx + 1));
                headers[header] = value;
              } else {
                headers[strTrim(headerEntry)] = 1;
              }
            }
          });
        }
        return headers;
      }
      function _appendHeader(theHeaders, xhr, name) {
        if (!theHeaders[name] && xhr && xhr.getResponseHeader) {
          var value = xhr.getResponseHeader(name);
          if (value) {
            theHeaders[name] = strTrim(value);
          }
        }
        return theHeaders;
      }
      var STR_KILL_DURATION_HEADER = "kill-duration";
      var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
      var STR_TIME_DELTA_HEADER = "time-delta-millis";
      function _getAllResponseHeaders(xhr, isOneDs) {
        var theHeaders = {};
        if (!xhr[_DYN_GET_ALL_RESPONSE_HEA5]) {
          if (!!isOneDs) {
            theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
          }
        } else {
          theHeaders = convertAllHeadersToMap(xhr[_DYN_GET_ALL_RESPONSE_HEA5]());
        }
        return theHeaders;
      }
      var strDocumentMode = "documentMode";
      var strLocation = "location";
      var strConsole = "console";
      var strJSON = "JSON";
      var strCrypto = "crypto";
      var strMsCrypto = "msCrypto";
      var strMsie = "msie";
      var strTrident = "trident/";
      var strXMLHttpRequest = "XMLHttpRequest";
      var _isTrident = null;
      var _navUserAgentCheck = null;
      var _enableMocks = false;
      var _useXDomainRequest = null;
      var _beaconsSupported = null;
      function _hasProperty(theClass, property) {
        var supported = false;
        if (theClass) {
          try {
            supported = property in theClass;
            if (!supported) {
              var proto = theClass[strShimPrototype];
              if (proto) {
                supported = property in proto;
              }
            }
          } catch (e) {
          }
          if (!supported) {
            try {
              var tmp = new theClass();
              supported = !/* @__PURE__ */ isUndefined(tmp[property]);
            } catch (e) {
            }
          }
        }
        return supported;
      }
      function getLocation(checkForMock) {
        if (checkForMock && _enableMocks) {
          var mockLocation = /* @__PURE__ */ getInst("__mockLocation");
          if (mockLocation) {
            return mockLocation;
          }
        }
        if (typeof location === strShimObject && location) {
          return location;
        }
        return /* @__PURE__ */ getInst(strLocation);
      }
      function getConsole() {
        if (typeof console !== strShimUndefined) {
          return console;
        }
        return /* @__PURE__ */ getInst(strConsole);
      }
      function hasJSON() {
        return Boolean(typeof JSON === strShimObject && JSON || /* @__PURE__ */ getInst(strJSON) !== null);
      }
      function getJSON() {
        if (hasJSON()) {
          return JSON || /* @__PURE__ */ getInst(strJSON);
        }
        return null;
      }
      function getCrypto() {
        return /* @__PURE__ */ getInst(strCrypto);
      }
      function getMsCrypto() {
        return /* @__PURE__ */ getInst(strMsCrypto);
      }
      function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
          _navUserAgentCheck = nav[_DYN_USER_AGENT];
          var userAgent = (_navUserAgentCheck || STR_EMPTY$1)[_DYN_TO_LOWER_CASE$1]();
          _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
        }
        return _isTrident;
      }
      function getIEVersion(userAgentStr) {
        if (userAgentStr === void 0) {
          userAgentStr = null;
        }
        if (!userAgentStr) {
          var navigator_1 = getNavigator() || {};
          userAgentStr = navigator_1 ? (navigator_1.userAgent || STR_EMPTY$1)[_DYN_TO_LOWER_CASE$1]() : STR_EMPTY$1;
        }
        var ua = (userAgentStr || STR_EMPTY$1)[_DYN_TO_LOWER_CASE$1]();
        if (strContains(ua, strMsie)) {
          var doc = getDocument() || {};
          return mathMax(parseInt(ua[_DYN_SPLIT$1](strMsie)[1]), doc[strDocumentMode] || 0);
        } else if (strContains(ua, strTrident)) {
          var tridentVer = parseInt(ua[_DYN_SPLIT$1](strTrident)[1]);
          if (tridentVer) {
            return tridentVer + 4;
          }
        }
        return null;
      }
      function isBeaconsSupported(useCached) {
        if (_beaconsSupported === null || useCached === false) {
          _beaconsSupported = /* @__PURE__ */ hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
      }
      function isFetchSupported(withKeepAlive) {
        var isSupported = false;
        try {
          isSupported = !!/* @__PURE__ */ getInst("fetch");
          var request = /* @__PURE__ */ getInst("Request");
          if (isSupported && withKeepAlive && request) {
            isSupported = _hasProperty(request, "keepalive");
          }
        } catch (e) {
        }
        return isSupported;
      }
      function useXDomainRequest() {
        if (_useXDomainRequest === null) {
          _useXDomainRequest = typeof XDomainRequest !== strShimUndefined;
          if (_useXDomainRequest && isXhrSupported()) {
            _useXDomainRequest = _useXDomainRequest && !_hasProperty(/* @__PURE__ */ getInst(strXMLHttpRequest), "withCredentials");
          }
        }
        return _useXDomainRequest;
      }
      function isXhrSupported() {
        var isSupported = false;
        try {
          var xmlHttpRequest = /* @__PURE__ */ getInst(strXMLHttpRequest);
          isSupported = !!xmlHttpRequest;
        } catch (e) {
        }
        return isSupported;
      }
      var UInt32Mask = 4294967296;
      var MaxUInt32 = 4294967295;
      var SEED1 = 123456789;
      var SEED2 = 987654321;
      var _mwcSeeded = false;
      var _mwcW = SEED1;
      var _mwcZ = SEED2;
      function _mwcSeed(seedValue) {
        if (seedValue < 0) {
          seedValue >>>= 0;
        }
        _mwcW = SEED1 + seedValue & MaxUInt32;
        _mwcZ = SEED2 - seedValue & MaxUInt32;
        _mwcSeeded = true;
      }
      function _autoSeedMwc() {
        try {
          var now = /* @__PURE__ */ utcNow() & 2147483647;
          _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
        } catch (e) {
        }
      }
      function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
          value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
          if (!_mwcSeeded) {
            _autoSeedMwc();
          }
          value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
          value = mathFloor(UInt32Mask * Math.random() | 0);
        }
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function mwcRandom32(signed) {
        _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32;
        _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
        var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function newId(maxLength) {
        if (maxLength === void 0) {
          maxLength = 22;
        }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY$1;
        while (result[_DYN_LENGTH$2] < maxLength) {
          chars++;
          result += base64chars.charAt(number & 63);
          number >>>= 6;
          if (chars === 5) {
            number = (random32() << 2 & 4294967295 | number & 3) >>> 0;
            chars = 0;
          }
        }
        return result;
      }
      var version = "3.3.7";
      var instanceName = "." + newId(6);
      var _dataUid = 0;
      function _canAcceptData(target) {
        return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
      }
      function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
          theCache = {};
          try {
            if (_canAcceptData(target)) {
              objDefine(target, data.id, {
                e: false,
                v: theCache
              });
            }
          } catch (e) {
          }
        }
        return theCache;
      }
      function createUniqueNamespace(name, includeVersion) {
        if (includeVersion === void 0) {
          includeVersion = false;
        }
        return normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY$1) + instanceName);
      }
      function createElmNodeData(name) {
        var data = {
          id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY$1) + "." + version),
          accept: function(target) {
            return _canAcceptData(target);
          },
          get: function(target, name2, defValue, addDefault) {
            var theCache = target[data.id];
            if (!theCache) {
              if (addDefault) {
                theCache = _getCache(data, target);
                theCache[normalizeJsName(name2)] = defValue;
              }
              return defValue;
            }
            return theCache[normalizeJsName(name2)];
          },
          kill: function(target, name2) {
            if (target && target[name2]) {
              try {
                delete target[name2];
              } catch (e) {
              }
            }
          }
        };
        return data;
      }
      function _isConfigDefaults(value) {
        return value && /* @__PURE__ */ isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
      }
      function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
        var defValue;
        var isDefaultValid = cfgDefaults.dfVal || isDefined;
        if (theConfig && cfgDefaults.fb) {
          var fallbacks = cfgDefaults.fb;
          if (!isArray(fallbacks)) {
            fallbacks = [fallbacks];
          }
          for (var lp = 0; lp < fallbacks[_DYN_LENGTH$2]; lp++) {
            var fallback = fallbacks[lp];
            var fbValue = theConfig[fallback];
            if (isDefaultValid(fbValue)) {
              defValue = fbValue;
            } else if (dynamicHandler) {
              fbValue = dynamicHandler.cfg[fallback];
              if (isDefaultValid(fbValue)) {
                defValue = fbValue;
              }
              dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);
            }
            if (isDefaultValid(defValue)) {
              break;
            }
          }
        }
        if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
          defValue = cfgDefaults.v;
        }
        return defValue;
      }
      function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
        var theValue = cfgDefaults;
        if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
          theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        }
        if (theValue) {
          if (_isConfigDefaults(theValue)) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
          }
          var newValue_1;
          if (isArray(theValue)) {
            newValue_1 = [];
            newValue_1[_DYN_LENGTH$2] = theValue[_DYN_LENGTH$2];
          } else if (/* @__PURE__ */ isPlainObject(theValue)) {
            newValue_1 = {};
          }
          if (newValue_1) {
            objForEachKey(theValue, function(key, value) {
              if (value && _isConfigDefaults(value)) {
                value = _resolveDefaultValue(dynamicHandler, theConfig, value);
              }
              newValue_1[key] = value;
            });
            theValue = newValue_1;
          }
        }
        return theValue;
      }
      function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
        var isValid;
        var setFn;
        var defValue;
        var cfgDefaults = defaultValue;
        var mergeDf;
        var reference;
        var readOnly;
        var blkDynamicValue;
        if (_isConfigDefaults(cfgDefaults)) {
          isValid = cfgDefaults.isVal;
          setFn = cfgDefaults.set;
          readOnly = cfgDefaults.rdOnly;
          blkDynamicValue = cfgDefaults.blkVal;
          mergeDf = cfgDefaults.mrg;
          reference = cfgDefaults.ref;
          if (!reference && /* @__PURE__ */ isUndefined(reference)) {
            reference = !!mergeDf;
          }
          defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
        } else {
          defValue = defaultValue;
        }
        if (blkDynamicValue) {
          dynamicHandler.blkVal(theConfig, name);
        }
        var theValue;
        var usingDefault = true;
        var cfgValue = theConfig[name];
        if (cfgValue || !/* @__PURE__ */ isNullOrUndefined(cfgValue)) {
          theValue = cfgValue;
          usingDefault = false;
          if (isValid && theValue !== defValue && !isValid(theValue)) {
            theValue = defValue;
            usingDefault = true;
          }
          if (setFn) {
            theValue = setFn(theValue, defValue, theConfig);
            usingDefault = theValue === defValue;
          }
        }
        if (!usingDefault) {
          if (/* @__PURE__ */ isPlainObject(theValue) || isArray(defValue)) {
            if (mergeDf && defValue && (/* @__PURE__ */ isPlainObject(defValue) || isArray(defValue))) {
              objForEachKey(defValue, function(dfName, dfValue) {
                _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
              });
            }
          }
        } else if (defValue) {
          theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
        } else {
          theValue = defValue;
        }
        dynamicHandler.set(theConfig, name, theValue);
        if (reference) {
          dynamicHandler.ref(theConfig, name);
        }
        if (readOnly) {
          dynamicHandler.rdOnly(theConfig, name);
        }
      }
      var CFG_HANDLER_LINK = /* @__PURE__ */ symbolFor("[[ai_dynCfg_1]]");
      var BLOCK_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_blkDynCfg_1]]");
      var FORCE_DYNAMIC = /* @__PURE__ */ symbolFor("[[ai_frcDynCfg_1]]");
      function _cfgDeepCopy(source) {
        if (source) {
          var target_1;
          if (isArray(source)) {
            target_1 = [];
            target_1[_DYN_LENGTH$2] = source[_DYN_LENGTH$2];
          } else if (/* @__PURE__ */ isPlainObject(source)) {
            target_1 = {};
          }
          if (target_1) {
            objForEachKey(source, function(key, value) {
              target_1[key] = _cfgDeepCopy(value);
            });
            return target_1;
          }
        }
        return source;
      }
      function getDynamicConfigHandler(value) {
        if (value) {
          var handler = value[CFG_HANDLER_LINK] || value;
          if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler;
          }
        }
        return null;
      }
      function blockDynamicConversion(value) {
        if (value && (/* @__PURE__ */ isPlainObject(value) || isArray(value))) {
          try {
            value[BLOCK_DYNAMIC] = true;
          } catch (e) {
          }
        }
        return value;
      }
      function _canMakeDynamic(getFunc, state, value) {
        var result = false;
        if (value && !getFunc[state.blkVal]) {
          result = value[FORCE_DYNAMIC];
          if (!result && !value[BLOCK_DYNAMIC]) {
            result = /* @__PURE__ */ isPlainObject(value) || isArray(value);
          }
        }
        return result;
      }
      function throwInvalidAccess(message) {
        throwTypeError("InvalidAccess:" + message);
      }
      var arrayMethodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
      ];
      var _throwDynamicError = function(logger2, name, desc, e) {
        logger2 && logger2[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + /* @__PURE__ */ dumpObj(e));
      };
      function _patchArray(state, target, name) {
        if (isArray(target)) {
          arrForEach(arrayMethodsToPatch, function(method) {
            var orgMethod = target[method];
            target[method] = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var result = orgMethod[_DYN_APPLY](this, args);
              _makeDynamicObject(state, target, name, "Patching");
              return result;
            };
          });
        }
      }
      function _getOwnPropGetter(target, name) {
        var propDesc = objGetOwnPropertyDescriptor(target, name);
        return propDesc && propDesc.get;
      }
      function _createDynamicProperty(state, theConfig, name, value) {
        var detail = {
          n: name,
          h: [],
          trk: function(handler) {
            if (handler && handler.fn) {
              if (arrIndexOf(detail.h, handler) === -1) {
                detail.h[_DYN_PUSH$1](handler);
              }
              state.trk(handler, detail);
            }
          },
          clr: function(handler) {
            var idx = arrIndexOf(detail.h, handler);
            if (idx !== -1) {
              detail.h[_DYN_SPLICE](idx, 1);
            }
          }
        };
        var checkDynamic = true;
        var isObjectOrArray = false;
        function _getProperty() {
          if (checkDynamic) {
            isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
            if (value && !value[CFG_HANDLER_LINK] && isObjectOrArray) {
              value = _makeDynamicObject(state, value, name, "Converting");
            }
            checkDynamic = false;
          }
          var activeHandler = state.act;
          if (activeHandler) {
            detail.trk(activeHandler);
          }
          return value;
        }
        _getProperty[state.prop] = {
          chng: function() {
            state.add(detail);
          }
        };
        function _setProperty(newValue) {
          if (value !== newValue) {
            if (!!_getProperty[state.ro] && !state.upd) {
              throwInvalidAccess("[" + name + "] is read-only:" + /* @__PURE__ */ dumpObj(theConfig));
            }
            if (checkDynamic) {
              isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value);
              checkDynamic = false;
            }
            var isReferenced = isObjectOrArray && _getProperty[state.rf];
            if (isObjectOrArray) {
              if (isReferenced) {
                objForEachKey(value, function(key) {
                  value[key] = newValue ? newValue[key] : UNDEFINED_VALUE$2;
                });
                try {
                  objForEachKey(newValue, function(key, theValue) {
                    _setDynamicProperty(state, value, key, theValue);
                  });
                  newValue = value;
                } catch (e) {
                  _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e);
                  isObjectOrArray = false;
                }
              } else if (value && value[CFG_HANDLER_LINK]) {
                objForEachKey(value, function(key) {
                  var getter = _getOwnPropGetter(value, key);
                  if (getter) {
                    var valueState = getter[state.prop];
                    valueState && valueState.chng();
                  }
                });
              }
            }
            if (newValue !== value) {
              var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
              if (!isReferenced && newIsObjectOrArray) {
                newValue = _makeDynamicObject(state, newValue, name, "Converting");
              }
              value = newValue;
              isObjectOrArray = newIsObjectOrArray;
            }
            state.add(detail);
          }
        }
        objDefine(theConfig, detail.n, { g: _getProperty, s: _setProperty });
      }
      function _setDynamicProperty(state, target, name, value) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          if (!isDynamic) {
            _createDynamicProperty(state, target, name, value);
          } else {
            target[name] = value;
          }
        }
        return target;
      }
      function _setDynamicPropertyState(state, target, name, flags) {
        if (target) {
          var getter = _getOwnPropGetter(target, name);
          var isDynamic = getter && !!getter[state.prop];
          var inPlace = flags && flags[0];
          var rdOnly = flags && flags[1];
          var blkProp = flags && flags[2];
          if (!isDynamic) {
            if (blkProp) {
              try {
                blockDynamicConversion(target);
              } catch (e) {
                _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
              }
            }
            try {
              _setDynamicProperty(state, target, name, target[name]);
              getter = _getOwnPropGetter(target, name);
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
            }
          }
          if (inPlace) {
            getter[state.rf] = inPlace;
          }
          if (rdOnly) {
            getter[state.ro] = rdOnly;
          }
          if (blkProp) {
            getter[state.blkVal] = true;
          }
        }
        return target;
      }
      function _makeDynamicObject(state, target, name, desc) {
        try {
          objForEachKey(target, function(key, value) {
            _setDynamicProperty(state, target, key, value);
          });
          if (!target[CFG_HANDLER_LINK]) {
            objDefineProp(target, CFG_HANDLER_LINK, {
              get: function() {
                return state.hdlr;
              }
            });
            _patchArray(state, target, name);
          }
        } catch (e) {
          _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
        }
        return target;
      }
      var symPrefix = "[[ai_";
      var symPostfix = "]]";
      function _createState(cfgHandler) {
        var dynamicPropertySymbol = /* @__PURE__ */ newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReadOnly = /* @__PURE__ */ newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix);
        var dynamicPropertyReferenced = /* @__PURE__ */ newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix);
        var dynamicPropertyBlockValue = /* @__PURE__ */ newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
        var dynamicPropertyDetail = /* @__PURE__ */ newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
        var _waitingHandlers = null;
        var _watcherTimer = null;
        var theState;
        function _useHandler(activeHandler, callback) {
          var prevWatcher = theState.act;
          try {
            theState.act = activeHandler;
            if (activeHandler && activeHandler[dynamicPropertyDetail]) {
              arrForEach(activeHandler[dynamicPropertyDetail], function(detail) {
                detail.clr(activeHandler);
              });
              activeHandler[dynamicPropertyDetail] = [];
            }
            callback({
              cfg: cfgHandler.cfg,
              set: cfgHandler.set.bind(cfgHandler),
              setDf: cfgHandler.setDf.bind(cfgHandler),
              ref: cfgHandler.ref.bind(cfgHandler),
              rdOnly: cfgHandler.rdOnly.bind(cfgHandler)
            });
          } catch (e) {
            var logger2 = cfgHandler[_DYN_LOGGER];
            if (logger2) {
              logger2[_DYN_THROW_INTERNAL](1, 107, /* @__PURE__ */ dumpObj(e));
            }
            throw e;
          } finally {
            theState.act = prevWatcher || null;
          }
        }
        function _notifyWatchers() {
          if (_waitingHandlers) {
            var notifyHandlers = _waitingHandlers;
            _waitingHandlers = null;
            _watcherTimer && _watcherTimer[_DYN_CANCEL]();
            _watcherTimer = null;
            var watcherFailures_1 = [];
            arrForEach(notifyHandlers, function(handler) {
              if (handler) {
                if (handler[dynamicPropertyDetail]) {
                  arrForEach(handler[dynamicPropertyDetail], function(detail) {
                    detail.clr(handler);
                  });
                  handler[dynamicPropertyDetail] = null;
                }
                if (handler.fn) {
                  try {
                    _useHandler(handler, handler.fn);
                  } catch (e) {
                    watcherFailures_1[_DYN_PUSH$1](e);
                  }
                }
              }
            });
            if (_waitingHandlers) {
              try {
                _notifyWatchers();
              } catch (e) {
                watcherFailures_1[_DYN_PUSH$1](e);
              }
            }
            if (watcherFailures_1[_DYN_LENGTH$2] > 0) {
              throwAggregationError("Watcher error(s): ", watcherFailures_1);
            }
          }
        }
        function _addWatcher(detail) {
          if (detail && detail.h[_DYN_LENGTH$2] > 0) {
            if (!_waitingHandlers) {
              _waitingHandlers = [];
            }
            if (!_watcherTimer) {
              _watcherTimer = scheduleTimeout(function() {
                _watcherTimer = null;
                _notifyWatchers();
              }, 0);
            }
            for (var idx = 0; idx < detail.h[_DYN_LENGTH$2]; idx++) {
              var handler = detail.h[idx];
              if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {
                _waitingHandlers[_DYN_PUSH$1](handler);
              }
            }
          }
        }
        function _trackHandler(handler, detail) {
          if (handler) {
            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
            if (arrIndexOf(details, detail) === -1) {
              details[_DYN_PUSH$1](detail);
            }
          }
        }
        theState = {
          prop: dynamicPropertySymbol,
          ro: dynamicPropertyReadOnly,
          rf: dynamicPropertyReferenced,
          blkVal: dynamicPropertyBlockValue,
          hdlr: cfgHandler,
          add: _addWatcher,
          notify: _notifyWatchers,
          use: _useHandler,
          trk: _trackHandler
        };
        return theState;
      }
      function _createAndUseHandler(state, configHandler) {
        var handler = {
          fn: configHandler,
          rm: function() {
            handler.fn = null;
            state = null;
            configHandler = null;
          }
        };
        objDefine(handler, "toJSON", { v: function() {
          return "WatcherHandler" + (handler.fn ? "" : "[X]");
        } });
        state.use(handler, configHandler);
        return handler;
      }
      function _createDynamicHandler(logger2, target, inPlace) {
        var dynamicHandler = getDynamicConfigHandler(target);
        if (dynamicHandler) {
          return dynamicHandler;
        }
        var uid = createUniqueNamespace("dyncfg", true);
        var newTarget = target && inPlace !== false ? target : _cfgDeepCopy(target);
        var theState;
        function _notifyWatchers() {
          theState.notify();
        }
        function _setValue(target2, name, value) {
          try {
            target2 = _setDynamicProperty(theState, target2, name, value);
          } catch (e) {
            _throwDynamicError(logger2, name, "Setting value", e);
          }
          return target2[name];
        }
        function _watch(configHandler) {
          return _createAndUseHandler(theState, configHandler);
        }
        function _block(configHandler, allowUpdate) {
          theState.use(null, function(details) {
            var prevUpd = theState.upd;
            try {
              if (!/* @__PURE__ */ isUndefined(allowUpdate)) {
                theState.upd = allowUpdate;
              }
              configHandler(details);
            } finally {
              theState.upd = prevUpd;
            }
          });
        }
        function _ref(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[0] = true, _a2))[name];
        }
        function _rdOnly(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[1] = true, _a2))[name];
        }
        function _blkPropValue(target2, name) {
          var _a2;
          return _setDynamicPropertyState(theState, target2, name, (_a2 = {}, _a2[2] = true, _a2))[name];
        }
        function _applyDefaults(theConfig, defaultValues2) {
          if (defaultValues2) {
            objForEachKey(defaultValues2, function(name, value) {
              _applyDefaultValue(cfgHandler, theConfig, name, value);
            });
          }
          return theConfig;
        }
        var cfgHandler = {
          uid: null,
          cfg: newTarget,
          logger: logger2,
          notify: _notifyWatchers,
          set: _setValue,
          setDf: _applyDefaults,
          watch: _watch,
          ref: _ref,
          rdOnly: _rdOnly,
          blkVal: _blkPropValue,
          _block
        };
        objDefine(cfgHandler, "uid", {
          c: false,
          e: false,
          w: false,
          v: uid
        });
        theState = _createState(cfgHandler);
        _makeDynamicObject(theState, newTarget, "config", "Creating");
        return cfgHandler;
      }
      function _logInvalidAccess(logger2, message) {
        if (logger2) {
          logger2[_DYN_WARN_TO_CONSOLE](message);
          logger2[_DYN_THROW_INTERNAL](2, 108, message);
        } else {
          throwInvalidAccess(message);
        }
      }
      function createDynamicConfig(config, defaultConfig2, logger2, inPlace) {
        var dynamicHandler = _createDynamicHandler(logger2, config || {}, inPlace);
        if (defaultConfig2) {
          dynamicHandler.setDf(dynamicHandler.cfg, defaultConfig2);
        }
        return dynamicHandler;
      }
      function onConfigChange(config, configHandler, logger2) {
        var handler = config[CFG_HANDLER_LINK] || config;
        if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {
          return handler[_DYN_WATCH](configHandler);
        }
        _logInvalidAccess(logger2, STR_NOT_DYNAMIC_ERROR + /* @__PURE__ */ dumpObj(config));
        return createDynamicConfig(config, null, logger2)[_DYN_WATCH](configHandler);
      }
      function runTargetUnload(target, isAsync) {
        if (target && target[_DYN_UNLOAD]) {
          return target[_DYN_UNLOAD](isAsync);
        }
      }
      function doUnloadAll(targets, isAsync, done) {
        var result;
        if (!done) {
          result = createPromise(function(resolved) {
            done = resolved;
          });
        }
        if (targets && getLength(targets) > 0) {
          doAwaitResponse(runTargetUnload(targets[0], isAsync), function() {
            doUnloadAll(arrSlice(targets, 1), isAsync, done);
          });
        } else {
          done();
        }
        return result;
      }
      var ChannelControllerPriority = 500;
      var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      function _stringToBoolOrDefault(theValue, defaultValue, theConfig) {
        if (!theValue && /* @__PURE__ */ isNullOrUndefined(theValue)) {
          return defaultValue;
        }
        if (isBoolean(theValue)) {
          return theValue;
        }
        return asString(theValue)[_DYN_TO_LOWER_CASE$1]() === "true";
      }
      function cfgDfMerge(defaultValue) {
        return {
          mrg: true,
          v: defaultValue
        };
      }
      function cfgDfValidate(validator, defaultValue, fallBackName) {
        return {
          fb: fallBackName,
          isVal: validator,
          v: defaultValue
        };
      }
      function cfgDfBoolean(defaultValue, fallBackName) {
        return {
          fb: fallBackName,
          set: _stringToBoolOrDefault,
          v: !!defaultValue
        };
      }
      var listenerFuncs = [STR_EVENTS_SENT, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_PERF_EVENT];
      var _aiNamespace = null;
      var _debugListener;
      function _listenerProxyFunc(name, config) {
        return function() {
          var args = arguments;
          var dbgExt = getDebugExt(config);
          if (dbgExt) {
            var listener = dbgExt.listener;
            if (listener && listener[name]) {
              listener[name][_DYN_APPLY](listener, args);
            }
          }
        };
      }
      function _getExtensionNamespace() {
        var target = /* @__PURE__ */ getInst("Microsoft");
        if (target) {
          _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
      }
      function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
          ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
      }
      function getDebugListener(config) {
        if (!_debugListener) {
          _debugListener = {};
          for (var lp = 0; lp < listenerFuncs[_DYN_LENGTH$2]; lp++) {
            _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
          }
        }
        return _debugListener;
      }
      var _a$5;
      var STR_WARN_TO_CONSOLE = "warnToConsole";
      var AiNonUserActionablePrefix = "AI (Internal): ";
      var AiUserActionablePrefix = "AI: ";
      var AIInternalMessagePrefix = "AITR_";
      var defaultValues$2 = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: false
      };
      var _logFuncs = (_a$5 = {}, _a$5[0] = null, _a$5[1] = "errorToConsole", _a$5[2] = STR_WARN_TO_CONSOLE, _a$5[3] = "debugToConsole", _a$5);
      function _sanitizeDiagnosticText(text) {
        if (text) {
          return '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY$1) + '"';
        }
        return STR_EMPTY$1;
      }
      function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
          var logFunc = "log";
          if (theConsole[func]) {
            logFunc = func;
          }
          if (isFunction(theConsole[logFunc])) {
            theConsole[logFunc](message);
          }
        }
      }
      var _InternalLogMessage = (
        /** @class */
        function() {
          function _InternalLogMessage2(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) {
              isUserAct = false;
            }
            var _self = this;
            _self[_DYN_MESSAGE_ID] = msgId;
            _self[_DYN_MESSAGE$1] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
            var strProps = STR_EMPTY$1;
            if (hasJSON()) {
              strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY$1) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY$1);
            _self[_DYN_MESSAGE$1] += diagnosticText;
          }
          _InternalLogMessage2.dataType = "MessageData";
          return _InternalLogMessage2;
        }()
      );
      function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
      }
      var DiagnosticLogger = (
        /** @class */
        function() {
          function DiagnosticLogger2(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            var _unloadHandler;
            dynamicProto(DiagnosticLogger2, this, function(_self) {
              _unloadHandler = _setDefaultsFromConfig(config || {});
              _self.consoleLoggingLevel = function() {
                return _loggingLevelConsole;
              };
              _self[_DYN_THROW_INTERNAL] = function(severity, msgId, msg, properties, isUserAct) {
                if (isUserAct === void 0) {
                  isUserAct = false;
                }
                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                if (_enableDebug) {
                  throw /* @__PURE__ */ dumpObj(message);
                } else {
                  var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                  if (!/* @__PURE__ */ isUndefined(message[_DYN_MESSAGE$1])) {
                    if (isUserAct) {
                      var messageKey = +message[_DYN_MESSAGE_ID];
                      if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE$1]);
                        _messageLogged[messageKey] = true;
                      }
                    } else {
                      if (_loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE$1]);
                      }
                    }
                    _logInternalMessage(severity, message);
                  } else {
                    _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);
                  }
                }
              };
              _self.debugToConsole = function(message) {
                _logToConsole("debug", message);
                _debugExtMsg("warning", message);
              };
              _self[_DYN_WARN_TO_CONSOLE] = function(message) {
                _logToConsole("warn", message);
                _debugExtMsg("warning", message);
              };
              _self.errorToConsole = function(message) {
                _logToConsole("error", message);
                _debugExtMsg("error", message);
              };
              _self.resetInternalMessageCount = function() {
                _messageCount = 0;
                _messageLogged = {};
              };
              _self.logInternalMessage = _logInternalMessage;
              _self[_DYN_UNLOAD] = function(isAsync) {
                _unloadHandler && _unloadHandler.rm();
                _unloadHandler = null;
              };
              function _logInternalMessage(severity, message) {
                if (_areInternalMessagesThrottled()) {
                  return;
                }
                var logMessage = true;
                var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
                if (_messageLogged[messageKey]) {
                  logMessage = false;
                } else {
                  _messageLogged[messageKey] = true;
                }
                if (logMessage) {
                  if (severity <= _loggingLevelTelemetry) {
                    _self.queue[_DYN_PUSH$1](message);
                    _messageCount++;
                    _debugExtMsg(severity === 1 ? "error" : "warn", message);
                  }
                  if (_messageCount === _maxInternalMessageLimit) {
                    var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                    var throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, false);
                    _self.queue[_DYN_PUSH$1](throttleMessage);
                    if (severity === 1) {
                      _self.errorToConsole(throttleLimitMessage);
                    } else {
                      _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
                    }
                  }
                }
              }
              function _setDefaultsFromConfig(config2) {
                return onConfigChange(createDynamicConfig(config2, defaultValues$2, _self).cfg, function(details) {
                  var config3 = details.cfg;
                  _loggingLevelConsole = config3[_DYN_LOGGING_LEVEL_CONSOL4];
                  _loggingLevelTelemetry = config3.loggingLevelTelemetry;
                  _maxInternalMessageLimit = config3.maxMessageLimit;
                  _enableDebug = config3.enableDebug;
                });
              }
              function _areInternalMessagesThrottled() {
                return _messageCount >= _maxInternalMessageLimit;
              }
              function _debugExtMsg(name, data) {
                var dbgExt = getDebugExt(config || {});
                if (dbgExt && dbgExt[_DYN_DIAG_LOG$1]) {
                  dbgExt[_DYN_DIAG_LOG$1](name, data);
                }
              }
            });
          }
          DiagnosticLogger2.__ieDyn = 1;
          return DiagnosticLogger2;
        }()
      );
      function _getLogger(logger2) {
        return logger2 || new DiagnosticLogger();
      }
      function _throwInternal(logger2, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) {
          isUserAct = false;
        }
        _getLogger(logger2)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
      }
      function _warnToConsole(logger2, message) {
        _getLogger(logger2)[_DYN_WARN_TO_CONSOLE](message);
      }
      var _a$4, _b$2;
      var strToGMTString = "toGMTString";
      var strToUTCString = "toUTCString";
      var strCookie = "cookie";
      var strExpires = "expires";
      var strIsCookieUseDisabled = "isCookieUseDisabled";
      var strDisableCookiesUsage = "disableCookiesUsage";
      var strConfigCookieMgr = "_ckMgr";
      var _supportsCookies = null;
      var _allowUaSameSite = null;
      var _parsedCookieValue = null;
      var _doc;
      var _cookieCache = {};
      var _globalCookieConfig = {};
      var rootDefaultConfig = (_a$4 = {
        cookieCfg: cfgDfMerge((_b$2 = {}, _b$2[STR_DOMAIN] = { fb: "cookieDomain", dfVal: isNotNullOrUndefined }, _b$2.path = { fb: "cookiePath", dfVal: isNotNullOrUndefined }, _b$2.enabled = UNDEFINED_VALUE$2, _b$2.ignoreCookies = UNDEFINED_VALUE$2, _b$2.blockedCookies = UNDEFINED_VALUE$2, _b$2)),
        cookieDomain: UNDEFINED_VALUE$2,
        cookiePath: UNDEFINED_VALUE$2
      }, _a$4[strDisableCookiesUsage] = UNDEFINED_VALUE$2, _a$4);
      function _getDoc() {
        !_doc && (_doc = /* @__PURE__ */ getLazy(function() {
          return getDocument();
        }));
      }
      function _isMgrEnabled(cookieMgr) {
        if (cookieMgr) {
          return cookieMgr.isEnabled();
        }
        return true;
      }
      function _isIgnoredCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.ignoreCookies)) {
          return arrIndexOf(cookieMgrCfg.ignoreCookies, name) !== -1;
        }
        return false;
      }
      function _isBlockedCookie(cookieMgrCfg, name) {
        if (name && cookieMgrCfg && isArray(cookieMgrCfg.blockedCookies)) {
          if (arrIndexOf(cookieMgrCfg.blockedCookies, name) !== -1) {
            return true;
          }
        }
        return _isIgnoredCookie(cookieMgrCfg, name);
      }
      function _isCfgEnabled(rootConfig, cookieMgrConfig) {
        var isCfgEnabled = cookieMgrConfig[_DYN_ENABLED];
        if (/* @__PURE__ */ isNullOrUndefined(isCfgEnabled)) {
          var cookieEnabled = void 0;
          if (!/* @__PURE__ */ isUndefined(rootConfig[strIsCookieUseDisabled])) {
            cookieEnabled = !rootConfig[strIsCookieUseDisabled];
          }
          if (!/* @__PURE__ */ isUndefined(rootConfig[strDisableCookiesUsage])) {
            cookieEnabled = !rootConfig[strDisableCookiesUsage];
          }
          isCfgEnabled = cookieEnabled;
        }
        return isCfgEnabled;
      }
      function createCookieMgr(rootConfig, logger2) {
        var cookieMgrConfig;
        var _path;
        var _domain;
        var unloadHandler;
        var _enabled;
        var _getCookieFn;
        var _setCookieFn;
        var _delCookieFn;
        rootConfig = createDynamicConfig(rootConfig || _globalCookieConfig, null, logger2).cfg;
        unloadHandler = onConfigChange(rootConfig, function(details) {
          details.setDf(details.cfg, rootDefaultConfig);
          cookieMgrConfig = details.ref(details.cfg, "cookieCfg");
          _path = cookieMgrConfig[STR_PATH] || "/";
          _domain = cookieMgrConfig[STR_DOMAIN];
          _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false;
          _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue;
          _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
          _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
        }, logger2);
        var cookieMgr = {
          isEnabled: function() {
            var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false && _enabled && areCookiesSupported(logger2);
            var gblManager = _globalCookieConfig[strConfigCookieMgr];
            if (enabled && gblManager && cookieMgr !== gblManager) {
              enabled = _isMgrEnabled(gblManager);
            }
            return enabled;
          },
          setEnabled: function(value) {
            _enabled = value !== false;
            cookieMgrConfig[_DYN_ENABLED] = value;
          },
          set: function(name, value, maxAgeSec, domain, path11) {
            var result = false;
            if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name)) {
              var values = {};
              var theValue = strTrim(value || STR_EMPTY$1);
              var idx = strIndexOf(theValue, ";");
              if (idx !== -1) {
                theValue = strTrim(/* @__PURE__ */ strLeft(value, idx));
                values = _extractParts(strSubstring(value, idx + 1));
              }
              setValue(values, STR_DOMAIN, domain || _domain, isTruthy, isUndefined);
              if (!/* @__PURE__ */ isNullOrUndefined(maxAgeSec)) {
                var _isIE = isIE();
                if (/* @__PURE__ */ isUndefined(values[strExpires])) {
                  var nowMs = /* @__PURE__ */ utcNow();
                  var expireMs = nowMs + maxAgeSec * 1e3;
                  if (expireMs > 0) {
                    var expiry = /* @__PURE__ */ new Date();
                    expiry.setTime(expireMs);
                    setValue(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || STR_EMPTY$1, isTruthy);
                  }
                }
                if (!_isIE) {
                  setValue(values, "max-age", STR_EMPTY$1 + maxAgeSec, null, isUndefined);
                }
              }
              var location_1 = getLocation();
              if (location_1 && location_1.protocol === "https:") {
                setValue(values, "secure", null, null, isUndefined);
                if (_allowUaSameSite === null) {
                  _allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT]);
                }
                if (_allowUaSameSite) {
                  setValue(values, "SameSite", "None", null, isUndefined);
                }
              }
              setValue(values, STR_PATH, path11 || _path, null, isUndefined);
              _setCookieFn(name, _formatCookieValue(theValue, values));
              result = true;
            }
            return result;
          },
          get: function(name) {
            var value = STR_EMPTY$1;
            if (_isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name)) {
              value = _getCookieFn(name);
            }
            return value;
          },
          del: function(name, path11) {
            var result = false;
            if (_isMgrEnabled(cookieMgr)) {
              result = cookieMgr.purge(name, path11);
            }
            return result;
          },
          purge: function(name, path11) {
            var _a2;
            var result = false;
            if (areCookiesSupported(logger2)) {
              var values = (_a2 = {}, _a2[STR_PATH] = path11 ? path11 : "/", _a2[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", _a2);
              if (!isIE()) {
                values["max-age"] = "0";
              }
              _delCookieFn(name, _formatCookieValue(STR_EMPTY$1, values));
              result = true;
            }
            return result;
          },
          unload: function(isAsync) {
            unloadHandler && unloadHandler.rm();
            unloadHandler = null;
          }
        };
        cookieMgr[strConfigCookieMgr] = cookieMgr;
        return cookieMgr;
      }
      function areCookiesSupported(logger2) {
        if (_supportsCookies === null) {
          _supportsCookies = false;
          !_doc && _getDoc();
          try {
            var doc = _doc.v || {};
            _supportsCookies = doc[strCookie] !== void 0;
          } catch (e) {
            _throwInternal(logger2, 2, 68, "Cannot access document.cookie - " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return _supportsCookies;
      }
      function _extractParts(theValue) {
        var values = {};
        if (theValue && theValue[_DYN_LENGTH$2]) {
          var parts = strTrim(theValue)[_DYN_SPLIT$1](";");
          arrForEach(parts, function(thePart) {
            thePart = strTrim(thePart || STR_EMPTY$1);
            if (thePart) {
              var idx = strIndexOf(thePart, "=");
              if (idx === -1) {
                values[thePart] = null;
              } else {
                values[strTrim(/* @__PURE__ */ strLeft(thePart, idx))] = strTrim(strSubstring(thePart, idx + 1));
              }
            }
          });
        }
        return values;
      }
      function _formatDate(theDate, func) {
        if (isFunction(theDate[func])) {
          return theDate[func]();
        }
        return null;
      }
      function _formatCookieValue(value, values) {
        var cookieValue = value || STR_EMPTY$1;
        objForEachKey(values, function(name, theValue) {
          cookieValue += "; " + name + (!/* @__PURE__ */ isNullOrUndefined(theValue) ? "=" + theValue : STR_EMPTY$1);
        });
        return cookieValue;
      }
      function _getCookieValue(name) {
        var cookieValue = STR_EMPTY$1;
        !_doc && _getDoc();
        if (_doc.v) {
          var theCookie = _doc.v[strCookie] || STR_EMPTY$1;
          if (_parsedCookieValue !== theCookie) {
            _cookieCache = _extractParts(theCookie);
            _parsedCookieValue = theCookie;
          }
          cookieValue = strTrim(_cookieCache[name] || STR_EMPTY$1);
        }
        return cookieValue;
      }
      function _setCookieValue(name, cookieValue) {
        !_doc && _getDoc();
        if (_doc.v) {
          _doc.v[strCookie] = name + "=" + cookieValue;
        }
      }
      function uaDisallowsSameSiteNone(userAgent) {
        if (!isString(userAgent)) {
          return false;
        }
        if (strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12")) {
          return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari")) {
          return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
          return true;
        }
        if (strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6")) {
          return true;
        }
        if (strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome")) {
          return true;
        }
        if (strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) {
          return true;
        }
        return false;
      }
      var defaultValues$1 = {
        perfEvtsSendAll: false
      };
      function _runScheduledListeners(asyncNotifications) {
        asyncNotifications.h = null;
        var callbacks = asyncNotifications.cb;
        asyncNotifications.cb = [];
        arrForEach(callbacks, function(cb) {
          safe(cb.fn, [cb.arg]);
        });
      }
      function _runListeners(listeners, name, asyncNotifications, callback) {
        arrForEach(listeners, function(listener) {
          if (listener && listener[name]) {
            if (asyncNotifications) {
              asyncNotifications.cb[_DYN_PUSH$1]({
                fn: callback,
                arg: listener
              });
              asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications);
            } else {
              safe(callback, [listener]);
            }
          }
        });
      }
      var NotificationManager = (
        /** @class */
        function() {
          function NotificationManager2(config) {
            this.listeners = [];
            var perfEvtsSendAll;
            var unloadHandler;
            var _listeners = [];
            var _asyncNotifications = {
              h: null,
              cb: []
            };
            var cfgHandler = createDynamicConfig(config, defaultValues$1);
            unloadHandler = cfgHandler[_DYN_WATCH](function(details) {
              perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
            });
            dynamicProto(NotificationManager2, this, function(_self) {
              objDefine(_self, "listeners", {
                g: function() {
                  return _listeners;
                }
              });
              _self[_DYN_ADD_NOTIFICATION_LIS1] = function(listener) {
                _listeners[_DYN_PUSH$1](listener);
              };
              _self[_DYN_REMOVE_NOTIFICATION_0] = function(listener) {
                var index = arrIndexOf(_listeners, listener);
                while (index > -1) {
                  _listeners[_DYN_SPLICE](index, 1);
                  index = arrIndexOf(_listeners, listener);
                }
              };
              _self[STR_EVENTS_SENT] = function(events) {
                _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function(listener) {
                  listener[STR_EVENTS_SENT](events);
                });
              };
              _self[STR_EVENTS_DISCARDED] = function(events, reason) {
                _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function(listener) {
                  listener[STR_EVENTS_DISCARDED](events, reason);
                });
              };
              _self[STR_EVENTS_SEND_REQUEST] = function(sendReason, isAsync) {
                _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function(listener) {
                  listener[STR_EVENTS_SEND_REQUEST](sendReason, isAsync);
                });
              };
              _self[STR_PERF_EVENT] = function(perfEvent) {
                if (perfEvent) {
                  if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT]()) {
                    _runListeners(_listeners, STR_PERF_EVENT, null, function(listener) {
                      if (perfEvent.isAsync) {
                        scheduleTimeout(function() {
                          return listener[STR_PERF_EVENT](perfEvent);
                        }, 0);
                      } else {
                        listener[STR_PERF_EVENT](perfEvent);
                      }
                    });
                  }
                }
              };
              _self[STR_OFFLINE_STORE] = function(events) {
                if (events && events[_DYN_LENGTH$2]) {
                  _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function(listener) {
                    listener[STR_OFFLINE_STORE](events);
                  });
                }
              };
              _self[STR_OFFLINE_SENT] = function(batch) {
                if (batch && batch[_DYN_DATA$1]) {
                  _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function(listener) {
                    listener[STR_OFFLINE_SENT](batch);
                  });
                }
              };
              _self[STR_OFFLINE_DROP] = function(cnt, reason) {
                if (cnt > 0) {
                  var rn_1 = reason || 0;
                  _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function(listener) {
                    listener[STR_OFFLINE_DROP](cnt, rn_1);
                  });
                }
              };
              _self[_DYN_UNLOAD] = function(isAsync) {
                var _finishUnload = function() {
                  unloadHandler && unloadHandler.rm();
                  unloadHandler = null;
                  _listeners = [];
                  _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL]();
                  _asyncNotifications.h = null;
                  _asyncNotifications.cb = [];
                };
                var waiting;
                _runListeners(_listeners, "unload", null, function(listener) {
                  var asyncUnload = listener[_DYN_UNLOAD](isAsync);
                  if (asyncUnload) {
                    if (!waiting) {
                      waiting = [];
                    }
                    waiting[_DYN_PUSH$1](asyncUnload);
                  }
                });
                if (waiting) {
                  return createPromise(function(resolve3) {
                    return doAwaitResponse(createAllPromise(waiting), function() {
                      _finishUnload();
                      resolve3();
                    });
                  });
                } else {
                  _finishUnload();
                }
              };
            });
          }
          NotificationManager2.__ieDyn = 1;
          return NotificationManager2;
        }()
      );
      var strExecutionContextKey = "ctx";
      var strParentContextKey = "ParentContextKey";
      var strChildrenContextKey = "ChildrenContextKey";
      var _defaultPerfManager = null;
      var PerfEvent = (
        /** @class */
        function() {
          function PerfEvent2(name, payloadDetails, isAsync) {
            var _self = this;
            _self.start = /* @__PURE__ */ utcNow();
            _self[_DYN_NAME$2] = name;
            _self.isAsync = isAsync;
            _self[_DYN_IS_CHILD_EVT] = function() {
              return false;
            };
            if (isFunction(payloadDetails)) {
              var theDetails_1;
              objDefine(_self, "payload", {
                g: function() {
                  if (!theDetails_1 && isFunction(payloadDetails)) {
                    theDetails_1 = payloadDetails();
                    payloadDetails = null;
                  }
                  return theDetails_1;
                }
              });
            }
            _self[_DYN_GET_CTX] = function(key) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey] || key === PerfEvent2[strChildrenContextKey]) {
                  return _self[key];
                }
                return (_self[strExecutionContextKey] || {})[key];
              }
              return null;
            };
            _self[_DYN_SET_CTX] = function(key, value) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey]) {
                  if (!_self[key]) {
                    _self[_DYN_IS_CHILD_EVT] = function() {
                      return true;
                    };
                  }
                  _self[key] = value;
                } else if (key === PerfEvent2[strChildrenContextKey]) {
                  _self[key] = value;
                } else {
                  var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                  ctx[key] = value;
                }
              }
            };
            _self.complete = function() {
              var childTime = 0;
              var childEvts = _self[_DYN_GET_CTX](PerfEvent2[strChildrenContextKey]);
              if (isArray(childEvts)) {
                for (var lp = 0; lp < childEvts[_DYN_LENGTH$2]; lp++) {
                  var childEvt = childEvts[lp];
                  if (childEvt) {
                    childTime += childEvt.time;
                  }
                }
              }
              _self.time = /* @__PURE__ */ utcNow() - _self.start;
              _self.exTime = _self.time - childTime;
              _self.complete = function() {
              };
            };
          }
          PerfEvent2.ParentContextKey = "parent";
          PerfEvent2.ChildrenContextKey = "childEvts";
          return PerfEvent2;
        }()
      );
      var PerfManager = (
        /** @class */
        function() {
          function PerfManager2(manager) {
            this.ctx = {};
            dynamicProto(PerfManager2, this, function(_self) {
              _self.create = function(src, payloadDetails, isAsync) {
                return new PerfEvent(src, payloadDetails, isAsync);
              };
              _self.fire = function(perfEvent) {
                if (perfEvent) {
                  perfEvent.complete();
                  if (manager && isFunction(manager[STR_PERF_EVENT])) {
                    manager[STR_PERF_EVENT](perfEvent);
                  }
                }
              };
              _self[_DYN_SET_CTX] = function(key, value) {
                if (key) {
                  var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                  ctx[key] = value;
                }
              };
              _self[_DYN_GET_CTX] = function(key) {
                return (_self[strExecutionContextKey] || {})[key];
              };
            });
          }
          PerfManager2.__ieDyn = 1;
          return PerfManager2;
        }()
      );
      var doPerfActiveKey = "CoreUtils.doPerf";
      function doPerf(mgrSource, getSource, func, details, isAsync) {
        if (mgrSource) {
          var perfMgr = mgrSource;
          if (perfMgr[STR_GET_PERF_MGR]) {
            perfMgr = perfMgr[STR_GET_PERF_MGR]();
          }
          if (perfMgr) {
            var perfEvt = void 0;
            var currentActive = perfMgr[_DYN_GET_CTX](doPerfActiveKey);
            try {
              perfEvt = perfMgr.create(getSource(), details, isAsync);
              if (perfEvt) {
                if (currentActive && perfEvt[_DYN_SET_CTX]) {
                  perfEvt[_DYN_SET_CTX](PerfEvent[strParentContextKey], currentActive);
                  if (currentActive[_DYN_GET_CTX] && currentActive[_DYN_SET_CTX]) {
                    var children = currentActive[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
                    if (!children) {
                      children = [];
                      currentActive[_DYN_SET_CTX](PerfEvent[strChildrenContextKey], children);
                    }
                    children[_DYN_PUSH$1](perfEvt);
                  }
                }
                perfMgr[_DYN_SET_CTX](doPerfActiveKey, perfEvt);
                return func(perfEvt);
              }
            } catch (ex) {
              if (perfEvt && perfEvt[_DYN_SET_CTX]) {
                perfEvt[_DYN_SET_CTX]("exception", ex);
              }
            } finally {
              if (perfEvt) {
                perfMgr.fire(perfEvt);
              }
              perfMgr[_DYN_SET_CTX](doPerfActiveKey, currentActive);
            }
          }
        }
        return func();
      }
      function getGblPerfMgr() {
        return _defaultPerfManager;
      }
      var INVALID_TRACE_ID = "00000000000000000000000000000000";
      var INVALID_SPAN_ID = "0000000000000000";
      function _isValid(value, len, invalidValue) {
        if (value && value[_DYN_LENGTH$2] === len && value !== invalidValue) {
          return !!value.match(/^[\da-f]*$/i);
        }
        return false;
      }
      function isValidTraceId(value) {
        return _isValid(value, 32, INVALID_TRACE_ID);
      }
      function isValidSpanId(value) {
        return _isValid(value, 16, INVALID_SPAN_ID);
      }
      var pluginStateData = createElmNodeData("plugin");
      function _getPluginState(plugin) {
        return pluginStateData.get(plugin, "state", {}, true);
      }
      function initializePlugins(processContext, extensions3) {
        var initPlugins = [];
        var lastPlugin = null;
        var proxy = processContext[_DYN_GET_NEXT]();
        var pluginState;
        while (proxy) {
          var thePlugin = proxy[_DYN_GET_PLUGIN]();
          if (thePlugin) {
            if (lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN] && thePlugin[STR_PROCESS_TELEMETRY]) {
              lastPlugin[_DYN_SET_NEXT_PLUGIN](thePlugin);
            }
            pluginState = _getPluginState(thePlugin);
            var isInitialized = !!pluginState[_DYN_IS_INITIALIZED];
            if (thePlugin[_DYN_IS_INITIALIZED]) {
              isInitialized = thePlugin[_DYN_IS_INITIALIZED]();
            }
            if (!isInitialized) {
              initPlugins[_DYN_PUSH$1](thePlugin);
            }
            lastPlugin = thePlugin;
            proxy = proxy[_DYN_GET_NEXT]();
          }
        }
        arrForEach(initPlugins, function(thePlugin2) {
          var core = processContext[STR_CORE]();
          thePlugin2[_DYN_INITIALIZE$1](processContext.getCfg(), core, extensions3, processContext[_DYN_GET_NEXT]());
          pluginState = _getPluginState(thePlugin2);
          if (!thePlugin2[STR_CORE] && !pluginState[STR_CORE]) {
            pluginState[STR_CORE] = core;
          }
          pluginState[_DYN_IS_INITIALIZED] = true;
          delete pluginState[_DYN_TEARDOWN];
        });
      }
      function sortPlugins(plugins) {
        return plugins.sort(function(extA, extB) {
          var result = 0;
          if (extB) {
            var bHasProcess = extB[STR_PROCESS_TELEMETRY];
            if (extA[STR_PROCESS_TELEMETRY]) {
              result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;
            } else if (bHasProcess) {
              result = -1;
            }
          } else {
            result = extA ? 1 : -1;
          }
          return result;
        });
      }
      function createDistributedTraceContext(parentCtx) {
        var trace = {};
        return {
          getName: function() {
            return trace[_DYN_NAME$2];
          },
          setName: function(newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DYN_NAME$2] = newValue;
          },
          getTraceId: function() {
            return trace.traceId;
          },
          setTraceId: function(newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if (isValidTraceId(newValue)) {
              trace.traceId = newValue;
            }
          },
          getSpanId: function() {
            return trace.spanId;
          },
          setSpanId: function(newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if (isValidSpanId(newValue)) {
              trace.spanId = newValue;
            }
          },
          getTraceFlags: function() {
            return trace[_DYN_TRACE_FLAGS];
          },
          setTraceFlags: function(newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace[_DYN_TRACE_FLAGS] = newTraceFlags;
          }
        };
      }
      var strTelemetryPluginChain = "TelemetryPluginChain";
      var strHasRunFlags = "_hasRun";
      var strGetTelCtx = "_getTelCtx";
      var _chainId = 0;
      function _getNextProxyStart(proxy, core, startAt) {
        while (proxy) {
          if (proxy[_DYN_GET_PLUGIN]() === startAt) {
            return proxy;
          }
          proxy = proxy[_DYN_GET_NEXT]();
        }
        return createTelemetryProxyChain([startAt], core.config || {}, core);
      }
      function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
        var _nextProxy = null;
        var _onComplete = [];
        if (!dynamicHandler) {
          dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER]);
        }
        if (startAt !== null) {
          _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
        }
        var context = {
          _next: _moveNext,
          ctx: {
            core: function() {
              return core;
            },
            diagLog: function() {
              return safeGetLogger(core, dynamicHandler.cfg);
            },
            getCfg: function() {
              return dynamicHandler.cfg;
            },
            getExtCfg: _resolveExtCfg,
            getConfig: _getConfig,
            hasNext: function() {
              return !!_nextProxy;
            },
            getNext: function() {
              return _nextProxy;
            },
            setNext: function(nextPlugin) {
              _nextProxy = nextPlugin;
            },
            iterate: _iterateChain,
            onComplete: _addOnComplete
          }
        };
        function _addOnComplete(onComplete, that) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          if (onComplete) {
            _onComplete[_DYN_PUSH$1]({
              func: onComplete,
              self: !/* @__PURE__ */ isUndefined(that) ? that : context.ctx,
              args
            });
          }
        }
        function _moveNext() {
          var nextProxy = _nextProxy;
          _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT]() : null;
          if (!nextProxy) {
            var onComplete = _onComplete;
            if (onComplete && onComplete[_DYN_LENGTH$2] > 0) {
              arrForEach(onComplete, function(completeDetails) {
                try {
                  completeDetails.func.call(completeDetails.self, completeDetails.args);
                } catch (e) {
                  _throwInternal(core[_DYN_LOGGER], 2, 73, "Unexpected Exception during onComplete - " + /* @__PURE__ */ dumpObj(e));
                }
              });
              _onComplete = [];
            }
          }
          return nextProxy;
        }
        function _getExtCfg(identifier, createIfMissing) {
          var idCfg = null;
          var cfg = dynamicHandler.cfg;
          if (cfg && identifier) {
            var extCfg = cfg[STR_EXTENSION_CONFIG];
            if (!extCfg && createIfMissing) {
              extCfg = {};
            }
            cfg[STR_EXTENSION_CONFIG] = extCfg;
            extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);
            if (extCfg) {
              idCfg = extCfg[identifier];
              if (!idCfg && createIfMissing) {
                idCfg = {};
              }
              extCfg[identifier] = idCfg;
              idCfg = dynamicHandler.ref(extCfg, identifier);
            }
          }
          return idCfg;
        }
        function _resolveExtCfg(identifier, defaultValues2) {
          var newConfig = _getExtCfg(identifier, true);
          if (defaultValues2) {
            objForEachKey(defaultValues2, function(field, defaultValue) {
              if (/* @__PURE__ */ isNullOrUndefined(newConfig[field])) {
                var cfgValue = dynamicHandler.cfg[field];
                if (cfgValue || !/* @__PURE__ */ isNullOrUndefined(cfgValue)) {
                  newConfig[field] = cfgValue;
                }
              }
              _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
            });
          }
          return dynamicHandler.setDf(newConfig, defaultValues2);
        }
        function _getConfig(identifier, field, defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = false;
          }
          var theValue;
          var extConfig = _getExtCfg(identifier, false);
          var rootConfig = dynamicHandler.cfg;
          if (extConfig && (extConfig[field] || !/* @__PURE__ */ isNullOrUndefined(extConfig[field]))) {
            theValue = extConfig[field];
          } else if (rootConfig[field] || !/* @__PURE__ */ isNullOrUndefined(rootConfig[field])) {
            theValue = rootConfig[field];
          }
          return theValue || !/* @__PURE__ */ isNullOrUndefined(theValue) ? theValue : defaultValue;
        }
        function _iterateChain(cb) {
          var nextPlugin;
          while (!!(nextPlugin = context._next())) {
            var plugin = nextPlugin[_DYN_GET_PLUGIN]();
            if (plugin) {
              cb(plugin);
            }
          }
        }
        return context;
      }
      function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
        var config = createDynamicConfig(cfg);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(env2) {
          var nextPlugin = internalContext._next();
          if (nextPlugin) {
            nextPlugin[STR_PROCESS_TELEMETRY](env2, context);
          }
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT](), config.cfg, core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(unloadState) {
          var nextPlugin = internalContext._next();
          nextPlugin && nextPlugin[_DYN_UNLOAD](context, unloadState);
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
        var config = createDynamicConfig(core.config);
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(updateState) {
          return context.iterate(function(plugin) {
            if (isFunction(plugin[_DYN_UPDATE])) {
              plugin[_DYN_UPDATE](context, updateState);
            }
          });
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt2);
          }
          return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createTelemetryProxyChain(plugins, config, core, startAt) {
        var firstProxy = null;
        var add = startAt ? false : true;
        if (isArray(plugins) && plugins[_DYN_LENGTH$2] > 0) {
          var lastProxy_1 = null;
          arrForEach(plugins, function(thePlugin) {
            if (!add && startAt === thePlugin) {
              add = true;
            }
            if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY])) {
              var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
              if (!firstProxy) {
                firstProxy = newProxy;
              }
              if (lastProxy_1) {
                lastProxy_1._setNext(newProxy);
              }
              lastProxy_1 = newProxy;
            }
          });
        }
        if (startAt && !firstProxy) {
          return createTelemetryProxyChain([startAt], config, core);
        }
        return firstProxy;
      }
      function createTelemetryPluginProxy(plugin, config, core) {
        var nextProxy = null;
        var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY]);
        var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN]);
        var chainId;
        if (plugin) {
          chainId = plugin[_DYN_IDENTIFIER] + "-" + plugin[STR_PRIORITY] + "-" + _chainId++;
        } else {
          chainId = "Unknown-0-" + _chainId++;
        }
        var proxyChain = {
          getPlugin: function() {
            return plugin;
          },
          getNext: function() {
            return nextProxy;
          },
          processTelemetry: _processTelemetry,
          unload: _unloadPlugin,
          update: _updatePlugin,
          _id: chainId,
          _setNext: function(nextPlugin) {
            nextProxy = nextPlugin;
          }
        };
        function _getTelCtx() {
          var itemCtx;
          if (plugin && isFunction(plugin[strGetTelCtx])) {
            itemCtx = plugin[strGetTelCtx]();
          }
          if (!itemCtx) {
            itemCtx = createProcessTelemetryContext(proxyChain, config, core);
          }
          return itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
          var hasRun = false;
          var identifier = plugin ? plugin[_DYN_IDENTIFIER] : strTelemetryPluginChain;
          var hasRunContext = itemCtx[strHasRunFlags];
          if (!hasRunContext) {
            hasRunContext = itemCtx[strHasRunFlags] = {};
          }
          itemCtx.setNext(nextProxy);
          if (plugin) {
            doPerf(itemCtx[STR_CORE](), function() {
              return identifier + ":" + name;
            }, function() {
              hasRunContext[chainId] = true;
              try {
                var nextId = nextProxy ? nextProxy._id : STR_EMPTY$1;
                if (nextId) {
                  hasRunContext[nextId] = false;
                }
                hasRun = processPluginFn(itemCtx);
              } catch (error) {
                var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                if (hasNextRun) {
                  hasRun = true;
                }
                if (!nextProxy || !hasNextRun) {
                  _throwInternal(itemCtx[_DYN_DIAG_LOG$1](), 1, 73, "Plugin [" + identifier + "] failed during " + name + " - " + /* @__PURE__ */ dumpObj(error) + ", run flags: " + /* @__PURE__ */ dumpObj(hasRunContext));
                }
              }
            }, details, isAsync);
          }
          return hasRun;
        }
        function _processTelemetry(env2, itemCtx) {
          itemCtx = itemCtx || _getTelCtx();
          function _callProcessTelemetry(itemCtx2) {
            if (!plugin || !hasProcessTelemetry) {
              return false;
            }
            var pluginState = _getPluginState(plugin);
            if (pluginState[_DYN_TEARDOWN] || pluginState[STR_DISABLED]) {
              return false;
            }
            if (hasSetNext) {
              plugin[_DYN_SET_NEXT_PLUGIN](nextProxy);
            }
            plugin[STR_PROCESS_TELEMETRY](env2, itemCtx2);
            return true;
          }
          if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function() {
            return { item: env2 };
          }, !env2.sync)) {
            itemCtx[_DYN_PROCESS_NEXT](env2);
          }
        }
        function _unloadPlugin(unloadCtx, unloadState) {
          function _callTeardown() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                pluginState[STR_CORE] = null;
                pluginState[_DYN_TEARDOWN] = true;
                pluginState[_DYN_IS_INITIALIZED] = false;
                if (plugin[_DYN_TEARDOWN] && plugin[_DYN_TEARDOWN](unloadCtx, unloadState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(unloadCtx, _callTeardown, "unload", function() {
          }, unloadState.isAsync)) {
            unloadCtx[_DYN_PROCESS_NEXT](unloadState);
          }
        }
        function _updatePlugin(updateCtx, updateState) {
          function _callUpdate() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                if (plugin[_DYN_UPDATE] && plugin[_DYN_UPDATE](updateCtx, updateState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(updateCtx, _callUpdate, "update", function() {
          }, false)) {
            updateCtx[_DYN_PROCESS_NEXT](updateState);
          }
        }
        return objFreeze(proxyChain);
      }
      function createUnloadHandlerContainer() {
        var handlers = [];
        function _addHandler(handler) {
          if (handler) {
            handlers[_DYN_PUSH$1](handler);
          }
        }
        function _runHandlers(unloadCtx, unloadState) {
          arrForEach(handlers, function(handler) {
            try {
              handler(unloadCtx, unloadState);
            } catch (e) {
              _throwInternal(unloadCtx[_DYN_DIAG_LOG$1](), 2, 73, "Unexpected error calling unload handler - " + /* @__PURE__ */ dumpObj(e));
            }
          });
          handlers = [];
        }
        return {
          add: _addHandler,
          run: _runHandlers
        };
      }
      function createUnloadHookContainer() {
        var _hooks = [];
        function _doUnload(logger2) {
          var oldHooks = _hooks;
          _hooks = [];
          arrForEach(oldHooks, function(fn) {
            try {
              (fn.rm || fn.remove).call(fn);
            } catch (e) {
              _throwInternal(logger2, 2, 73, "Unloading:" + /* @__PURE__ */ dumpObj(e));
            }
          });
        }
        function _addHook(hooks) {
          if (hooks) {
            arrAppend(_hooks, hooks);
          }
        }
        return {
          run: _doUnload,
          add: _addHook
        };
      }
      var _a$3;
      var strGetPlugin = "getPlugin";
      var defaultValues = (_a$3 = {}, _a$3[STR_EXTENSION_CONFIG] = { isVal: isNotNullOrUndefined, v: {} }, _a$3);
      var BaseTelemetryPlugin = (
        /** @class */
        function() {
          function BaseTelemetryPlugin2() {
            var _self = this;
            var _isinitialized;
            var _rootCtx;
            var _nextPlugin;
            var _unloadHandlerContainer;
            var _hookContainer;
            _initDefaults();
            dynamicProto(BaseTelemetryPlugin2, _self, function(_self2) {
              _self2[_DYN_INITIALIZE$1] = function(config, core, extensions3, pluginChain) {
                _setDefaults(config, core, pluginChain);
                _isinitialized = true;
              };
              _self2[_DYN_TEARDOWN] = function(unloadCtx, unloadState) {
                var core = _self2[STR_CORE];
                if (!core || unloadCtx && core !== unloadCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var unloadDone = false;
                var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUnloadState = unloadState || {
                  reason: 0,
                  isAsync: false
                };
                function _unloadCallback() {
                  if (!unloadDone) {
                    unloadDone = true;
                    _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                    _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG$1]());
                    if (result === true) {
                      theUnloadCtx[_DYN_PROCESS_NEXT](theUnloadState);
                    }
                    _initDefaults();
                  }
                }
                if (!_self2[_DYN__DO_TEARDOWN] || _self2[_DYN__DO_TEARDOWN](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                  _unloadCallback();
                } else {
                  result = true;
                }
                return result;
              };
              _self2[_DYN_UPDATE] = function(updateCtx, updateState) {
                var core = _self2[STR_CORE];
                if (!core || updateCtx && core !== updateCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var updateDone = false;
                var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUpdateState = updateState || {
                  reason: 0
                };
                function _updateCallback() {
                  if (!updateDone) {
                    updateDone = true;
                    _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT]());
                  }
                }
                if (!_self2._doUpdate || _self2._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                  _updateCallback();
                } else {
                  result = true;
                }
                return result;
              };
              proxyFunctionAs(_self2, "_addUnloadCb", function() {
                return _unloadHandlerContainer;
              }, "add");
              proxyFunctionAs(_self2, "_addHook", function() {
                return _hookContainer;
              }, "add");
              objDefine(_self2, "_unloadHooks", { g: function() {
                return _hookContainer;
              } });
            });
            _self[_DYN_DIAG_LOG$1] = function(itemCtx) {
              return _getTelCtx(itemCtx)[_DYN_DIAG_LOG$1]();
            };
            _self[_DYN_IS_INITIALIZED] = function() {
              return _isinitialized;
            };
            _self.setInitialized = function(isInitialized) {
              _isinitialized = isInitialized;
            };
            _self[_DYN_SET_NEXT_PLUGIN] = function(next) {
              _nextPlugin = next;
            };
            _self[_DYN_PROCESS_NEXT] = function(env2, itemCtx) {
              if (itemCtx) {
                itemCtx[_DYN_PROCESS_NEXT](env2);
              } else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY])) {
                _nextPlugin[STR_PROCESS_TELEMETRY](env2, null);
              }
            };
            _self._getTelCtx = _getTelCtx;
            function _getTelCtx(currentCtx) {
              if (currentCtx === void 0) {
                currentCtx = null;
              }
              var itemCtx = currentCtx;
              if (!itemCtx) {
                var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE]);
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin[strGetPlugin]);
                } else {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin);
                }
              }
              return itemCtx;
            }
            function _setDefaults(config, core, pluginChain) {
              createDynamicConfig(config, defaultValues, safeGetLogger(core));
              if (!pluginChain && core) {
                pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2]()[_DYN_GET_NEXT]();
              }
              var nextPlugin = _nextPlugin;
              if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                nextPlugin = _nextPlugin[strGetPlugin]();
              }
              _self[STR_CORE] = core;
              _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
            }
            function _initDefaults() {
              _isinitialized = false;
              _self[STR_CORE] = null;
              _rootCtx = null;
              _nextPlugin = null;
              _hookContainer = createUnloadHookContainer();
              _unloadHandlerContainer = createUnloadHandlerContainer();
            }
          }
          BaseTelemetryPlugin2.__ieDyn = 1;
          return BaseTelemetryPlugin2;
        }()
      );
      function _addInitializer(_initializers, id, telemetryInitializer) {
        var theInitializer = {
          id,
          fn: telemetryInitializer
        };
        arrAppend(_initializers, theInitializer);
        var handler = {
          remove: function() {
            arrForEach(_initializers, function(initializer, idx) {
              if (initializer.id === theInitializer.id) {
                _initializers[_DYN_SPLICE](idx, 1);
                return -1;
              }
            });
          }
        };
        return handler;
      }
      function _runInitializers(_initializers, item, logger2) {
        var doNotSendItem = false;
        var telemetryInitializersCount = _initializers[_DYN_LENGTH$2];
        for (var i = 0; i < telemetryInitializersCount; ++i) {
          var telemetryInitializer = _initializers[i];
          if (telemetryInitializer) {
            try {
              if (telemetryInitializer.fn[_DYN_APPLY](null, [item]) === false) {
                doNotSendItem = true;
                break;
              }
            } catch (e) {
              _throwInternal(logger2, 2, 64, "Telemetry initializer failed: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) }, true);
            }
          }
        }
        return !doNotSendItem;
      }
      var TelemetryInitializerPlugin = (
        /** @class */
        function(_super) {
          __extendsFn(TelemetryInitializerPlugin2, _super);
          function TelemetryInitializerPlugin2() {
            var _this = _super.call(this) || this;
            _this.identifier = "TelemetryInitializerPlugin";
            _this.priority = 199;
            var _id;
            var _initializers;
            _initDefaults();
            dynamicProto(TelemetryInitializerPlugin2, _this, function(_self, _base) {
              _self.addTelemetryInitializer = function(telemetryInitializer) {
                return _addInitializer(_initializers, _id++, telemetryInitializer);
              };
              _self[STR_PROCESS_TELEMETRY] = function(item, itemCtx) {
                if (_runInitializers(_initializers, item, itemCtx ? itemCtx[_DYN_DIAG_LOG$1]() : _self[_DYN_DIAG_LOG$1]())) {
                  _self[_DYN_PROCESS_NEXT](item, itemCtx);
                }
              };
              _self[_DYN__DO_TEARDOWN] = function() {
                _initDefaults();
              };
            });
            function _initDefaults() {
              _id = 0;
              _initializers = [];
            }
            return _this;
          }
          TelemetryInitializerPlugin2.__ieDyn = 1;
          return TelemetryInitializerPlugin2;
        }(BaseTelemetryPlugin)
      );
      var _a$2;
      var strValidationError = "Plugins must provide initialize method";
      var strNotificationManager = "_notificationManager";
      var strSdkUnloadingError = "SDK is still unloading...";
      var strSdkNotInitialized = "SDK is not initialized";
      var maxInitQueueSize = 100;
      var maxInitTimeout = 5e4;
      var defaultConfig = objDeepFreeze((_a$2 = {
        cookieCfg: {}
      }, _a$2[STR_EXTENSIONS] = { rdOnly: true, ref: true, v: [] }, _a$2[STR_CHANNELS] = { rdOnly: true, ref: true, v: [] }, _a$2[STR_EXTENSION_CONFIG] = { ref: true, v: {} }, _a$2[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE$2, _a$2.loggingLevelConsole = 0, _a$2.diagnosticLogInterval = UNDEFINED_VALUE$2, _a$2));
      function _createPerfManager(core, notificationMgr) {
        return new PerfManager(notificationMgr);
      }
      function _validateExtensions(logger2, channelPriority, allExtensions) {
        var coreExtensions = [];
        var channels = [];
        var extPriorities = {};
        arrForEach(allExtensions, function(ext) {
          if (/* @__PURE__ */ isNullOrUndefined(ext) || /* @__PURE__ */ isNullOrUndefined(ext[_DYN_INITIALIZE$1])) {
            throwError(strValidationError);
          }
          var extPriority = ext[STR_PRIORITY];
          var identifier = ext[_DYN_IDENTIFIER];
          if (ext && extPriority) {
            if (!/* @__PURE__ */ isNullOrUndefined(extPriorities[extPriority])) {
              _warnToConsole(logger2, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
            } else {
              extPriorities[extPriority] = identifier;
            }
          }
          if (!extPriority || extPriority < channelPriority) {
            coreExtensions[_DYN_PUSH$1](ext);
          } else {
            channels[_DYN_PUSH$1](ext);
          }
        });
        return {
          core: coreExtensions,
          channels
        };
      }
      function _isPluginPresent(thePlugin, plugins) {
        var exists = false;
        arrForEach(plugins, function(plugin) {
          if (plugin === thePlugin) {
            exists = true;
            return -1;
          }
        });
        return exists;
      }
      function _deepMergeConfig(details, target, newValues, merge) {
        if (newValues) {
          objForEachKey(newValues, function(key, value) {
            if (merge) {
              if (/* @__PURE__ */ isPlainObject(value) && /* @__PURE__ */ isPlainObject(target[key])) {
                _deepMergeConfig(details, target[key], value, merge);
              }
            }
            if (merge && /* @__PURE__ */ isPlainObject(value) && /* @__PURE__ */ isPlainObject(target[key])) {
              _deepMergeConfig(details, target[key], value, merge);
            } else {
              details.set(target, key, value);
            }
          });
        }
      }
      function _findWatcher(listeners, newWatcher) {
        var theListener = null;
        var idx = -1;
        arrForEach(listeners, function(listener, lp) {
          if (listener.w === newWatcher) {
            theListener = listener;
            idx = lp;
            return -1;
          }
        });
        return { i: idx, l: theListener };
      }
      function _addDelayedCfgListener(listeners, newWatcher) {
        var theListener = _findWatcher(listeners, newWatcher).l;
        if (!theListener) {
          theListener = {
            w: newWatcher,
            rm: function() {
              var fnd = _findWatcher(listeners, newWatcher);
              if (fnd.i !== -1) {
                listeners[_DYN_SPLICE](fnd.i, 1);
              }
            }
          };
          listeners[_DYN_PUSH$1](theListener);
        }
        return theListener;
      }
      function _registerDelayedCfgListener(config, listeners, logger2) {
        arrForEach(listeners, function(listener) {
          var unloadHdl = onConfigChange(config, listener.w, logger2);
          delete listener.w;
          listener.rm = function() {
            unloadHdl.rm();
          };
        });
      }
      function _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {
        unloadContainer.add(configHandler[_DYN_WATCH](function(details) {
          var disableDbgExt = details.cfg.disableDbgExt;
          if (disableDbgExt === true && debugListener) {
            notificationManager[_DYN_REMOVE_NOTIFICATION_0](debugListener);
            debugListener = null;
          }
          if (notificationManager && !debugListener && disableDbgExt !== true) {
            debugListener = getDebugListener(details.cfg);
            notificationManager[_DYN_ADD_NOTIFICATION_LIS1](debugListener);
          }
        }));
        return debugListener;
      }
      function _createUnloadHook(unloadHook) {
        return objDefine({
          rm: function() {
            unloadHook.rm();
          }
        }, "toJSON", { v: function() {
          return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">";
        } });
      }
      var AppInsightsCore = (
        /** @class */
        function() {
          function AppInsightsCore2() {
            var _configHandler;
            var _isInitialized;
            var _logger;
            var _eventQueue;
            var _notificationManager;
            var _perfManager;
            var _cfgPerfManager;
            var _cookieManager;
            var _pluginChain;
            var _configExtensions;
            var _channelConfig;
            var _channels;
            var _isUnloading;
            var _telemetryInitializerPlugin;
            var _internalLogsEventName;
            var _evtNamespace;
            var _unloadHandlers;
            var _hookContainer;
            var _debugListener2;
            var _traceCtx;
            var _instrumentationKey;
            var _cfgListeners;
            var _extensions;
            var _pluginVersionStringArr;
            var _pluginVersionString;
            var _activeStatus;
            var _endpoint;
            var _initInMemoMaxSize;
            var _isStatusSet;
            var _initTimer;
            var _internalLogPoller;
            var _internalLogPollerListening;
            var _forceStopInternalLogPoller;
            dynamicProto(AppInsightsCore2, this, function(_self) {
              _initDefaults();
              _self["_getDbgPlgTargets"] = function() {
                return [_extensions, _eventQueue];
              };
              _self[_DYN_IS_INITIALIZED] = function() {
                return _isInitialized;
              };
              _self.activeStatus = function() {
                return _activeStatus;
              };
              _self._setPendingStatus = function() {
                _activeStatus = 3;
              };
              _self[_DYN_INITIALIZE$1] = function(config, extensions3, logger2, notificationManager) {
                if (_isUnloading) {
                  throwError(strSdkUnloadingError);
                }
                if (_self[_DYN_IS_INITIALIZED]()) {
                  throwError("Core cannot be initialized more than once");
                }
                _configHandler = createDynamicConfig(config, defaultConfig, logger2 || _self[_DYN_LOGGER], false);
                config = _configHandler.cfg;
                _addUnloadHook(_configHandler[_DYN_WATCH](function(details) {
                  var rootCfg = details.cfg;
                  _initInMemoMaxSize = rootCfg.initInMemoMaxSize || maxInitQueueSize;
                  _handleIKeyEndpointPromises(rootCfg);
                  var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);
                  objForEachKey(extCfg, function(key) {
                    details.ref(extCfg, key);
                  });
                }));
                _notificationManager = notificationManager;
                _debugListener2 = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DYN_GET_NOTIFY_MGR](), _debugListener2);
                _initPerfManager();
                _self[_DYN_LOGGER] = logger2;
                var cfgExtensions = config[STR_EXTENSIONS];
                _configExtensions = [];
                _configExtensions[_DYN_PUSH$1].apply(_configExtensions, __spreadArrayFn(__spreadArrayFn([], extensions3, false), cfgExtensions));
                _channelConfig = config[STR_CHANNELS];
                _initPluginChain(null);
                if (!_channels || _channels[_DYN_LENGTH$2] === 0) {
                  throwError("No " + STR_CHANNELS + " available");
                }
                if (_channelConfig && _channelConfig[_DYN_LENGTH$2] > 1) {
                  var teeController = _self[_DYN_GET_PLUGIN]("TeeChannelController");
                  if (!teeController || !teeController.plugin) {
                    _throwInternal(_logger, 1, 28, "TeeChannel required");
                  }
                }
                _registerDelayedCfgListener(config, _cfgListeners, _logger);
                _cfgListeners = null;
                _isInitialized = true;
                if (_activeStatus === ActiveStatus.ACTIVE) {
                  _releaseQueues();
                }
              };
              _self.getChannels = function() {
                var controls = [];
                if (_channels) {
                  arrForEach(_channels, function(channel) {
                    controls[_DYN_PUSH$1](channel);
                  });
                }
                return objFreeze(controls);
              };
              _self.track = function(telemetryItem) {
                doPerf(_self[STR_GET_PERF_MGR](), function() {
                  return "AppInsightsCore:track";
                }, function() {
                  if (telemetryItem === null) {
                    _notifyInvalidEvent(telemetryItem);
                    throwError("Invalid telemetry item");
                  }
                  if (!telemetryItem[_DYN_NAME$2] && /* @__PURE__ */ isNullOrUndefined(telemetryItem[_DYN_NAME$2])) {
                    _notifyInvalidEvent(telemetryItem);
                    throwError("telemetry name required");
                  }
                  telemetryItem.iKey = telemetryItem.iKey || _instrumentationKey;
                  telemetryItem.time = telemetryItem.time || toISOString(/* @__PURE__ */ new Date());
                  telemetryItem.ver = telemetryItem.ver || "4.0";
                  if (!_isUnloading && _self[_DYN_IS_INITIALIZED]() && _activeStatus === ActiveStatus.ACTIVE) {
                    _createTelCtx()[_DYN_PROCESS_NEXT](telemetryItem);
                  } else if (_activeStatus !== ActiveStatus.INACTIVE) {
                    if (_eventQueue[_DYN_LENGTH$2] <= _initInMemoMaxSize) {
                      _eventQueue[_DYN_PUSH$1](telemetryItem);
                    }
                  }
                }, function() {
                  return { item: telemetryItem };
                }, !telemetryItem.sync);
              };
              _self[_DYN_GET_PROCESS_TEL_CONT2] = _createTelCtx;
              _self[_DYN_GET_NOTIFY_MGR] = function() {
                if (!_notificationManager) {
                  _notificationManager = new NotificationManager(_configHandler.cfg);
                  _self[strNotificationManager] = _notificationManager;
                }
                return _notificationManager;
              };
              _self[_DYN_ADD_NOTIFICATION_LIS1] = function(listener) {
                _self.getNotifyMgr()[_DYN_ADD_NOTIFICATION_LIS1](listener);
              };
              _self[_DYN_REMOVE_NOTIFICATION_0] = function(listener) {
                if (_notificationManager) {
                  _notificationManager[_DYN_REMOVE_NOTIFICATION_0](listener);
                }
              };
              _self.getCookieMgr = function() {
                if (!_cookieManager) {
                  _cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER]);
                }
                return _cookieManager;
              };
              _self.setCookieMgr = function(cookieMgr) {
                if (_cookieManager !== cookieMgr) {
                  runTargetUnload(_cookieManager, false);
                  _cookieManager = cookieMgr;
                }
              };
              _self[STR_GET_PERF_MGR] = function() {
                return _perfManager || _cfgPerfManager || getGblPerfMgr();
              };
              _self.setPerfMgr = function(perfMgr) {
                _perfManager = perfMgr;
              };
              _self.eventCnt = function() {
                return _eventQueue[_DYN_LENGTH$2];
              };
              _self.releaseQueue = function() {
                if (_isInitialized && _eventQueue[_DYN_LENGTH$2] > 0) {
                  var eventQueue = _eventQueue;
                  _eventQueue = [];
                  if (_activeStatus === 2) {
                    arrForEach(eventQueue, function(event) {
                      event.iKey = event.iKey || _instrumentationKey;
                      _createTelCtx()[_DYN_PROCESS_NEXT](event);
                    });
                  } else {
                    _throwInternal(_logger, 2, 20, "core init status is not active");
                  }
                }
              };
              _self.pollInternalLogs = function(eventName) {
                _internalLogsEventName = eventName || null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller && _internalLogPoller[_DYN_CANCEL]();
                return _startLogPoller(true);
              };
              function _handleIKeyEndpointPromises(theConfig) {
                var ikey = theConfig.instrumentationKey;
                var endpointUrl = theConfig.endpointUrl;
                if (_activeStatus !== 3) {
                  if (/* @__PURE__ */ isNullOrUndefined(ikey)) {
                    _instrumentationKey = null;
                    _activeStatus = ActiveStatus.INACTIVE;
                    var msg = "Please provide instrumentation key";
                    if (!_isInitialized) {
                      throwError(msg);
                    } else {
                      _throwInternal(_logger, 1, 100, msg);
                      _releaseQueues();
                    }
                    return;
                  }
                  var promises = [];
                  if (/* @__PURE__ */ isPromiseLike(ikey)) {
                    promises[_DYN_PUSH$1](ikey);
                    _instrumentationKey = null;
                  } else {
                    _instrumentationKey = ikey;
                  }
                  if (/* @__PURE__ */ isPromiseLike(endpointUrl)) {
                    promises[_DYN_PUSH$1](endpointUrl);
                    _endpoint = null;
                  } else {
                    _endpoint = endpointUrl;
                  }
                  if (promises[_DYN_LENGTH$2]) {
                    _waitForInitPromises(theConfig, promises);
                  } else {
                    _setStatus();
                  }
                }
              }
              function _waitForInitPromises(theConfig, promises) {
                _isStatusSet = false;
                _activeStatus = 3;
                var initTimeout = isNotNullOrUndefined(theConfig.initTimeOut) ? theConfig.initTimeOut : maxInitTimeout;
                var allPromises = createSyncAllSettledPromise(promises);
                if (_initTimer) {
                  _initTimer[_DYN_CANCEL]();
                }
                _initTimer = scheduleTimeout(function() {
                  _initTimer = null;
                  if (!_isStatusSet) {
                    _setStatus();
                  }
                }, initTimeout);
                doAwaitResponse(allPromises, function(response) {
                  try {
                    if (_isStatusSet) {
                      return;
                    }
                    if (!response.rejected) {
                      var values = response[_DYN_VALUE];
                      if (values && values[_DYN_LENGTH$2]) {
                        var ikeyRes = values[0];
                        _instrumentationKey = ikeyRes && ikeyRes[_DYN_VALUE];
                        if (values[_DYN_LENGTH$2] > 1) {
                          var endpointRes = values[1];
                          _endpoint = endpointRes && endpointRes[_DYN_VALUE];
                        }
                      }
                      if (_instrumentationKey) {
                        theConfig.instrumentationKey = _instrumentationKey;
                        theConfig.endpointUrl = _endpoint;
                      }
                    }
                    _setStatus();
                  } catch (e) {
                    if (!_isStatusSet) {
                      _setStatus();
                    }
                  }
                });
              }
              function _setStatus() {
                _isStatusSet = true;
                if (/* @__PURE__ */ isNullOrUndefined(_instrumentationKey)) {
                  _activeStatus = ActiveStatus.INACTIVE;
                  _throwInternal(_logger, 1, 112, "ikey can't be resolved from promises");
                } else {
                  _activeStatus = ActiveStatus.ACTIVE;
                }
                _releaseQueues();
              }
              function _releaseQueues() {
                if (_isInitialized) {
                  _self.releaseQueue();
                  _self.pollInternalLogs();
                }
              }
              function _startLogPoller(alwaysStart) {
                if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED]) && !_forceStopInternalLogPoller) {
                  var shouldStart = alwaysStart || _logger && _logger.queue[_DYN_LENGTH$2] > 0;
                  if (shouldStart) {
                    if (!_internalLogPollerListening) {
                      _internalLogPollerListening = true;
                      _addUnloadHook(_configHandler[_DYN_WATCH](function(details) {
                        var interval = details.cfg.diagnosticLogInterval;
                        if (!interval || !(interval > 0)) {
                          interval = 1e4;
                        }
                        var isRunning = false;
                        if (_internalLogPoller) {
                          isRunning = _internalLogPoller[_DYN_ENABLED];
                          _internalLogPoller[_DYN_CANCEL]();
                        }
                        _internalLogPoller = createTimeout(_flushInternalLogs, interval);
                        _internalLogPoller.unref();
                        _internalLogPoller[_DYN_ENABLED] = isRunning;
                      }));
                    }
                    _internalLogPoller[_DYN_ENABLED] = true;
                  }
                }
                return _internalLogPoller;
              }
              _self[_DYN_STOP_POLLING_INTERNA3] = function() {
                _forceStopInternalLogPoller = true;
                _internalLogPoller && _internalLogPoller[_DYN_CANCEL]();
                _flushInternalLogs();
              };
              proxyFunctions(_self, function() {
                return _telemetryInitializerPlugin;
              }, ["addTelemetryInitializer"]);
              _self[_DYN_UNLOAD] = function(isAsync, unloadComplete, cbTimeout) {
                if (isAsync === void 0) {
                  isAsync = true;
                }
                if (!_isInitialized) {
                  throwError(strSdkNotInitialized);
                }
                if (_isUnloading) {
                  throwError(strSdkUnloadingError);
                }
                var unloadState = {
                  reason: 50,
                  isAsync,
                  flushComplete: false
                };
                var result;
                if (isAsync && !unloadComplete) {
                  result = createPromise(function(resolve3) {
                    unloadComplete = resolve3;
                  });
                }
                var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);
                processUnloadCtx[_DYN_ON_COMPLETE](function() {
                  _hookContainer.run(_self[_DYN_LOGGER]);
                  doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function() {
                    _initDefaults();
                    unloadComplete && unloadComplete(unloadState);
                  });
                }, _self);
                function _doUnload(flushComplete) {
                  unloadState.flushComplete = flushComplete;
                  _isUnloading = true;
                  _unloadHandlers.run(processUnloadCtx, unloadState);
                  _self[_DYN_STOP_POLLING_INTERNA3]();
                  processUnloadCtx[_DYN_PROCESS_NEXT](unloadState);
                }
                _flushInternalLogs();
                if (!_flushChannels(isAsync, _doUnload, 6, cbTimeout)) ;
                return result;
              };
              _self[_DYN_GET_PLUGIN] = _getPlugin;
              _self.addPlugin = function(plugin, replaceExisting, isAsync, addCb) {
                if (!plugin) {
                  addCb && addCb(false);
                  _logOrThrowError(strValidationError);
                  return;
                }
                var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER]);
                if (existingPlugin && !replaceExisting) {
                  addCb && addCb(false);
                  _logOrThrowError("Plugin [" + plugin[_DYN_IDENTIFIER] + "] is already loaded!");
                  return;
                }
                var updateState = {
                  reason: 16
                };
                function _addPlugin(removed) {
                  _configExtensions[_DYN_PUSH$1](plugin);
                  updateState.added = [plugin];
                  _initPluginChain(updateState);
                  addCb && addCb(true);
                }
                if (existingPlugin) {
                  var removedPlugins_1 = [existingPlugin.plugin];
                  var unloadState = {
                    reason: 2,
                    isAsync: !!isAsync
                  };
                  _removePlugins(removedPlugins_1, unloadState, function(removed) {
                    if (!removed) {
                      addCb && addCb(false);
                    } else {
                      updateState.removed = removedPlugins_1;
                      updateState.reason |= 32;
                      _addPlugin();
                    }
                  });
                } else {
                  _addPlugin();
                }
              };
              _self.updateCfg = function(newConfig, mergeExisting) {
                if (mergeExisting === void 0) {
                  mergeExisting = true;
                }
                var updateState;
                if (_self[_DYN_IS_INITIALIZED]()) {
                  updateState = {
                    reason: 1,
                    cfg: _configHandler.cfg,
                    oldCfg: deepExtend({}, _configHandler.cfg),
                    newConfig: deepExtend({}, newConfig),
                    merge: mergeExisting
                  };
                  newConfig = updateState.newConfig;
                  var cfg = _configHandler.cfg;
                  newConfig[STR_EXTENSIONS] = cfg[STR_EXTENSIONS];
                  newConfig[STR_CHANNELS] = cfg[STR_CHANNELS];
                }
                _configHandler._block(function(details) {
                  var theConfig = details.cfg;
                  _deepMergeConfig(details, theConfig, newConfig, mergeExisting);
                  if (!mergeExisting) {
                    objForEachKey(theConfig, function(key) {
                      if (!objHasOwn(newConfig, key)) {
                        details.set(theConfig, key, UNDEFINED_VALUE$2);
                      }
                    });
                  }
                  details.setDf(theConfig, defaultConfig);
                }, true);
                _configHandler.notify();
                if (updateState) {
                  _doUpdate(updateState);
                }
              };
              _self.evtNamespace = function() {
                return _evtNamespace;
              };
              _self.flush = _flushChannels;
              _self.getTraceCtx = function(createNew) {
                if (!_traceCtx) {
                  _traceCtx = createDistributedTraceContext();
                }
                return _traceCtx;
              };
              _self.setTraceCtx = function(traceCtx) {
                _traceCtx = traceCtx || null;
              };
              _self.addUnloadHook = _addUnloadHook;
              proxyFunctionAs(_self, "addUnloadCb", function() {
                return _unloadHandlers;
              }, "add");
              _self.onCfgChange = function(handler) {
                var unloadHook;
                if (!_isInitialized) {
                  unloadHook = _addDelayedCfgListener(_cfgListeners, handler);
                } else {
                  unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER]);
                }
                return _createUnloadHook(unloadHook);
              };
              _self.getWParam = function() {
                return /* @__PURE__ */ hasDocument() || !!_configHandler.cfg.enableWParam ? 0 : -1;
              };
              function _setPluginVersions() {
                var thePlugins = {};
                _pluginVersionStringArr = [];
                var _addPluginVersions = function(plugins) {
                  if (plugins) {
                    arrForEach(plugins, function(plugin) {
                      if (plugin[_DYN_IDENTIFIER] && plugin[_DYN_VERSION] && !thePlugins[plugin.identifier]) {
                        var ver = plugin[_DYN_IDENTIFIER] + "=" + plugin[_DYN_VERSION];
                        _pluginVersionStringArr[_DYN_PUSH$1](ver);
                        thePlugins[plugin.identifier] = plugin;
                      }
                    });
                  }
                };
                _addPluginVersions(_channels);
                if (_channelConfig) {
                  arrForEach(_channelConfig, function(channels) {
                    _addPluginVersions(channels);
                  });
                }
                _addPluginVersions(_configExtensions);
              }
              function _initDefaults() {
                _isInitialized = false;
                _configHandler = createDynamicConfig({}, defaultConfig, _self[_DYN_LOGGER]);
                _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4] = 1;
                objDefine(_self, "config", {
                  g: function() {
                    return _configHandler.cfg;
                  },
                  s: function(newValue) {
                    _self.updateCfg(newValue, false);
                  }
                });
                objDefine(_self, "pluginVersionStringArr", {
                  g: function() {
                    if (!_pluginVersionStringArr) {
                      _setPluginVersions();
                    }
                    return _pluginVersionStringArr;
                  }
                });
                objDefine(_self, "pluginVersionString", {
                  g: function() {
                    if (!_pluginVersionString) {
                      if (!_pluginVersionStringArr) {
                        _setPluginVersions();
                      }
                      _pluginVersionString = _pluginVersionStringArr.join(";");
                    }
                    return _pluginVersionString || STR_EMPTY$1;
                  }
                });
                objDefine(_self, "logger", {
                  g: function() {
                    if (!_logger) {
                      _logger = new DiagnosticLogger(_configHandler.cfg);
                      _configHandler[_DYN_LOGGER] = _logger;
                    }
                    return _logger;
                  },
                  s: function(newLogger) {
                    _configHandler[_DYN_LOGGER] = newLogger;
                    if (_logger !== newLogger) {
                      runTargetUnload(_logger, false);
                      _logger = newLogger;
                    }
                  }
                });
                _self[_DYN_LOGGER] = new DiagnosticLogger(_configHandler.cfg);
                _extensions = [];
                var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
                cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$2]);
                arrAppend(cfgExtensions, _extensions);
                _telemetryInitializerPlugin = new TelemetryInitializerPlugin();
                _eventQueue = [];
                runTargetUnload(_notificationManager, false);
                _notificationManager = null;
                _perfManager = null;
                _cfgPerfManager = null;
                runTargetUnload(_cookieManager, false);
                _cookieManager = null;
                _pluginChain = null;
                _configExtensions = [];
                _channelConfig = null;
                _channels = null;
                _isUnloading = false;
                _internalLogsEventName = null;
                _evtNamespace = createUniqueNamespace("AIBaseCore", true);
                _unloadHandlers = createUnloadHandlerContainer();
                _traceCtx = null;
                _instrumentationKey = null;
                _hookContainer = createUnloadHookContainer();
                _cfgListeners = [];
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller = null;
                _internalLogPollerListening = false;
                _activeStatus = 0;
                _endpoint = null;
                _initInMemoMaxSize = null;
                _isStatusSet = false;
                _initTimer = null;
              }
              function _createTelCtx() {
                var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);
                theCtx[_DYN_ON_COMPLETE](_startLogPoller);
                return theCtx;
              }
              function _initPluginChain(updateState) {
                var theExtensions = _validateExtensions(_self[_DYN_LOGGER], ChannelControllerPriority, _configExtensions);
                _pluginChain = null;
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                _channels = (_channelConfig || [])[0] || [];
                _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS]));
                var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE]), _channels);
                _extensions = objFreeze(allExtensions);
                var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
                cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH$2]);
                arrAppend(cfgExtensions, _extensions);
                var rootCtx = _createTelCtx();
                if (_channels && _channels[_DYN_LENGTH$2] > 0) {
                  initializePlugins(rootCtx[_DYN_CREATE_NEW](_channels), allExtensions);
                }
                initializePlugins(rootCtx, allExtensions);
                if (updateState) {
                  _doUpdate(updateState);
                }
              }
              function _getPlugin(pluginIdentifier) {
                var theExt = null;
                var thePlugin = null;
                var channelHosts = [];
                arrForEach(_extensions, function(ext) {
                  if (ext[_DYN_IDENTIFIER] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {
                    thePlugin = ext;
                    return -1;
                  }
                  if (ext.getChannel) {
                    channelHosts[_DYN_PUSH$1](ext);
                  }
                });
                if (!thePlugin && channelHosts[_DYN_LENGTH$2] > 0) {
                  arrForEach(channelHosts, function(host) {
                    thePlugin = host.getChannel(pluginIdentifier);
                    if (!thePlugin) {
                      return -1;
                    }
                  });
                }
                if (thePlugin) {
                  theExt = {
                    plugin: thePlugin,
                    setEnabled: function(enabled) {
                      _getPluginState(thePlugin)[STR_DISABLED] = !enabled;
                    },
                    isEnabled: function() {
                      var pluginState = _getPluginState(thePlugin);
                      return !pluginState[_DYN_TEARDOWN] && !pluginState[STR_DISABLED];
                    },
                    remove: function(isAsync, removeCb) {
                      if (isAsync === void 0) {
                        isAsync = true;
                      }
                      var pluginsToRemove = [thePlugin];
                      var unloadState = {
                        reason: 1,
                        isAsync
                      };
                      _removePlugins(pluginsToRemove, unloadState, function(removed) {
                        if (removed) {
                          _initPluginChain({
                            reason: 32,
                            removed: pluginsToRemove
                          });
                        }
                        removeCb && removeCb(removed);
                      });
                    }
                  };
                }
                return theExt;
              }
              function _getPluginChain() {
                if (!_pluginChain) {
                  var extensions3 = (_extensions || []).slice();
                  if (arrIndexOf(extensions3, _telemetryInitializerPlugin) === -1) {
                    extensions3[_DYN_PUSH$1](_telemetryInitializerPlugin);
                  }
                  _pluginChain = createTelemetryProxyChain(sortPlugins(extensions3), _configHandler.cfg, _self);
                }
                return _pluginChain;
              }
              function _removePlugins(thePlugins, unloadState, removeComplete) {
                if (thePlugins && thePlugins[_DYN_LENGTH$2] > 0) {
                  var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self);
                  var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);
                  unloadCtx[_DYN_ON_COMPLETE](function() {
                    var removed = false;
                    var newConfigExtensions = [];
                    arrForEach(_configExtensions, function(plugin, idx) {
                      if (!_isPluginPresent(plugin, thePlugins)) {
                        newConfigExtensions[_DYN_PUSH$1](plugin);
                      } else {
                        removed = true;
                      }
                    });
                    _configExtensions = newConfigExtensions;
                    _pluginVersionString = null;
                    _pluginVersionStringArr = null;
                    var newChannelConfig = [];
                    if (_channelConfig) {
                      arrForEach(_channelConfig, function(queue, idx) {
                        var newQueue = [];
                        arrForEach(queue, function(channel) {
                          if (!_isPluginPresent(channel, thePlugins)) {
                            newQueue[_DYN_PUSH$1](channel);
                          } else {
                            removed = true;
                          }
                        });
                        newChannelConfig[_DYN_PUSH$1](newQueue);
                      });
                      _channelConfig = newChannelConfig;
                    }
                    removeComplete && removeComplete(removed);
                    _startLogPoller();
                  });
                  unloadCtx[_DYN_PROCESS_NEXT](unloadState);
                } else {
                  removeComplete(false);
                }
              }
              function _flushInternalLogs() {
                if (_logger && _logger.queue) {
                  var queue = _logger.queue.slice(0);
                  _logger.queue[_DYN_LENGTH$2] = 0;
                  arrForEach(queue, function(logMessage) {
                    var item = {
                      name: _internalLogsEventName ? _internalLogsEventName : "InternalMessageId: " + logMessage[_DYN_MESSAGE_ID],
                      iKey: _instrumentationKey,
                      time: toISOString(/* @__PURE__ */ new Date()),
                      baseType: _InternalLogMessage.dataType,
                      baseData: { message: logMessage[_DYN_MESSAGE$1] }
                    };
                    _self.track(item);
                  });
                }
              }
              function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
                var waiting = 1;
                var doneIterating = false;
                var cbTimer = null;
                cbTimeout = cbTimeout || 5e3;
                function doCallback() {
                  waiting--;
                  if (doneIterating && waiting === 0) {
                    cbTimer && cbTimer[_DYN_CANCEL]();
                    cbTimer = null;
                    callBack && callBack(doneIterating);
                    callBack = null;
                  }
                }
                if (_channels && _channels[_DYN_LENGTH$2] > 0) {
                  var flushCtx = _createTelCtx()[_DYN_CREATE_NEW](_channels);
                  flushCtx.iterate(function(plugin) {
                    if (plugin.flush) {
                      waiting++;
                      var handled_1 = false;
                      if (!plugin.flush(isAsync, function() {
                        handled_1 = true;
                        doCallback();
                      }, sendReason)) {
                        if (!handled_1) {
                          if (isAsync && cbTimer == null) {
                            cbTimer = scheduleTimeout(function() {
                              cbTimer = null;
                              doCallback();
                            }, cbTimeout);
                          } else {
                            doCallback();
                          }
                        }
                      }
                    }
                  });
                }
                doneIterating = true;
                doCallback();
                return true;
              }
              function _initPerfManager() {
                var prevCfgPerfMgr;
                _addUnloadHook(_configHandler[_DYN_WATCH](function(details) {
                  var enablePerfMgr = details.cfg.enablePerfMgr;
                  if (enablePerfMgr) {
                    var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR];
                    if (prevCfgPerfMgr !== createPerfMgr || !prevCfgPerfMgr) {
                      if (!createPerfMgr) {
                        createPerfMgr = _createPerfManager;
                      }
                      getSetValue(details.cfg, STR_CREATE_PERF_MGR, createPerfMgr);
                      prevCfgPerfMgr = createPerfMgr;
                      _cfgPerfManager = null;
                    }
                    if (!_perfManager && !_cfgPerfManager && isFunction(createPerfMgr)) {
                      _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR]());
                    }
                  } else {
                    _cfgPerfManager = null;
                    prevCfgPerfMgr = null;
                  }
                }));
              }
              function _doUpdate(updateState) {
                var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);
                updateCtx[_DYN_ON_COMPLETE](_startLogPoller);
                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {
                  updateCtx[_DYN_PROCESS_NEXT](updateState);
                }
              }
              function _logOrThrowError(message) {
                var logger2 = _self[_DYN_LOGGER];
                if (logger2) {
                  _throwInternal(logger2, 2, 73, message);
                  _startLogPoller();
                } else {
                  throwError(message);
                }
              }
              function _notifyInvalidEvent(telemetryItem) {
                var manager = _self[_DYN_GET_NOTIFY_MGR]();
                if (manager) {
                  manager[STR_EVENTS_DISCARDED]([telemetryItem], 2);
                }
              }
              function _addUnloadHook(hooks) {
                _hookContainer.add(hooks);
              }
            });
          }
          AppInsightsCore2.__ieDyn = 1;
          return AppInsightsCore2;
        }()
      );
      function parseResponse(response, diagLog) {
        try {
          if (response && response !== "") {
            var result = getJSON().parse(response);
            if (result && result[_DYN_ITEMS_RECEIVED$1] && result[_DYN_ITEMS_RECEIVED$1] >= result.itemsAccepted && result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH$2]) {
              return result;
            }
          }
        } catch (e) {
          _throwInternal(diagLog, 1, 43, "Cannot parse the response. " + (e[_DYN_NAME$2] || /* @__PURE__ */ dumpObj(e)), {
            response
          });
        }
        return null;
      }
      var STR_EMPTY = "";
      var STR_NO_RESPONSE_BODY = "NoResponseBody";
      var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
      var STR_POST_METHOD = "POST";
      var SenderPostManager = (
        /** @class */
        function() {
          function SenderPostManager2() {
            var _syncFetchPayload = 0;
            var _enableSendPromise;
            var _isInitialized;
            var _diagLog;
            var _isOneDs;
            var _onCompleteFuncs;
            var _disableCredentials;
            var _fetchCredentials;
            var _fallbackInst;
            var _disableXhr;
            var _disableBeacon;
            var _disableBeaconSync;
            var _disableFetchKeepAlive;
            var _addNoResponse;
            var _timeoutWrapper;
            dynamicProto(SenderPostManager2, this, function(_self, _base) {
              var _sendCredentials = true;
              _initDefaults();
              _self[_DYN_INITIALIZE$1] = function(config, diagLog) {
                _diagLog = diagLog;
                if (_isInitialized) {
                  _throwInternal(_diagLog, 1, 28, "Sender is already initialized");
                }
                _self.SetConfig(config);
                _isInitialized = true;
              };
              _self["_getDbgPlgTargets"] = function() {
                return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
              };
              _self.SetConfig = function(config) {
                try {
                  _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                  _disableCredentials = !!config.disableCredentials;
                  _fetchCredentials = config.fetchCredentials;
                  _isOneDs = !!config.isOneDs;
                  _enableSendPromise = !!config.enableSendPromise;
                  _disableXhr = !!config.disableXhr;
                  _disableBeacon = !!config.disableBeacon;
                  _disableBeaconSync = !!config.disableBeaconSync;
                  _timeoutWrapper = config.timeWrapper;
                  _addNoResponse = !!config.addNoResponse;
                  _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                  _fallbackInst = { sendPOST: _xhrSender };
                  if (!_isOneDs) {
                    _sendCredentials = false;
                  }
                  if (_disableCredentials) {
                    var location_1 = getLocation();
                    if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE$1]() === "file:") {
                      _sendCredentials = false;
                    }
                  }
                  return true;
                } catch (e) {
                }
                return false;
              };
              _self.getSyncFetchPayload = function() {
                return _syncFetchPayload;
              };
              _self.getSenderInst = function(transports, sync) {
                if (transports && transports[_DYN_LENGTH$2]) {
                  return _getSenderInterface(transports, sync);
                }
                return null;
              };
              _self.getFallbackInst = function() {
                return _fallbackInst;
              };
              _self[_DYN__DO_TEARDOWN] = function(unloadCtx, unloadState) {
                _initDefaults();
              };
              _self.preparePayload = function(callback, zipPayload, payload, isSync) {
                if (!zipPayload || isSync || !payload[_DYN_DATA$1]) {
                  callback(payload);
                  return;
                }
                try {
                  var csStream = /* @__PURE__ */ getInst("CompressionStream");
                  if (!isFunction(csStream)) {
                    callback(payload);
                    return;
                  }
                  var body = new ReadableStream({
                    start: function(controller) {
                      controller.enqueue(isString(payload[_DYN_DATA$1]) ? new TextEncoder().encode(payload[_DYN_DATA$1]) : payload[_DYN_DATA$1]);
                      controller.close();
                    }
                  });
                  var compressedStream = body.pipeThrough(new csStream("gzip"));
                  var reader_1 = compressedStream.getReader();
                  var chunks_1 = [];
                  var totalLength_1 = 0;
                  var callbackCalled_1 = false;
                  doAwaitResponse(reader_1.read(), function processChunk(response) {
                    if (!callbackCalled_1 && !response.rejected) {
                      var result = response[_DYN_VALUE];
                      if (!result.done) {
                        chunks_1[_DYN_PUSH$1](result[_DYN_VALUE]);
                        totalLength_1 += result.value[_DYN_LENGTH$2];
                        return doAwaitResponse(reader_1.read(), processChunk);
                      }
                      var combined = new Uint8Array(totalLength_1);
                      var offset = 0;
                      for (var _i = 0, chunks_2 = chunks_1; _i < chunks_2.length; _i++) {
                        var chunk = chunks_2[_i];
                        combined.set(chunk, offset);
                        offset += chunk[_DYN_LENGTH$2];
                      }
                      payload[_DYN_DATA$1] = combined;
                      payload[_DYN_HEADERS]["Content-Encoding"] = "gzip";
                      payload._chunkCount = chunks_1[_DYN_LENGTH$2];
                    }
                    if (!callbackCalled_1) {
                      callbackCalled_1 = true;
                      callback(payload);
                    }
                  });
                  return reader_1;
                } catch (error) {
                  callback(payload);
                  return;
                }
              };
              function _onSuccess(res, onComplete) {
                _doOnComplete(onComplete, 200, {}, res);
              }
              function _onError(message, onComplete) {
                _throwInternal(_diagLog, 2, 26, "Failed to send telemetry.", { message });
                _doOnComplete(onComplete, 400, {});
              }
              function _onNoPayloadUrl(onComplete) {
                _onError("No endpoint url is provided for the batch", onComplete);
              }
              function _getSenderInterface(transports, syncSupport) {
                var transportType = 0;
                var sendPostFunc = null;
                var lp = 0;
                while (sendPostFunc == null && lp < transports[_DYN_LENGTH$2]) {
                  transportType = transports[lp];
                  if (!_disableXhr && transportType === 1) {
                    if (useXDomainRequest()) {
                      sendPostFunc = _xdrSender;
                    } else if (isXhrSupported()) {
                      sendPostFunc = _xhrSender;
                    }
                  } else if (transportType === 2 && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                    sendPostFunc = _doFetchSender;
                  } else if (transportType === 3 && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                    sendPostFunc = _beaconSender;
                  }
                  lp++;
                }
                if (sendPostFunc) {
                  return {
                    _transport: transportType,
                    _isSync: syncSupport,
                    sendPOST: sendPostFunc
                  };
                }
                return null;
              }
              function _doOnComplete(oncomplete, status, headers, response) {
                try {
                  oncomplete && oncomplete(status, headers, response);
                } catch (e) {
                }
              }
              function _doBeaconSend(payload, oncomplete) {
                var nav = getNavigator();
                var url = payload[_DYN_URL_STRING];
                if (!url) {
                  _onNoPayloadUrl(oncomplete);
                  return true;
                }
                url = payload[_DYN_URL_STRING] + (_addNoResponse ? _noResponseQs : STR_EMPTY);
                var data = payload[_DYN_DATA$1];
                var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                var queued = nav.sendBeacon(url, plainTextBatch);
                return queued;
              }
              function _beaconSender(payload, oncomplete, sync) {
                var data = payload[_DYN_DATA$1];
                try {
                  if (data) {
                    if (!_doBeaconSend(payload, oncomplete)) {
                      var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                      if (onRetry && isFunction(onRetry)) {
                        onRetry(payload, oncomplete, _doBeaconSend);
                      } else {
                        _fallbackInst && _fallbackInst.sendPOST(payload, oncomplete, true);
                        _throwInternal(_diagLog, 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");
                      }
                    } else {
                      _onSuccess(STR_EMPTY, oncomplete);
                    }
                  }
                } catch (e) {
                  _isOneDs && _warnToConsole(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + /* @__PURE__ */ dumpObj(e));
                  _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY);
                }
                return;
              }
              function _xhrSender(payload, oncomplete, sync) {
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var headers = payload[_DYN_HEADERS] || {};
                if (!sync && _enableSendPromise) {
                  thePromise = createPromise(function(resolve3, reject) {
                    resolveFunc = resolve3;
                    rejectFunc = reject;
                  });
                }
                if (_isOneDs && sync && payload.disableXhrSync) {
                  sync = false;
                }
                var endPointUrl = payload[_DYN_URL_STRING];
                if (!endPointUrl) {
                  _onNoPayloadUrl(oncomplete);
                  resolveFunc && resolveFunc(false);
                  return;
                }
                var xhr = openXhr(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT]);
                if (!_isOneDs) {
                  xhr.setRequestHeader("Content-type", "application/json");
                }
                arrForEach(objKeys(headers), function(headerName) {
                  xhr.setRequestHeader(headerName, headers[headerName]);
                });
                xhr.onreadystatechange = function() {
                  if (!_isOneDs) {
                    _doOnReadyFunc(xhr);
                    if (xhr.readyState === 4) {
                      resolveFunc && resolveFunc(true);
                    }
                  }
                };
                xhr.onload = function() {
                  if (_isOneDs) {
                    _doOnReadyFunc(xhr);
                  }
                };
                function _doOnReadyFunc(xhr2) {
                  var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                  var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);
                  if (onReadyFuncExist) {
                    onReadyFunc(xhr2, oncomplete, payload);
                  } else {
                    var response = getResponseText(xhr2);
                    _doOnComplete(oncomplete, xhr2[_DYN_STATUS], _getAllResponseHeaders(xhr2, _isOneDs), response);
                  }
                }
                xhr.onerror = function(event) {
                  _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));
                  rejectFunc && rejectFunc(event);
                };
                xhr.ontimeout = function() {
                  _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));
                  resolveFunc && resolveFunc(false);
                };
                xhr.send(payload[_DYN_DATA$1]);
                return thePromise;
              }
              function _doFetchSender(payload, oncomplete, sync) {
                var _a2;
                var endPointUrl = payload[_DYN_URL_STRING];
                var batch = payload[_DYN_DATA$1];
                var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var requestHeaders = new Headers();
                var batchLength = batch[_DYN_LENGTH$2];
                var ignoreResponse = false;
                var responseHandled = false;
                var headers = payload[_DYN_HEADERS] || {};
                var init = (_a2 = {
                  method: STR_POST_METHOD,
                  body: plainTextBatch
                }, _a2[DisabledPropertyName] = true, _a2);
                if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH$2] > 0) {
                  arrForEach(objKeys(headers), function(headerName) {
                    requestHeaders.append(headerName, headers[headerName]);
                  });
                  init[_DYN_HEADERS] = requestHeaders;
                }
                if (_fetchCredentials) {
                  init.credentials = _fetchCredentials;
                } else if (_sendCredentials && _isOneDs) {
                  init.credentials = "include";
                }
                if (sync) {
                  init.keepalive = true;
                  _syncFetchPayload += batchLength;
                  if (_isOneDs) {
                    if (payload["_sendReason"] === 2) {
                      ignoreResponse = true;
                      if (_addNoResponse) {
                        endPointUrl += _noResponseQs;
                      }
                    }
                  } else {
                    ignoreResponse = true;
                  }
                }
                var request = new Request(endPointUrl, init);
                try {
                  request[DisabledPropertyName] = true;
                } catch (e) {
                }
                if (!sync && _enableSendPromise) {
                  thePromise = createPromise(function(resolve3, reject) {
                    resolveFunc = resolve3;
                    rejectFunc = reject;
                  });
                }
                if (!endPointUrl) {
                  _onNoPayloadUrl(oncomplete);
                  resolveFunc && resolveFunc(false);
                  return;
                }
                function _handleError(res, statusCode) {
                  if (statusCode) {
                    _doOnComplete(oncomplete, _isOneDs ? 0 : statusCode, {}, _isOneDs ? STR_EMPTY : res);
                  } else {
                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY : res);
                  }
                }
                function _onFetchComplete(response, payload2, value) {
                  var status = response[_DYN_STATUS];
                  var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                  if (onCompleteFunc && isFunction(onCompleteFunc)) {
                    onCompleteFunc(response, oncomplete, value || STR_EMPTY, payload2);
                  } else {
                    _doOnComplete(oncomplete, status, {}, value || STR_EMPTY);
                  }
                }
                try {
                  doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function(result) {
                    if (sync) {
                      _syncFetchPayload -= batchLength;
                      batchLength = 0;
                    }
                    if (!responseHandled) {
                      responseHandled = true;
                      if (!result.rejected) {
                        var response_1 = result[_DYN_VALUE];
                        try {
                          if (!_isOneDs && !response_1.ok) {
                            if (response_1[_DYN_STATUS]) {
                              _handleError(response_1.statusText, response_1[_DYN_STATUS]);
                            } else {
                              _handleError(response_1.statusText, 499);
                            }
                            resolveFunc && resolveFunc(false);
                          } else {
                            if (_isOneDs && !response_1.body) {
                              _onFetchComplete(response_1, null, STR_EMPTY);
                              resolveFunc && resolveFunc(true);
                            } else {
                              doAwaitResponse(response_1.text(), function(resp) {
                                _onFetchComplete(response_1, payload, resp[_DYN_VALUE]);
                                resolveFunc && resolveFunc(true);
                              });
                            }
                          }
                        } catch (e) {
                          if (response_1 && response_1[_DYN_STATUS]) {
                            _handleError(/* @__PURE__ */ dumpObj(e), response_1[_DYN_STATUS]);
                          } else {
                            _handleError(/* @__PURE__ */ dumpObj(e), 499);
                          }
                          rejectFunc && rejectFunc(e);
                        }
                      } else {
                        _handleError(result.reason && result.reason[_DYN_MESSAGE$1], 499);
                        rejectFunc && rejectFunc(result.reason);
                      }
                    }
                  });
                } catch (e) {
                  if (!responseHandled) {
                    _handleError(/* @__PURE__ */ dumpObj(e), 499);
                    rejectFunc && rejectFunc(e);
                  }
                }
                if (ignoreResponse && !responseHandled) {
                  responseHandled = true;
                  _doOnComplete(oncomplete, 200, {});
                  resolveFunc && resolveFunc(true);
                }
                if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT] > 0) {
                  _timeoutWrapper && _timeoutWrapper.set(function() {
                    if (!responseHandled) {
                      responseHandled = true;
                      _doOnComplete(oncomplete, 500, {});
                      resolveFunc && resolveFunc(true);
                    }
                  }, payload[_DYN_TIMEOUT]);
                }
                return thePromise;
              }
              function _xdrSender(payload, oncomplete, sync) {
                var _window = getWindow();
                var xdr = new XDomainRequest();
                var data = payload[_DYN_DATA$1];
                xdr.onload = function() {
                  var response = getResponseText(xdr);
                  var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                  if (onloadFunc && isFunction(onloadFunc)) {
                    onloadFunc(xdr, oncomplete, payload);
                  } else {
                    _doOnComplete(oncomplete, 200, {}, response);
                  }
                };
                xdr.onerror = function() {
                  _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY : formatErrorMessageXdr(xdr));
                };
                xdr.ontimeout = function() {
                  _doOnComplete(oncomplete, 500, {});
                };
                xdr.onprogress = function() {
                };
                var hostingProtocol = _window && _window.location && _window.location.protocol || "";
                var endpoint = payload[_DYN_URL_STRING];
                if (!endpoint) {
                  _onNoPayloadUrl(oncomplete);
                  return;
                }
                if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                  var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                  _throwInternal(_diagLog, 2, 40, ". " + msg);
                  _onError(msg, oncomplete);
                  return;
                }
                var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE](/^(https?:)/, "");
                xdr.open(STR_POST_METHOD, endpointUrl);
                if (payload[_DYN_TIMEOUT]) {
                  xdr[_DYN_TIMEOUT] = payload[_DYN_TIMEOUT];
                }
                xdr.send(data);
                if (_isOneDs && sync) {
                  _timeoutWrapper && _timeoutWrapper.set(function() {
                    xdr.send(data);
                  }, 0);
                } else {
                  xdr.send(data);
                }
              }
              function _initDefaults() {
                _syncFetchPayload = 0;
                _isInitialized = false;
                _enableSendPromise = false;
                _diagLog = null;
                _isOneDs = null;
                _onCompleteFuncs = null;
                _disableCredentials = null;
                _fetchCredentials = null;
                _fallbackInst = null;
                _disableXhr = false;
                _disableBeacon = false;
                _disableBeaconSync = false;
                _disableFetchKeepAlive = false;
                _addNoResponse = false;
                _timeoutWrapper = null;
              }
            });
          }
          SenderPostManager2.__ieDyn = 1;
          return SenderPostManager2;
        }()
      );
      var strOnPrefix = "on";
      var strAttachEvent = "attachEvent";
      var strAddEventHelper = "addEventListener";
      var strDetachEvent = "detachEvent";
      var strRemoveEventListener = "removeEventListener";
      var strEvents = "events";
      createUniqueNamespace("aiEvtPageHide");
      createUniqueNamespace("aiEvtPageShow");
      var rRemoveEmptyNs = /\.[\.]+/g;
      var rRemoveTrailingEmptyNs = /[\.]+$/;
      var _guid = 1;
      var elmNodeData = createElmNodeData("events");
      var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
      function _normalizeNamespace(name) {
        if (name && name[_DYN_REPLACE]) {
          return name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY$1);
        }
        return name;
      }
      function _getEvtNamespace(eventName, evtNamespace) {
        if (evtNamespace) {
          var theNamespace_1 = STR_EMPTY$1;
          if (isArray(evtNamespace)) {
            theNamespace_1 = STR_EMPTY$1;
            arrForEach(evtNamespace, function(name) {
              name = _normalizeNamespace(name);
              if (name) {
                if (name[0] !== ".") {
                  name = "." + name;
                }
                theNamespace_1 += name;
              }
            });
          } else {
            theNamespace_1 = _normalizeNamespace(evtNamespace);
          }
          if (theNamespace_1) {
            if (theNamespace_1[0] !== ".") {
              theNamespace_1 = "." + theNamespace_1;
            }
            eventName = (eventName || STR_EMPTY$1) + theNamespace_1;
          }
        }
        var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY$1) || [];
        return {
          type: parsedEvent[1],
          ns: (parsedEvent[2] || STR_EMPTY$1).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY$1)[_DYN_SPLIT$1](".").sort().join(".")
        };
      }
      function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) {
          addDefault = true;
        }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
          registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
      }
      function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE]) {
          if (obj[strRemoveEventListener]) {
            obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture);
          } else if (obj[strDetachEvent]) {
            obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
          }
        }
      }
      function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE] && handlerRef) {
          if (obj[strAddEventHelper]) {
            obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture);
            result = true;
          } else if (obj[strAttachEvent]) {
            obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
            result = true;
          }
        }
        return result;
      }
      function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH$2];
        while (idx--) {
          var theEvent = events[idx];
          if (theEvent) {
            if (!evtName.ns || evtName.ns === theEvent[_DYN_EVT_NAME].ns) {
              if (!unRegFn || unRegFn(theEvent)) {
                _doDetach(target, theEvent[_DYN_EVT_NAME], theEvent.handler, theEvent.capture);
                events[_DYN_SPLICE](idx, 1);
              }
            }
          }
        }
      }
      function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE]) {
          _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);
        } else {
          var eventCache = elmNodeData.get(target, strEvents, {});
          objForEachKey(eventCache, function(evtType, events) {
            _doUnregister(target, events, evtName, unRegFn);
          });
          if (objKeys(eventCache)[_DYN_LENGTH$2] === 0) {
            elmNodeData.kill(target, strEvents);
          }
        }
      }
      function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
          if (isArray(namespaces)) {
            newNamespaces = [theNamespace].concat(namespaces);
          } else {
            newNamespaces = [theNamespace, namespaces];
          }
          newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT$1](".");
        } else {
          newNamespaces = theNamespace;
        }
        return newNamespaces;
      }
      function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        var result = false;
        if (target) {
          try {
            var evtName = _getEvtNamespace(eventName, evtNamespace);
            result = _doAttach(target, evtName, handlerRef, useCapture);
            if (result && elmNodeData.accept(target)) {
              var registeredEvent = {
                guid: _guid++,
                evtName,
                handler: handlerRef,
                capture: useCapture
              };
              _getRegisteredEvents(target, evtName.type)[_DYN_PUSH$1](registeredEvent);
            }
          } catch (e) {
          }
        }
        return result;
      }
      function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        if (target) {
          try {
            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
            var found_1 = false;
            _unregisterEvents(target, evtName_1, function(regEvent) {
              if (evtName_1.ns && !handlerRef || regEvent.handler === handlerRef) {
                found_1 = true;
                return true;
              }
              return false;
            });
            if (!found_1) {
              _doDetach(target, evtName_1, handlerRef, useCapture);
            }
          } catch (e) {
          }
        }
      }
      var SampleRate = "sampleRate";
      var ProcessLegacy = "ProcessLegacy";
      var HttpMethod = "http.method";
      var DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
      var DEFAULT_BREEZE_PATH = "/v2/track";
      var strNotSpecified = "not_specified";
      var RequestHeaders = createValueMap({
        requestContextHeader: [0, "Request-Context"],
        requestContextTargetKey: [1, "appId"],
        requestContextAppIdFormat: [2, "appId=cid-v1:"],
        requestIdHeader: [3, "Request-Id"],
        traceParentHeader: [4, "traceparent"],
        traceStateHeader: [5, "tracestate"],
        sdkContextHeader: [6, "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7, "appId"],
        requestContextHeaderLowerCase: [8, "request-context"]
      });
      var _DYN_SPLIT = "split";
      var _DYN_LENGTH$1 = "length";
      var _DYN_TO_LOWER_CASE = "toLowerCase";
      var _DYN_INGESTIONENDPOINT = "ingestionendpoint";
      var _DYN_TO_STRING$1 = "toString";
      var _DYN_REMOVE_ITEM = "removeItem";
      var _DYN_MESSAGE = "message";
      var _DYN_COUNT$1 = "count";
      var _DYN_STRINGIFY$1 = "stringify";
      var _DYN_PATHNAME = "pathname";
      var _DYN_MATCH = "match";
      var _DYN_NAME$1 = "name";
      var _DYN_PROPERTIES = "properties";
      var _DYN_MEASUREMENTS$1 = "measurements";
      var _DYN_SIZE_IN_BYTES = "sizeInBytes";
      var _DYN_TYPE_NAME = "typeName";
      var _DYN_EXCEPTIONS = "exceptions";
      var _DYN_SEVERITY_LEVEL = "severityLevel";
      var _DYN_PROBLEM_GROUP = "problemGroup";
      var _DYN_PARSED_STACK = "parsedStack";
      var _DYN_HAS_FULL_STACK = "hasFullStack";
      var _DYN_ASSEMBLY = "assembly";
      var _DYN_FILE_NAME = "fileName";
      var _DYN_LINE = "line";
      var _DYN_AI_DATA_CONTRACT = "aiDataContract";
      var _DYN_DURATION = "duration";
      function dataSanitizeKeyAndAddUniqueness(logger2, key, map) {
        var origLength = key[_DYN_LENGTH$1];
        var field = dataSanitizeKey(logger2, key);
        if (field[_DYN_LENGTH$1] !== origLength) {
          var i = 0;
          var uniqueField = field;
          while (map[uniqueField] !== void 0) {
            i++;
            uniqueField = strSubstring(field, 0, 150 - 3) + dsPadNumber(i);
          }
          field = uniqueField;
        }
        return field;
      }
      function dataSanitizeKey(logger2, name) {
        var nameTrunc;
        if (name) {
          name = strTrim(asString(name));
          if (name[_DYN_LENGTH$1] > 150) {
            nameTrunc = strSubstring(name, 0, 150);
            _throwInternal(logger2, 2, 57, "name is too long.  It has been truncated to 150 characters.", { name }, true);
          }
        }
        return nameTrunc || name;
      }
      function dataSanitizeString(logger2, value, maxLength) {
        if (maxLength === void 0) {
          maxLength = 1024;
        }
        var valueTrunc;
        if (value) {
          maxLength = maxLength ? maxLength : 1024;
          value = strTrim(asString(value));
          if (value[_DYN_LENGTH$1] > maxLength) {
            valueTrunc = strSubstring(value, 0, maxLength);
            _throwInternal(logger2, 2, 61, "string value is too long. It has been truncated to " + maxLength + " characters.", { value }, true);
          }
        }
        return valueTrunc || value;
      }
      function dataSanitizeUrl(logger2, url) {
        return dataSanitizeInput(logger2, url, 2048, 66);
      }
      function dataSanitizeMessage(logger2, message) {
        var messageTrunc;
        if (message) {
          if (message[_DYN_LENGTH$1] > 32768) {
            messageTrunc = strSubstring(message, 0, 32768);
            _throwInternal(logger2, 2, 56, "message is too long, it has been truncated to 32768 characters.", { message }, true);
          }
        }
        return messageTrunc || message;
      }
      function dataSanitizeException(logger2, exception) {
        var exceptionTrunc;
        if (exception) {
          var value = "" + exception;
          if (value[_DYN_LENGTH$1] > 32768) {
            exceptionTrunc = strSubstring(value, 0, 32768);
            _throwInternal(logger2, 2, 52, "exception is too long, it has been truncated to 32768 characters.", { exception }, true);
          }
        }
        return exceptionTrunc || exception;
      }
      function dataSanitizeProperties(logger2, properties) {
        if (properties) {
          var tempProps_1 = {};
          objForEachKey(properties, function(prop, value) {
            if (/* @__PURE__ */ isObject(value) && hasJSON()) {
              try {
                value = getJSON()[_DYN_STRINGIFY$1](value);
              } catch (e) {
                _throwInternal(logger2, 2, 49, "custom property is not valid", { exception: e }, true);
              }
            }
            value = dataSanitizeString(logger2, value, 8192);
            prop = dataSanitizeKeyAndAddUniqueness(logger2, prop, tempProps_1);
            tempProps_1[prop] = value;
          });
          properties = tempProps_1;
        }
        return properties;
      }
      function dataSanitizeMeasurements(logger2, measurements) {
        if (measurements) {
          var tempMeasurements_1 = {};
          objForEachKey(measurements, function(measure, value) {
            measure = dataSanitizeKeyAndAddUniqueness(logger2, measure, tempMeasurements_1);
            tempMeasurements_1[measure] = value;
          });
          measurements = tempMeasurements_1;
        }
        return measurements;
      }
      function dataSanitizeId(logger2, id) {
        return id ? dataSanitizeInput(logger2, id, 128, 69)[_DYN_TO_STRING$1]() : id;
      }
      function dataSanitizeInput(logger2, input, maxLength, _msgId) {
        var inputTrunc;
        if (input) {
          input = strTrim(asString(input));
          if (input[_DYN_LENGTH$1] > maxLength) {
            inputTrunc = strSubstring(input, 0, maxLength);
            _throwInternal(logger2, 2, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
          }
        }
        return inputTrunc || input;
      }
      function dsPadNumber(num) {
        var s = "00" + num;
        return strSubstr(s, s[_DYN_LENGTH$1] - 3);
      }
      var _document = getDocument() || {};
      var _htmlAnchorIdx = 0;
      var _htmlAnchorElement = [null, null, null, null, null];
      function urlParseUrl(url) {
        var anchorIdx = _htmlAnchorIdx;
        var anchorCache = _htmlAnchorElement;
        var tempAnchor = anchorCache[anchorIdx];
        if (!_document.createElement) {
          tempAnchor = { host: urlParseHost(url, true) };
        } else if (!anchorCache[anchorIdx]) {
          tempAnchor = anchorCache[anchorIdx] = _document.createElement("a");
        }
        tempAnchor.href = url;
        anchorIdx++;
        if (anchorIdx >= anchorCache[_DYN_LENGTH$1]) {
          anchorIdx = 0;
        }
        _htmlAnchorIdx = anchorIdx;
        return tempAnchor;
      }
      function urlParseHost(url, inclPort) {
        var fullHost = urlParseFullHost(url, inclPort) || "";
        if (fullHost) {
          var match = fullHost[_DYN_MATCH](/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
          if (match != null && match[_DYN_LENGTH$1] > 3 && isString(match[2]) && match[2][_DYN_LENGTH$1] > 0) {
            return match[2] + (match[3] || "");
          }
        }
        return fullHost;
      }
      function urlParseFullHost(url, inclPort) {
        var result = null;
        if (url) {
          var match = url[_DYN_MATCH](/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
          if (match != null && match[_DYN_LENGTH$1] > 2 && isString(match[2]) && match[2][_DYN_LENGTH$1] > 0) {
            result = match[2] || "";
            if (inclPort && match[_DYN_LENGTH$1] > 2) {
              var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE]();
              var port = match[3] || "";
              if (protocol === "http" && port === ":80") {
                port = "";
              } else if (protocol === "https" && port === ":443") {
                port = "";
              }
              result += port;
            }
          }
        }
        return result;
      }
      var _internalEndpoints = [
        DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH,
        "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH,
        "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH
      ];
      function isInternalApplicationInsightsEndpoint(endpointUrl) {
        return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE]()) !== -1;
      }
      function AjaxHelperParseDependencyPath(logger2, absoluteUrl, method, commandName) {
        var target, name = commandName, data = commandName;
        if (absoluteUrl && absoluteUrl[_DYN_LENGTH$1] > 0) {
          var parsedUrl = urlParseUrl(absoluteUrl);
          target = parsedUrl.host;
          if (!name) {
            if (parsedUrl[_DYN_PATHNAME] != null) {
              var pathName = parsedUrl.pathname[_DYN_LENGTH$1] === 0 ? "/" : parsedUrl[_DYN_PATHNAME];
              if (pathName.charAt(0) !== "/") {
                pathName = "/" + pathName;
              }
              data = parsedUrl[_DYN_PATHNAME];
              name = dataSanitizeString(logger2, method ? method + " " + pathName : pathName);
            } else {
              name = dataSanitizeString(logger2, absoluteUrl);
            }
          }
        } else {
          target = commandName;
          name = commandName;
        }
        return {
          target,
          name,
          data
        };
      }
      var StorageType = createEnumStyle({
        LocalStorage: 0,
        SessionStorage: 1
      });
      var _canUseSessionStorage = void 0;
      var _storagePrefix = "";
      function _getVerifiedStorageObject(storageType) {
        try {
          if (/* @__PURE__ */ isNullOrUndefined(getGlobal())) {
            return null;
          }
          var uid = (/* @__PURE__ */ new Date())[_DYN_TO_STRING$1]();
          var storage = /* @__PURE__ */ getInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage");
          var name_1 = _storagePrefix + uid;
          storage.setItem(name_1, uid);
          var fail = storage.getItem(name_1) !== uid;
          storage[_DYN_REMOVE_ITEM](name_1);
          if (!fail) {
            return storage;
          }
        } catch (exception) {
        }
        return null;
      }
      function _getSessionStorageObject() {
        if (utlCanUseSessionStorage()) {
          return _getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return null;
      }
      function utlSetStoragePrefix(storagePrefix) {
        _storagePrefix = storagePrefix || "";
      }
      function utlCanUseSessionStorage(reset) {
        if (reset || _canUseSessionStorage === void 0) {
          _canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage);
        }
        return _canUseSessionStorage;
      }
      function utlGetSessionStorage(logger2, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
          try {
            return storage.getItem(name);
          } catch (e) {
            _canUseSessionStorage = false;
            _throwInternal(logger2, 2, 2, "Browser failed read of session storage. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return null;
      }
      function utlSetSessionStorage(logger2, name, data) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
          try {
            storage.setItem(name, data);
            return true;
          } catch (e) {
            _canUseSessionStorage = false;
            _throwInternal(logger2, 2, 4, "Browser failed write to session storage. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return false;
      }
      function utlRemoveSessionStorage(logger2, name) {
        var storage = _getSessionStorageObject();
        if (storage !== null) {
          try {
            storage[_DYN_REMOVE_ITEM](name);
            return true;
          } catch (e) {
            _canUseSessionStorage = false;
            _throwInternal(logger2, 2, 6, "Browser failed removal of session storage item. " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
          }
        }
        return false;
      }
      var _FIELDS_SEPARATOR = ";";
      var _FIELD_KEY_VALUE_SEPARATOR = "=";
      function parseConnectionString(connectionString) {
        if (!connectionString) {
          return {};
        }
        var kvPairs = connectionString[_DYN_SPLIT](_FIELDS_SEPARATOR);
        var result = arrReduce(kvPairs, function(fields, kv) {
          var kvParts = kv[_DYN_SPLIT](_FIELD_KEY_VALUE_SEPARATOR);
          if (kvParts[_DYN_LENGTH$1] === 2) {
            var key = kvParts[0][_DYN_TO_LOWER_CASE]();
            var value = kvParts[1];
            fields[key] = value;
          }
          return fields;
        }, {});
        if (objKeys(result)[_DYN_LENGTH$1] > 0) {
          if (result.endpointsuffix) {
            var locationPrefix = result.location ? result.location + "." : "";
            result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || "https://" + locationPrefix + "dc." + result.endpointsuffix;
          }
          result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || DEFAULT_BREEZE_ENDPOINT;
          if (strEndsWith(result[_DYN_INGESTIONENDPOINT], "/")) {
            result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT].slice(0, -1);
          }
        }
        return result;
      }
      var Envelope = (
        /** @class */
        /* @__PURE__ */ function() {
          function Envelope2(logger2, data, name) {
            var _this = this;
            var _self = this;
            _self.ver = 1;
            _self.sampleRate = 100;
            _self.tags = {};
            _self[_DYN_NAME$1] = dataSanitizeString(logger2, name) || strNotSpecified;
            _self.data = data;
            _self.time = toISOString(/* @__PURE__ */ new Date());
            _self[_DYN_AI_DATA_CONTRACT] = {
              time: 1,
              iKey: 1,
              name: 1,
              sampleRate: function() {
                return _this.sampleRate === 100 ? 4 : 1;
              },
              tags: 1,
              data: 1
            };
          }
          return Envelope2;
        }()
      );
      var Event$1 = (
        /** @class */
        function() {
          function Event2(logger2, name, properties, measurements) {
            this.aiDataContract = {
              ver: 1,
              name: 1,
              properties: 0,
              measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self[_DYN_NAME$1] = dataSanitizeString(logger2, name) || strNotSpecified;
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(logger2, measurements);
          }
          Event2.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
          Event2.dataType = "EventData";
          return Event2;
        }()
      );
      var STACKFRAME_BASE_SIZE = 58;
      var IS_FRAME = /^\s{0,50}(from\s|at\s|Line\s{1,5}\d{1,10}\s{1,5}of|\w{1,50}@\w{1,80}|[^\(\s\n]+:[0-9\?]+(?::[0-9\?]+)?)/;
      var FULL_STACK_FRAME_1 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+):([0-9\?]+)\)?$/;
      var FULL_STACK_FRAME_2 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+)\)?$/;
      var FULL_STACK_FRAME_3 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\)\]]+)\)?$/;
      var EXTRACT_FILENAME = /(?:^|\(|\s{0,10}[\w\)]+\@)?([^\(\n\s\]\)]+)(?:\:([0-9]+)(?:\:([0-9]+))?)?\)?(?:,|$)/;
      var PARSE_FILENAME_LINE_COL = /([^\(\s\n]+):([0-9]+):([0-9]+)$/;
      var PARSE_FILENAME_LINE_ONLY = /([^\(\s\n]+):([0-9]+)$/;
      var NoMethod = "<no_method>";
      var strError = "error";
      var strStack = "stack";
      var strStackDetails = "stackDetails";
      var strErrorSrc = "errorSrc";
      var strMessage = "message";
      var strDescription = "description";
      var _parseSequence = [
        { re: FULL_STACK_FRAME_1, len: 5, m: 1, fn: 2, ln: 3, col: 4 },
        { chk: _ignoreNative, pre: _scrubAnonymous, re: FULL_STACK_FRAME_2, len: 4, m: 1, fn: 2, ln: 3 },
        { re: FULL_STACK_FRAME_3, len: 3, m: 1, fn: 2, hdl: _handleFilename },
        { re: EXTRACT_FILENAME, len: 2, fn: 1, hdl: _handleFilename }
      ];
      function _scrubAnonymous(frame) {
        return frame.replace(/(\(anonymous\))/, "<anonymous>");
      }
      function _ignoreNative(frame) {
        return strIndexOf(frame, "[native") < 0;
      }
      function _stringify(value, convertToString) {
        var result = value;
        if (result && !isString(result)) {
          if (JSON && JSON[_DYN_STRINGIFY$1]) {
            result = JSON[_DYN_STRINGIFY$1](value);
            if (convertToString && (!result || result === "{}")) {
              if (isFunction(value[_DYN_TO_STRING$1])) {
                result = value[_DYN_TO_STRING$1]();
              } else {
                result = "" + value;
              }
            }
          } else {
            result = "" + value + " - (Missing JSON.stringify)";
          }
        }
        return result || "";
      }
      function _formatMessage(theEvent, errorType) {
        var evtMessage = theEvent;
        if (theEvent) {
          if (evtMessage && !isString(evtMessage)) {
            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;
          }
          if (evtMessage && !isString(evtMessage)) {
            evtMessage = _stringify(evtMessage, true);
          }
          if (theEvent["filename"]) {
            evtMessage = evtMessage + " @" + (theEvent["filename"] || "") + ":" + (theEvent["lineno"] || "?") + ":" + (theEvent["colno"] || "?");
          }
        }
        if (errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1) {
          evtMessage = errorType + ": " + evtMessage;
        }
        return evtMessage || "";
      }
      function _isExceptionDetailsInternal(value) {
        try {
          if (/* @__PURE__ */ isObject(value)) {
            return "hasFullStack" in value && "typeName" in value;
          }
        } catch (e) {
        }
        return false;
      }
      function _isExceptionInternal(value) {
        try {
          if (/* @__PURE__ */ isObject(value)) {
            return "ver" in value && "exceptions" in value && "properties" in value;
          }
        } catch (e) {
        }
        return false;
      }
      function _isStackDetails(details) {
        return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
      }
      function _convertStackObj(errorStack) {
        var src = errorStack || "";
        if (!isString(src)) {
          if (isString(src[strStack])) {
            src = src[strStack];
          } else {
            src = "" + src;
          }
        }
        var items = src[_DYN_SPLIT]("\n");
        return {
          src,
          obj: items
        };
      }
      function _getOperaStack(errorMessage) {
        var stack = [];
        var lines = errorMessage[_DYN_SPLIT]("\n");
        for (var lp = 0; lp < lines[_DYN_LENGTH$1]; lp++) {
          var entry = lines[lp];
          if (lines[lp + 1]) {
            entry += "@" + lines[lp + 1];
            lp++;
          }
          stack.push(entry);
        }
        return {
          src: errorMessage,
          obj: stack
        };
      }
      function _getStackFromErrorObj(errorObj) {
        var details = null;
        if (errorObj) {
          try {
            if (errorObj[strStack]) {
              details = _convertStackObj(errorObj[strStack]);
            } else if (errorObj[strError] && errorObj[strError][strStack]) {
              details = _convertStackObj(errorObj[strError][strStack]);
            } else if (errorObj["exception"] && errorObj.exception[strStack]) {
              details = _convertStackObj(errorObj.exception[strStack]);
            } else if (_isStackDetails(errorObj)) {
              details = errorObj;
            } else if (_isStackDetails(errorObj[strStackDetails])) {
              details = errorObj[strStackDetails];
            } else if (getWindow() && getWindow()["opera"] && errorObj[strMessage]) {
              details = _getOperaStack(errorObj[_DYN_MESSAGE]);
            } else if (errorObj["reason"] && errorObj.reason[strStack]) {
              details = _convertStackObj(errorObj.reason[strStack]);
            } else if (isString(errorObj)) {
              details = _convertStackObj(errorObj);
            } else {
              var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
              if (isString(errorObj[strErrorSrc])) {
                if (evtMessage) {
                  evtMessage += "\n";
                }
                evtMessage += " from " + errorObj[strErrorSrc];
              }
              if (evtMessage) {
                details = _convertStackObj(evtMessage);
              }
            }
          } catch (e) {
            details = _convertStackObj(e);
          }
        }
        return details || {
          src: "",
          obj: null
        };
      }
      function _formatStackTrace(stackDetails) {
        var stack = "";
        if (stackDetails) {
          if (stackDetails.obj) {
            stack = stackDetails.obj.join("\n");
          } else {
            stack = stackDetails.src || "";
          }
        }
        return stack;
      }
      function _parseStack(stack) {
        var parsedStack;
        var frames = stack.obj;
        if (frames && frames[_DYN_LENGTH$1] > 0) {
          parsedStack = [];
          var level_1 = 0;
          var foundStackStart_1 = false;
          var totalSizeInBytes_1 = 0;
          arrForEach(frames, function(frame) {
            if (foundStackStart_1 || _isStackFrame(frame)) {
              var theFrame = asString(frame);
              foundStackStart_1 = true;
              var parsedFrame = _extractStackFrame(theFrame, level_1);
              if (parsedFrame) {
                totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES];
                parsedStack.push(parsedFrame);
                level_1++;
              }
            }
          });
          var exceptionParsedStackThreshold = 32 * 1024;
          if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {
            var left = 0;
            var right = parsedStack[_DYN_LENGTH$1] - 1;
            var size = 0;
            var acceptedLeft = left;
            var acceptedRight = right;
            while (left < right) {
              var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES];
              var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES];
              size += lSize + rSize;
              if (size > exceptionParsedStackThreshold) {
                var howMany = acceptedRight - acceptedLeft + 1;
                parsedStack.splice(acceptedLeft, howMany);
                break;
              }
              acceptedLeft = left;
              acceptedRight = right;
              left++;
              right--;
            }
          }
        }
        return parsedStack;
      }
      function _getErrorType(errorType) {
        var typeName = "";
        if (errorType) {
          typeName = errorType.typeName || errorType[_DYN_NAME$1] || "";
          if (!typeName) {
            try {
              var funcNameRegex = /function (.{1,200})\(/;
              var results = funcNameRegex.exec(errorType.constructor[_DYN_TO_STRING$1]());
              typeName = results && results[_DYN_LENGTH$1] > 1 ? results[1] : "";
            } catch (e) {
            }
          }
        }
        return typeName;
      }
      function _formatErrorCode(errorObj) {
        if (errorObj) {
          try {
            if (!isString(errorObj)) {
              var errorType = _getErrorType(errorObj);
              var result = _stringify(errorObj, false);
              if (!result || result === "{}") {
                if (errorObj[strError]) {
                  errorObj = errorObj[strError];
                  errorType = _getErrorType(errorObj);
                }
                result = _stringify(errorObj, true);
              }
              if (strIndexOf(result, errorType) !== 0 && errorType !== "String") {
                return errorType + ":" + result;
              }
              return result;
            }
          } catch (e) {
          }
        }
        return "" + (errorObj || "");
      }
      var Exception = (
        /** @class */
        function() {
          function Exception2(logger2, exception, properties, measurements, severityLevel, id) {
            this.aiDataContract = {
              ver: 1,
              exceptions: 1,
              severityLevel: 0,
              properties: 0,
              measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            if (!_isExceptionInternal(exception)) {
              if (!properties) {
                properties = {};
              }
              if (id) {
                properties.id = id;
              }
              _self[_DYN_EXCEPTIONS] = [_createExceptionDetails(logger2, exception, properties)];
              _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
              _self[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(logger2, measurements);
              if (severityLevel) {
                _self[_DYN_SEVERITY_LEVEL] = severityLevel;
              }
              if (id) {
                _self.id = id;
              }
            } else {
              _self[_DYN_EXCEPTIONS] = exception[_DYN_EXCEPTIONS] || [];
              _self[_DYN_PROPERTIES] = exception[_DYN_PROPERTIES];
              _self[_DYN_MEASUREMENTS$1] = exception[_DYN_MEASUREMENTS$1];
              if (exception[_DYN_SEVERITY_LEVEL]) {
                _self[_DYN_SEVERITY_LEVEL] = exception[_DYN_SEVERITY_LEVEL];
              }
              if (exception.id) {
                _self.id = exception.id;
                exception[_DYN_PROPERTIES].id = exception.id;
              }
              if (exception[_DYN_PROBLEM_GROUP]) {
                _self[_DYN_PROBLEM_GROUP] = exception[_DYN_PROBLEM_GROUP];
              }
              if (!/* @__PURE__ */ isNullOrUndefined(exception.isManual)) {
                _self.isManual = exception.isManual;
              }
            }
          }
          Exception2.CreateAutoException = function(message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
            var errorType = _getErrorType(error || evt || message);
            return {
              message: _formatMessage(message, errorType),
              url,
              lineNumber,
              columnNumber,
              error: _formatErrorCode(error || evt || message),
              evt: _formatErrorCode(evt || message),
              typeName: errorType,
              stackDetails: _getStackFromErrorObj(stack || error || evt),
              errorSrc
            };
          };
          Exception2.CreateFromInterface = function(logger2, exception, properties, measurements) {
            var exceptions = exception[_DYN_EXCEPTIONS] && arrMap(exception[_DYN_EXCEPTIONS], function(ex) {
              return _createExDetailsFromInterface(logger2, ex);
            });
            var exceptionData = new Exception2(logger2, __assignFn(__assignFn({}, exception), { exceptions }), properties, measurements);
            return exceptionData;
          };
          Exception2.prototype.toInterface = function() {
            var _a2 = this, exceptions = _a2.exceptions, properties = _a2.properties, measurements = _a2.measurements, severityLevel = _a2.severityLevel, problemGroup = _a2.problemGroup, id = _a2.id, isManual = _a2.isManual;
            var exceptionDetailsInterface = exceptions instanceof Array && arrMap(exceptions, function(exception) {
              return exception.toInterface();
            }) || void 0;
            return {
              ver: "4.0",
              exceptions: exceptionDetailsInterface,
              severityLevel,
              properties,
              measurements,
              problemGroup,
              id,
              isManual
            };
          };
          Exception2.CreateSimpleException = function(message, typeName, assembly, fileName, details, line) {
            var _a2;
            return {
              exceptions: [
                (_a2 = {}, _a2[_DYN_HAS_FULL_STACK] = true, _a2.message = message, _a2.stack = details, _a2.typeName = typeName, _a2)
              ]
            };
          };
          Exception2.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
          Exception2.dataType = "ExceptionData";
          Exception2.formatError = _formatErrorCode;
          return Exception2;
        }()
      );
      var exDetailsAiDataContract = objFreeze({
        id: 0,
        outerId: 0,
        typeName: 1,
        message: 1,
        hasFullStack: 0,
        stack: 0,
        parsedStack: 2
      });
      function _toInterface() {
        var _self = this;
        var parsedStack = isArray(_self[_DYN_PARSED_STACK]) && arrMap(_self[_DYN_PARSED_STACK], function(frame) {
          return _parsedFrameToInterface(frame);
        });
        var exceptionDetailsInterface = {
          id: _self.id,
          outerId: _self.outerId,
          typeName: _self[_DYN_TYPE_NAME],
          message: _self[_DYN_MESSAGE],
          hasFullStack: _self[_DYN_HAS_FULL_STACK],
          stack: _self[strStack],
          parsedStack: parsedStack || void 0
        };
        return exceptionDetailsInterface;
      }
      function _createExceptionDetails(logger2, exception, properties) {
        var _a2;
        var id;
        var outerId;
        var typeName;
        var message;
        var hasFullStack;
        var theStack;
        var parsedStack;
        if (!_isExceptionDetailsInternal(exception)) {
          var error = exception;
          var evt = error && error.evt;
          if (!isError(error)) {
            error = error[strError] || evt || error;
          }
          typeName = dataSanitizeString(logger2, _getErrorType(error)) || strNotSpecified;
          message = dataSanitizeMessage(logger2, _formatMessage(exception || error, typeName)) || strNotSpecified;
          var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
          parsedStack = _parseStack(stack);
          if (isArray(parsedStack)) {
            arrMap(parsedStack, function(frame) {
              frame[_DYN_ASSEMBLY] = dataSanitizeString(logger2, frame[_DYN_ASSEMBLY]);
              frame[_DYN_FILE_NAME] = dataSanitizeString(logger2, frame[_DYN_FILE_NAME]);
            });
          }
          theStack = dataSanitizeException(logger2, _formatStackTrace(stack));
          hasFullStack = isArray(parsedStack) && parsedStack[_DYN_LENGTH$1] > 0;
          if (properties) {
            properties[_DYN_TYPE_NAME] = properties[_DYN_TYPE_NAME] || typeName;
          }
        } else {
          typeName = exception[_DYN_TYPE_NAME];
          message = exception[_DYN_MESSAGE];
          theStack = exception[strStack];
          parsedStack = exception[_DYN_PARSED_STACK] || [];
          hasFullStack = exception[_DYN_HAS_FULL_STACK];
        }
        return _a2 = {}, _a2[_DYN_AI_DATA_CONTRACT] = exDetailsAiDataContract, _a2.id = id, _a2.outerId = outerId, _a2.typeName = typeName, _a2.message = message, _a2[_DYN_HAS_FULL_STACK] = hasFullStack, _a2.stack = theStack, _a2.parsedStack = parsedStack, _a2.toInterface = _toInterface, _a2;
      }
      function _createExDetailsFromInterface(logger2, exception) {
        var parsedStack = isArray(exception[_DYN_PARSED_STACK]) && arrMap(exception[_DYN_PARSED_STACK], function(frame) {
          return _stackFrameFromInterface(frame);
        }) || exception[_DYN_PARSED_STACK];
        var exceptionDetails = _createExceptionDetails(logger2, __assignFn(__assignFn({}, exception), { parsedStack }));
        return exceptionDetails;
      }
      function _parseFilename(theFrame, fileName) {
        var lineCol = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_COL);
        if (lineCol && lineCol[_DYN_LENGTH$1] >= 4) {
          theFrame[_DYN_FILE_NAME] = lineCol[1];
          theFrame[_DYN_LINE] = parseInt(lineCol[2]);
        } else {
          var lineNo = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_ONLY);
          if (lineNo && lineNo[_DYN_LENGTH$1] >= 3) {
            theFrame[_DYN_FILE_NAME] = lineNo[1];
            theFrame[_DYN_LINE] = parseInt(lineNo[2]);
          } else {
            theFrame[_DYN_FILE_NAME] = fileName;
          }
        }
      }
      function _handleFilename(theFrame, sequence, matches) {
        var filename = theFrame[_DYN_FILE_NAME];
        if (sequence.fn && matches && matches[_DYN_LENGTH$1] > sequence.fn) {
          if (sequence.ln && matches[_DYN_LENGTH$1] > sequence.ln) {
            filename = strTrim(matches[sequence.fn] || "");
            theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0;
          } else {
            filename = strTrim(matches[sequence.fn] || "");
          }
        }
        if (filename) {
          _parseFilename(theFrame, filename);
        }
      }
      function _isStackFrame(frame) {
        var result = false;
        if (frame && isString(frame)) {
          var trimmedFrame = strTrim(frame);
          if (trimmedFrame) {
            result = IS_FRAME.test(trimmedFrame);
          }
        }
        return result;
      }
      var stackFrameAiDataContract = objFreeze({
        level: 1,
        method: 1,
        assembly: 0,
        fileName: 0,
        line: 0
      });
      function _extractStackFrame(frame, level) {
        var _a2;
        var theFrame;
        if (frame && isString(frame) && strTrim(frame)) {
          theFrame = (_a2 = {}, _a2[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a2.level = level, _a2.assembly = strTrim(frame), _a2.method = NoMethod, _a2.fileName = "", _a2.line = 0, _a2.sizeInBytes = 0, _a2);
          var idx = 0;
          while (idx < _parseSequence[_DYN_LENGTH$1]) {
            var sequence = _parseSequence[idx];
            if (sequence.chk && !sequence.chk(frame)) {
              break;
            }
            if (sequence.pre) {
              frame = sequence.pre(frame);
            }
            var matches = frame[_DYN_MATCH](sequence.re);
            if (matches && matches[_DYN_LENGTH$1] >= sequence.len) {
              if (sequence.m) {
                theFrame.method = strTrim(matches[sequence.m] || NoMethod);
              }
              if (sequence.hdl) {
                sequence.hdl(theFrame, sequence, matches);
              } else if (sequence.fn) {
                if (sequence.ln) {
                  theFrame[_DYN_FILE_NAME] = strTrim(matches[sequence.fn] || "");
                  theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0;
                } else {
                  _parseFilename(theFrame, matches[sequence.fn] || "");
                }
              }
              break;
            }
            idx++;
          }
        }
        return _populateFrameSizeInBytes(theFrame);
      }
      function _stackFrameFromInterface(frame) {
        var _a2;
        var parsedFrame = (_a2 = {}, _a2[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a2.level = frame.level, _a2.method = frame.method, _a2.assembly = frame[_DYN_ASSEMBLY], _a2.fileName = frame[_DYN_FILE_NAME], _a2.line = frame[_DYN_LINE], _a2.sizeInBytes = 0, _a2);
        return _populateFrameSizeInBytes(parsedFrame);
      }
      function _populateFrameSizeInBytes(frame) {
        var sizeInBytes = STACKFRAME_BASE_SIZE;
        if (frame) {
          sizeInBytes += frame.method[_DYN_LENGTH$1];
          sizeInBytes += frame.assembly[_DYN_LENGTH$1];
          sizeInBytes += frame.fileName[_DYN_LENGTH$1];
          sizeInBytes += frame.level.toString()[_DYN_LENGTH$1];
          sizeInBytes += frame.line.toString()[_DYN_LENGTH$1];
          frame[_DYN_SIZE_IN_BYTES] = sizeInBytes;
        }
        return frame;
      }
      function _parsedFrameToInterface(frame) {
        return {
          level: frame.level,
          method: frame.method,
          assembly: frame[_DYN_ASSEMBLY],
          fileName: frame[_DYN_FILE_NAME],
          line: frame[_DYN_LINE]
        };
      }
      var DataPoint = (
        /** @class */
        /* @__PURE__ */ function() {
          function DataPoint2() {
            this.aiDataContract = {
              name: 1,
              kind: 0,
              value: 1,
              count: 0,
              min: 0,
              max: 0,
              stdDev: 0
            };
            this.kind = 0;
          }
          return DataPoint2;
        }()
      );
      var Metric = (
        /** @class */
        function() {
          function Metric2(logger2, name, value, count, min, max, stdDev, properties, measurements) {
            this.aiDataContract = {
              ver: 1,
              metrics: 1,
              properties: 0
            };
            var _self = this;
            _self.ver = 2;
            var dataPoint = new DataPoint();
            dataPoint[_DYN_COUNT$1] = count > 0 ? count : void 0;
            dataPoint.max = isNaN(max) || max === null ? void 0 : max;
            dataPoint.min = isNaN(min) || min === null ? void 0 : min;
            dataPoint[_DYN_NAME$1] = dataSanitizeString(logger2, name) || strNotSpecified;
            dataPoint.value = value;
            dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? void 0 : stdDev;
            _self.metrics = [dataPoint];
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(logger2, measurements);
          }
          Metric2.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
          Metric2.dataType = "MetricData";
          return Metric2;
        }()
      );
      var strEmpty = "";
      function msToTimeSpan(totalms) {
        if (isNaN(totalms) || totalms < 0) {
          totalms = 0;
        }
        totalms = mathRound(totalms);
        var ms = strEmpty + totalms % 1e3;
        var sec = strEmpty + mathFloor(totalms / 1e3) % 60;
        var min = strEmpty + mathFloor(totalms / (1e3 * 60)) % 60;
        var hour = strEmpty + mathFloor(totalms / (1e3 * 60 * 60)) % 24;
        var days = mathFloor(totalms / (1e3 * 60 * 60 * 24));
        ms = ms[_DYN_LENGTH$1] === 1 ? "00" + ms : ms[_DYN_LENGTH$1] === 2 ? "0" + ms : ms;
        sec = sec[_DYN_LENGTH$1] < 2 ? "0" + sec : sec;
        min = min[_DYN_LENGTH$1] < 2 ? "0" + min : min;
        hour = hour[_DYN_LENGTH$1] < 2 ? "0" + hour : hour;
        return (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
      }
      var PageView = (
        /** @class */
        function() {
          function PageView2(logger2, name, url, durationMs, properties, measurements, id) {
            this.aiDataContract = {
              ver: 1,
              name: 0,
              url: 0,
              duration: 0,
              properties: 0,
              measurements: 0,
              id: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = dataSanitizeId(logger2, id);
            _self.url = dataSanitizeUrl(logger2, url);
            _self[_DYN_NAME$1] = dataSanitizeString(logger2, name) || strNotSpecified;
            if (!isNaN(durationMs)) {
              _self[_DYN_DURATION] = msToTimeSpan(durationMs);
            }
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(logger2, measurements);
          }
          PageView2.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
          PageView2.dataType = "PageviewData";
          return PageView2;
        }()
      );
      var RemoteDependencyData = (
        /** @class */
        function() {
          function RemoteDependencyData2(logger2, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
            if (requestAPI === void 0) {
              requestAPI = "Ajax";
            }
            this.aiDataContract = {
              id: 1,
              ver: 1,
              name: 0,
              resultCode: 0,
              duration: 0,
              success: 0,
              data: 0,
              target: 0,
              type: 0,
              properties: 0,
              measurements: 0,
              kind: 0,
              value: 0,
              count: 0,
              min: 0,
              max: 0,
              stdDev: 0,
              dependencyKind: 0,
              dependencySource: 0,
              commandName: 0,
              dependencyTypeName: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.id = id;
            _self[_DYN_DURATION] = msToTimeSpan(value);
            _self.success = success;
            _self.resultCode = resultCode + "";
            _self.type = dataSanitizeString(logger2, requestAPI);
            var dependencyFields = AjaxHelperParseDependencyPath(logger2, absoluteUrl, method, commandName);
            _self.data = dataSanitizeUrl(logger2, commandName) || dependencyFields.data;
            _self.target = dataSanitizeString(logger2, dependencyFields.target);
            if (correlationContext) {
              _self.target = "".concat(_self.target, " | ").concat(correlationContext);
            }
            _self[_DYN_NAME$1] = dataSanitizeString(logger2, dependencyFields[_DYN_NAME$1]);
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(logger2, measurements);
          }
          RemoteDependencyData2.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
          RemoteDependencyData2.dataType = "RemoteDependencyData";
          return RemoteDependencyData2;
        }()
      );
      var Trace = (
        /** @class */
        function() {
          function Trace2(logger2, message, severityLevel, properties, measurements) {
            this.aiDataContract = {
              ver: 1,
              message: 1,
              severityLevel: 0,
              properties: 0
            };
            var _self = this;
            _self.ver = 2;
            message = message || strNotSpecified;
            _self[_DYN_MESSAGE] = dataSanitizeMessage(logger2, message);
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(logger2, measurements);
            if (severityLevel) {
              _self[_DYN_SEVERITY_LEVEL] = severityLevel;
            }
          }
          Trace2.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
          Trace2.dataType = "MessageData";
          return Trace2;
        }()
      );
      var PageViewPerformance = (
        /** @class */
        function() {
          function PageViewPerformance2(logger2, name, url, unused, properties, measurements, cs4BaseData) {
            this.aiDataContract = {
              ver: 1,
              name: 0,
              url: 0,
              duration: 0,
              perfTotal: 0,
              networkConnect: 0,
              sentRequest: 0,
              receivedResponse: 0,
              domProcessing: 0,
              properties: 0,
              measurements: 0
            };
            var _self = this;
            _self.ver = 2;
            _self.url = dataSanitizeUrl(logger2, url);
            _self[_DYN_NAME$1] = dataSanitizeString(logger2, name) || strNotSpecified;
            _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger2, properties);
            _self[_DYN_MEASUREMENTS$1] = dataSanitizeMeasurements(logger2, measurements);
            if (cs4BaseData) {
              _self.domProcessing = cs4BaseData.domProcessing;
              _self[_DYN_DURATION] = cs4BaseData[_DYN_DURATION];
              _self.networkConnect = cs4BaseData.networkConnect;
              _self.perfTotal = cs4BaseData.perfTotal;
              _self.receivedResponse = cs4BaseData.receivedResponse;
              _self.sentRequest = cs4BaseData.sentRequest;
            }
          }
          PageViewPerformance2.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
          PageViewPerformance2.dataType = "PageviewPerformanceData";
          return PageViewPerformance2;
        }()
      );
      var Data = (
        /** @class */
        /* @__PURE__ */ function() {
          function Data2(baseType, data) {
            this.aiDataContract = {
              baseType: 1,
              baseData: 1
            };
            this.baseType = baseType;
            this.baseData = data;
          }
          return Data2;
        }()
      );
      var SeverityLevel = createEnumStyle({
        Verbose: 0,
        Information: 1,
        Warning: 2,
        Error: 3,
        Critical: 4
      });
      function _aiNameFunc(baseName) {
        var aiName = "ai." + baseName + ".";
        return function(name) {
          return aiName + name;
        };
      }
      var _aiApplication = _aiNameFunc("application");
      var _aiDevice = _aiNameFunc("device");
      var _aiLocation = _aiNameFunc("location");
      var _aiOperation = _aiNameFunc("operation");
      var _aiSession = _aiNameFunc("session");
      var _aiUser = _aiNameFunc("user");
      var _aiCloud = _aiNameFunc("cloud");
      var _aiInternal = _aiNameFunc("internal");
      var ContextTagKeys = (
        /** @class */
        function(_super) {
          __extendsFn(ContextTagKeys2, _super);
          function ContextTagKeys2() {
            return _super.call(this) || this;
          }
          return ContextTagKeys2;
        }(createClassFromInterface({
          applicationVersion: _aiApplication("ver"),
          applicationBuild: _aiApplication("build"),
          applicationTypeId: _aiApplication("typeId"),
          applicationId: _aiApplication("applicationId"),
          applicationLayer: _aiApplication("layer"),
          deviceId: _aiDevice("id"),
          deviceIp: _aiDevice("ip"),
          deviceLanguage: _aiDevice("language"),
          deviceLocale: _aiDevice("locale"),
          deviceModel: _aiDevice("model"),
          deviceFriendlyName: _aiDevice("friendlyName"),
          deviceNetwork: _aiDevice("network"),
          deviceNetworkName: _aiDevice("networkName"),
          deviceOEMName: _aiDevice("oemName"),
          deviceOS: _aiDevice("os"),
          deviceOSVersion: _aiDevice("osVersion"),
          deviceRoleInstance: _aiDevice("roleInstance"),
          deviceRoleName: _aiDevice("roleName"),
          deviceScreenResolution: _aiDevice("screenResolution"),
          deviceType: _aiDevice("type"),
          deviceMachineName: _aiDevice("machineName"),
          deviceVMName: _aiDevice("vmName"),
          deviceBrowser: _aiDevice("browser"),
          deviceBrowserVersion: _aiDevice("browserVersion"),
          locationIp: _aiLocation("ip"),
          locationCountry: _aiLocation("country"),
          locationProvince: _aiLocation("province"),
          locationCity: _aiLocation("city"),
          operationId: _aiOperation("id"),
          operationName: _aiOperation("name"),
          operationParentId: _aiOperation("parentId"),
          operationRootId: _aiOperation("rootId"),
          operationSyntheticSource: _aiOperation("syntheticSource"),
          operationCorrelationVector: _aiOperation("correlationVector"),
          sessionId: _aiSession("id"),
          sessionIsFirst: _aiSession("isFirst"),
          sessionIsNew: _aiSession("isNew"),
          userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
          userAccountId: _aiUser("accountId"),
          userAgent: _aiUser("userAgent"),
          userId: _aiUser("id"),
          userStoreRegion: _aiUser("storeRegion"),
          userAuthUserId: _aiUser("authUserId"),
          userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
          userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
          cloudName: _aiCloud("name"),
          cloudRole: _aiCloud("role"),
          cloudRoleVer: _aiCloud("roleVer"),
          cloudRoleInstance: _aiCloud("roleInstance"),
          cloudEnvironment: _aiCloud("environment"),
          cloudLocation: _aiCloud("location"),
          cloudDeploymentUnit: _aiCloud("deploymentUnit"),
          internalNodeName: _aiInternal("nodeName"),
          internalSdkVersion: _aiInternal("sdkVersion"),
          internalAgentVersion: _aiInternal("agentVersion"),
          internalSnippet: _aiInternal("snippet"),
          internalSdkSrc: _aiInternal("sdkSrc")
        }))
      );
      var CtxTagKeys = new ContextTagKeys();
      function _disableEvents(target, evtNamespace) {
        eventOff(target, null, null, evtNamespace);
      }
      function createOfflineListener(parentEvtNamespace) {
        var _document2 = getDocument();
        var _navigator = getNavigator();
        var _isListening = false;
        var listenerList = [];
        var rState = 1;
        if (_navigator && !/* @__PURE__ */ isNullOrUndefined(_navigator.onLine) && !_navigator.onLine) {
          rState = 2;
        }
        var uState = 0;
        var _currentState = calCurrentState();
        var _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
        try {
          if (_enableEvents(getWindow())) {
            _isListening = true;
          }
          if (_document2) {
            var target = _document2.body || _document2;
            if (target.ononline) {
              if (_enableEvents(target)) {
                _isListening = true;
              }
            }
          }
        } catch (e) {
          _isListening = false;
        }
        function _enableEvents(target2) {
          var enabled = false;
          if (target2) {
            enabled = eventOn(target2, "online", _setOnline, _evtNamespace);
            if (enabled) {
              eventOn(target2, "offline", _setOffline, _evtNamespace);
            }
          }
          return enabled;
        }
        function _isOnline() {
          return _currentState;
        }
        function calCurrentState() {
          if (uState === 2 || rState === 2) {
            return false;
          }
          return true;
        }
        function listnerNoticeCheck() {
          var newState = calCurrentState();
          if (_currentState !== newState) {
            _currentState = newState;
            arrForEach(listenerList, function(callback) {
              var offlineState = {
                isOnline: _currentState,
                rState,
                uState
              };
              try {
                callback(offlineState);
              } catch (e) {
              }
            });
          }
        }
        function setOnlineState(newState) {
          uState = newState;
          listnerNoticeCheck();
        }
        function _setOnline() {
          rState = 1;
          listnerNoticeCheck();
        }
        function _setOffline() {
          rState = 2;
          listnerNoticeCheck();
        }
        function _unload() {
          var win = getWindow();
          if (win && _isListening) {
            _disableEvents(win, _evtNamespace);
            if (_document2) {
              var target2 = _document2.body || _document2;
              if (!/* @__PURE__ */ isUndefined(target2.ononline)) {
                _disableEvents(target2, _evtNamespace);
              }
            }
            _isListening = false;
          }
        }
        function addListener(callback) {
          listenerList.push(callback);
          return {
            rm: function() {
              var index = listenerList.indexOf(callback);
              if (index > -1) {
                return listenerList.splice(index, 1);
              } else {
                return;
              }
            }
          };
        }
        return {
          isOnline: _isOnline,
          isListening: function() {
            return _isListening;
          },
          unload: _unload,
          addListener,
          setOnlineState
        };
      }
      var BreezeChannelIdentifier = "AppInsightsChannelPlugin";
      var STR_DURATION = "duration";
      var _DYN_TAGS = "tags";
      var _DYN_DEVICE_TYPE = "deviceType";
      var _DYN_DATA = "data";
      var _DYN_NAME = "name";
      var _DYN_TRACE_ID = "traceID";
      var _DYN_LENGTH = "length";
      var _DYN_STRINGIFY = "stringify";
      var _DYN_MEASUREMENTS = "measurements";
      var _DYN_DATA_TYPE = "dataType";
      var _DYN_ENVELOPE_TYPE = "envelopeType";
      var _DYN_TO_STRING = "toString";
      var _DYN_ENQUEUE = "enqueue";
      var _DYN_COUNT = "count";
      var _DYN_PUSH = "push";
      var _DYN_EMIT_LINE_DELIMITED_0 = "emitLineDelimitedJson";
      var _DYN_CLEAR = "clear";
      var _DYN_MARK_AS_SENT = "markAsSent";
      var _DYN_CLEAR_SENT = "clearSent";
      var _DYN_BUFFER_OVERRIDE = "bufferOverride";
      var _DYN__BUFFER__KEY = "BUFFER_KEY";
      var _DYN__SENT__BUFFER__KEY = "SENT_BUFFER_KEY";
      var _DYN_CONCAT = "concat";
      var _DYN__MAX__BUFFER__SIZE = "MAX_BUFFER_SIZE";
      var _DYN_TRIGGER_SEND = "triggerSend";
      var _DYN_DIAG_LOG = "diagLog";
      var _DYN_INITIALIZE = "initialize";
      var _DYN__SENDER = "_sender";
      var _DYN_ENDPOINT_URL$1 = "endpointUrl";
      var _DYN_INSTRUMENTATION_KEY$1 = "instrumentationKey";
      var _DYN_CUSTOM_HEADERS = "customHeaders";
      var _DYN_MAX_BATCH_SIZE_IN_BY1 = "maxBatchSizeInBytes";
      var _DYN_ONUNLOAD_DISABLE_BEA2 = "onunloadDisableBeacon";
      var _DYN_IS_BEACON_API_DISABL3 = "isBeaconApiDisabled";
      var _DYN_ALWAYS_USE_XHR_OVERR4 = "alwaysUseXhrOverride";
      var _DYN_ENABLE_SESSION_STORA5 = "enableSessionStorageBuffer";
      var _DYN__BUFFER = "_buffer";
      var _DYN_ONUNLOAD_DISABLE_FET6 = "onunloadDisableFetch";
      var _DYN_DISABLE_SEND_BEACON_7 = "disableSendBeaconSplit";
      var _DYN_GET_SENDER_INST = "getSenderInst";
      var _DYN__ON_ERROR = "_onError";
      var _DYN__ON_PARTIAL_SUCCESS = "_onPartialSuccess";
      var _DYN__ON_SUCCESS = "_onSuccess";
      var _DYN_ITEMS_RECEIVED = "itemsReceived";
      var _DYN_ITEMS_ACCEPTED = "itemsAccepted";
      var _DYN_BASE_TYPE = "baseType";
      var _DYN_SAMPLE_RATE = "sampleRate";
      var _DYN_GET_HASH_CODE_SCORE = "getHashCodeScore";
      var strBaseType = "baseType";
      var strBaseData = "baseData";
      var strProperties = "properties";
      var strTrue = "true";
      function _setValueIf(target, field, value) {
        return setValue(target, field, value, isTruthy);
      }
      function _extractPartAExtensions(logger2, item, env2) {
        var envTags = env2[_DYN_TAGS] = env2[_DYN_TAGS] || {};
        var itmExt = item.ext = item.ext || {};
        var itmTags = item[_DYN_TAGS] = item[_DYN_TAGS] || [];
        var extUser = itmExt.user;
        if (extUser) {
          _setValueIf(envTags, CtxTagKeys.userAuthUserId, extUser.authId);
          _setValueIf(envTags, CtxTagKeys.userId, extUser.id || extUser.localId);
        }
        var extApp = itmExt.app;
        if (extApp) {
          _setValueIf(envTags, CtxTagKeys.sessionId, extApp.sesId);
        }
        var extDevice = itmExt.device;
        if (extDevice) {
          _setValueIf(envTags, CtxTagKeys.deviceId, extDevice.id || extDevice.localId);
          _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE], extDevice.deviceClass);
          _setValueIf(envTags, CtxTagKeys.deviceIp, extDevice.ip);
          _setValueIf(envTags, CtxTagKeys.deviceModel, extDevice.model);
          _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE], extDevice[_DYN_DEVICE_TYPE]);
        }
        var web = item.ext.web;
        if (web) {
          _setValueIf(envTags, CtxTagKeys.deviceLanguage, web.browserLang);
          _setValueIf(envTags, CtxTagKeys.deviceBrowserVersion, web.browserVer);
          _setValueIf(envTags, CtxTagKeys.deviceBrowser, web.browser);
          var envData = env2[_DYN_DATA] = env2[_DYN_DATA] || {};
          var envBaseData = envData[strBaseData] = envData[strBaseData] || {};
          var envProps = envBaseData[strProperties] = envBaseData[strProperties] || {};
          _setValueIf(envProps, "domain", web.domain);
          _setValueIf(envProps, "isManual", web.isManual ? strTrue : null);
          _setValueIf(envProps, "screenRes", web.screenRes);
          _setValueIf(envProps, "userConsent", web.userConsent ? strTrue : null);
        }
        var extOs = itmExt.os;
        if (extOs) {
          _setValueIf(envTags, CtxTagKeys.deviceOS, extOs[_DYN_NAME]);
          _setValueIf(envTags, CtxTagKeys.deviceOSVersion, extOs.osVer);
        }
        var extTrace = itmExt.trace;
        if (extTrace) {
          _setValueIf(envTags, CtxTagKeys.operationParentId, extTrace.parentID);
          _setValueIf(envTags, CtxTagKeys.operationName, dataSanitizeString(logger2, extTrace[_DYN_NAME]));
          _setValueIf(envTags, CtxTagKeys.operationId, extTrace[_DYN_TRACE_ID]);
        }
        var tgs = {};
        for (var i = itmTags[_DYN_LENGTH] - 1; i >= 0; i--) {
          var tg = itmTags[i];
          objForEachKey(tg, function(key, value) {
            tgs[key] = value;
          });
          itmTags.splice(i, 1);
        }
        objForEachKey(itmTags, function(tg2, value) {
          tgs[tg2] = value;
        });
        var theTags = __assignFn(__assignFn({}, envTags), tgs);
        if (!theTags[CtxTagKeys.internalSdkVersion]) {
          theTags[CtxTagKeys.internalSdkVersion] = dataSanitizeString(logger2, "javascript:".concat(EnvelopeCreator.Version), 64);
        }
        env2[_DYN_TAGS] = optimizeObject(theTags);
      }
      function _extractPropsAndMeasurements(data, properties, measurements) {
        if (!/* @__PURE__ */ isNullOrUndefined(data)) {
          objForEachKey(data, function(key, value) {
            if (isNumber(value)) {
              measurements[key] = value;
            } else if (isString(value)) {
              properties[key] = value;
            } else if (hasJSON()) {
              properties[key] = getJSON()[_DYN_STRINGIFY](value);
            }
          });
        }
      }
      function _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue) {
        if (!/* @__PURE__ */ isNullOrUndefined(properties)) {
          objForEachKey(properties, function(key, value) {
            properties[key] = value || customUndefinedValue;
          });
        }
      }
      function _createEnvelope(logger2, envelopeType, telemetryItem, data) {
        var envelope = new Envelope(logger2, data, envelopeType);
        _setValueIf(envelope, "sampleRate", telemetryItem[SampleRate]);
        if ((telemetryItem[strBaseData] || {}).startTime) {
          envelope.time = toISOString(telemetryItem[strBaseData].startTime);
        }
        envelope.iKey = telemetryItem.iKey;
        var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
        envelope[_DYN_NAME] = envelope[_DYN_NAME].replace("{0}", iKeyNoDashes);
        _extractPartAExtensions(logger2, telemetryItem, envelope);
        telemetryItem[_DYN_TAGS] = telemetryItem[_DYN_TAGS] || [];
        return optimizeObject(envelope);
      }
      function EnvelopeCreatorInit(logger2, telemetryItem) {
        if (/* @__PURE__ */ isNullOrUndefined(telemetryItem[strBaseData])) {
          _throwInternal(logger2, 1, 46, "telemetryItem.baseData cannot be null.");
        }
      }
      var EnvelopeCreator = {
        Version: "3.3.7"
      };
      function DependencyEnvelopeCreator(logger2, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger2, telemetryItem);
        var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {};
        var customProperties = telemetryItem[strBaseData][strProperties] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements);
        if (!/* @__PURE__ */ isNullOrUndefined(customUndefinedValue)) {
          _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
        }
        var bd = telemetryItem[strBaseData];
        if (/* @__PURE__ */ isNullOrUndefined(bd)) {
          _warnToConsole(logger2, "Invalid input for dependency data");
          return null;
        }
        var method = bd[strProperties] && bd[strProperties][HttpMethod] ? bd[strProperties][HttpMethod] : "GET";
        var remoteDepData = new RemoteDependencyData(logger2, bd.id, bd.target, bd[_DYN_NAME], bd[STR_DURATION], bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements);
        var data = new Data(RemoteDependencyData[_DYN_DATA_TYPE], remoteDepData);
        return _createEnvelope(logger2, RemoteDependencyData[_DYN_ENVELOPE_TYPE], telemetryItem, data);
      }
      function EventEnvelopeCreator(logger2, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger2, telemetryItem);
        var customProperties = {};
        var customMeasurements = {};
        if (telemetryItem[strBaseType] !== Event$1[_DYN_DATA_TYPE]) {
          customProperties["baseTypeSource"] = telemetryItem[strBaseType];
        }
        if (telemetryItem[strBaseType] === Event$1[_DYN_DATA_TYPE]) {
          customProperties = telemetryItem[strBaseData][strProperties] || {};
          customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {};
        } else {
          if (telemetryItem[strBaseData]) {
            _extractPropsAndMeasurements(telemetryItem[strBaseData], customProperties, customMeasurements);
          }
        }
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements);
        if (!/* @__PURE__ */ isNullOrUndefined(customUndefinedValue)) {
          _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
        }
        var eventName = telemetryItem[strBaseData][_DYN_NAME];
        var eventData = new Event$1(logger2, eventName, customProperties, customMeasurements);
        var data = new Data(Event$1[_DYN_DATA_TYPE], eventData);
        return _createEnvelope(logger2, Event$1[_DYN_ENVELOPE_TYPE], telemetryItem, data);
      }
      function ExceptionEnvelopeCreator(logger2, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger2, telemetryItem);
        var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {};
        var customProperties = telemetryItem[strBaseData][strProperties] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements);
        if (!/* @__PURE__ */ isNullOrUndefined(customUndefinedValue)) {
          _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
        }
        var bd = telemetryItem[strBaseData];
        var exData = Exception.CreateFromInterface(logger2, bd, customProperties, customMeasurements);
        var data = new Data(Exception[_DYN_DATA_TYPE], exData);
        return _createEnvelope(logger2, Exception[_DYN_ENVELOPE_TYPE], telemetryItem, data);
      }
      function MetricEnvelopeCreator(logger2, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger2, telemetryItem);
        var baseData = telemetryItem[strBaseData];
        var props = baseData[strProperties] || {};
        var measurements = baseData[_DYN_MEASUREMENTS] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], props, measurements);
        if (!/* @__PURE__ */ isNullOrUndefined(customUndefinedValue)) {
          _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
        }
        var baseMetricData = new Metric(logger2, baseData[_DYN_NAME], baseData.average, baseData.sampleCount, baseData.min, baseData.max, baseData.stdDev, props, measurements);
        var data = new Data(Metric[_DYN_DATA_TYPE], baseMetricData);
        return _createEnvelope(logger2, Metric[_DYN_ENVELOPE_TYPE], telemetryItem, data);
      }
      function PageViewEnvelopeCreator(logger2, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger2, telemetryItem);
        var duration;
        var baseData = telemetryItem[strBaseData];
        if (!/* @__PURE__ */ isNullOrUndefined(baseData) && !/* @__PURE__ */ isNullOrUndefined(baseData[strProperties]) && !/* @__PURE__ */ isNullOrUndefined(baseData[strProperties][STR_DURATION])) {
          duration = baseData[strProperties][STR_DURATION];
          delete baseData[strProperties][STR_DURATION];
        } else if (!/* @__PURE__ */ isNullOrUndefined(telemetryItem[_DYN_DATA]) && !/* @__PURE__ */ isNullOrUndefined(telemetryItem[_DYN_DATA][STR_DURATION])) {
          duration = telemetryItem[_DYN_DATA][STR_DURATION];
          delete telemetryItem[_DYN_DATA][STR_DURATION];
        }
        var bd = telemetryItem[strBaseData];
        var currentContextId;
        if (((telemetryItem.ext || {}).trace || {})[_DYN_TRACE_ID]) {
          currentContextId = telemetryItem.ext.trace[_DYN_TRACE_ID];
        }
        var id = bd.id || currentContextId;
        var name = bd[_DYN_NAME];
        var url = bd.uri;
        var properties = bd[strProperties] || {};
        var measurements = bd[_DYN_MEASUREMENTS] || {};
        if (!/* @__PURE__ */ isNullOrUndefined(bd.refUri)) {
          properties["refUri"] = bd.refUri;
        }
        if (!/* @__PURE__ */ isNullOrUndefined(bd.pageType)) {
          properties["pageType"] = bd.pageType;
        }
        if (!/* @__PURE__ */ isNullOrUndefined(bd.isLoggedIn)) {
          properties["isLoggedIn"] = bd.isLoggedIn[_DYN_TO_STRING]();
        }
        if (!/* @__PURE__ */ isNullOrUndefined(bd[strProperties])) {
          var pageTags = bd[strProperties];
          objForEachKey(pageTags, function(key, value) {
            properties[key] = value;
          });
        }
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], properties, measurements);
        if (!/* @__PURE__ */ isNullOrUndefined(customUndefinedValue)) {
          _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
        }
        var pageViewData = new PageView(logger2, name, url, duration, properties, measurements, id);
        var data = new Data(PageView[_DYN_DATA_TYPE], pageViewData);
        return _createEnvelope(logger2, PageView[_DYN_ENVELOPE_TYPE], telemetryItem, data);
      }
      function PageViewPerformanceEnvelopeCreator(logger2, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger2, telemetryItem);
        var bd = telemetryItem[strBaseData];
        var name = bd[_DYN_NAME];
        var url = bd.uri || bd.url;
        var properties = bd[strProperties] || {};
        var measurements = bd[_DYN_MEASUREMENTS] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], properties, measurements);
        if (!/* @__PURE__ */ isNullOrUndefined(customUndefinedValue)) {
          _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
        }
        var baseData = new PageViewPerformance(logger2, name, url, void 0, properties, measurements, bd);
        var data = new Data(PageViewPerformance[_DYN_DATA_TYPE], baseData);
        return _createEnvelope(logger2, PageViewPerformance[_DYN_ENVELOPE_TYPE], telemetryItem, data);
      }
      function TraceEnvelopeCreator(logger2, telemetryItem, customUndefinedValue) {
        EnvelopeCreatorInit(logger2, telemetryItem);
        var message = telemetryItem[strBaseData].message;
        var severityLevel = telemetryItem[strBaseData].severityLevel;
        var props = telemetryItem[strBaseData][strProperties] || {};
        var measurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {};
        _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], props, measurements);
        if (!/* @__PURE__ */ isNullOrUndefined(customUndefinedValue)) {
          _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
        }
        var baseData = new Trace(logger2, message, severityLevel, props, measurements);
        var data = new Data(Trace[_DYN_DATA_TYPE], baseData);
        return _createEnvelope(logger2, Trace[_DYN_ENVELOPE_TYPE], telemetryItem, data);
      }
      var BaseSendBuffer = (
        /** @class */
        function() {
          function BaseSendBuffer2(logger2, config) {
            var _buffer = [];
            var _bufferFullMessageSent = false;
            var _maxRetryCnt = config.maxRetryCnt;
            this._get = function() {
              return _buffer;
            };
            this._set = function(buffer) {
              _buffer = buffer;
              return _buffer;
            };
            dynamicProto(BaseSendBuffer2, this, function(_self) {
              _self[_DYN_ENQUEUE] = function(payload) {
                if (_self[_DYN_COUNT]() >= config.eventsLimitInMem) {
                  if (!_bufferFullMessageSent) {
                    _throwInternal(logger2, 2, 105, "Maximum in-memory buffer size reached: " + _self[_DYN_COUNT](), true);
                    _bufferFullMessageSent = true;
                  }
                  return;
                }
                payload.cnt = payload.cnt || 0;
                if (!/* @__PURE__ */ isNullOrUndefined(_maxRetryCnt)) {
                  if (payload.cnt > _maxRetryCnt) {
                    return;
                  }
                }
                _buffer[_DYN_PUSH](payload);
                return;
              };
              _self[_DYN_COUNT] = function() {
                return _buffer[_DYN_LENGTH];
              };
              _self.size = function() {
                var size = _buffer[_DYN_LENGTH];
                for (var lp = 0; lp < _buffer[_DYN_LENGTH]; lp++) {
                  size += _buffer[lp].item[_DYN_LENGTH];
                }
                if (!config[_DYN_EMIT_LINE_DELIMITED_0]) {
                  size += 2;
                }
                return size;
              };
              _self[_DYN_CLEAR] = function() {
                _buffer = [];
                _bufferFullMessageSent = false;
              };
              _self.getItems = function() {
                return _buffer.slice(0);
              };
              _self.batchPayloads = function(payloads) {
                if (payloads && payloads[_DYN_LENGTH] > 0) {
                  var payloadStr_1 = [];
                  arrForEach(payloads, function(payload) {
                    payloadStr_1[_DYN_PUSH](payload.item);
                  });
                  var batch = config[_DYN_EMIT_LINE_DELIMITED_0] ? payloadStr_1.join("\n") : "[" + payloadStr_1.join(",") + "]";
                  return batch;
                }
                return null;
              };
              _self.createNew = function(newLogger, newConfig, canUseSessionStorage) {
                var items = _buffer.slice(0);
                newLogger = newLogger || logger2;
                newConfig = newConfig || {};
                var newBuffer = !!canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                arrForEach(items, function(payload) {
                  newBuffer[_DYN_ENQUEUE](payload);
                });
                return newBuffer;
              };
            });
          }
          BaseSendBuffer2.__ieDyn = 1;
          return BaseSendBuffer2;
        }()
      );
      var ArraySendBuffer = (
        /** @class */
        function(_super) {
          __extendsFn(ArraySendBuffer2, _super);
          function ArraySendBuffer2(logger2, config) {
            var _this = _super.call(this, logger2, config) || this;
            dynamicProto(ArraySendBuffer2, _this, function(_self, _base) {
              _self[_DYN_MARK_AS_SENT] = function(payload) {
                _base[_DYN_CLEAR]();
              };
              _self[_DYN_CLEAR_SENT] = function(payload) {
              };
            });
            return _this;
          }
          ArraySendBuffer2.__ieDyn = 1;
          return ArraySendBuffer2;
        }(BaseSendBuffer)
      );
      var PREVIOUS_KEYS = ["AI_buffer", "AI_sentBuffer"];
      var SessionStorageSendBuffer = (
        /** @class */
        function(_super) {
          __extendsFn(SessionStorageSendBuffer2, _super);
          function SessionStorageSendBuffer2(logger2, config) {
            var _this = _super.call(this, logger2, config) || this;
            var _bufferFullMessageSent = false;
            var _namePrefix = config === null || config === void 0 ? void 0 : config.namePrefix;
            var _b2 = config[_DYN_BUFFER_OVERRIDE] || { getItem: utlGetSessionStorage, setItem: utlSetSessionStorage }, getItem = _b2.getItem, setItem = _b2.setItem;
            var _maxRetryCnt = config.maxRetryCnt;
            dynamicProto(SessionStorageSendBuffer2, _this, function(_self, _base) {
              var bufferItems = _getBuffer(SessionStorageSendBuffer2[_DYN__BUFFER__KEY]);
              var itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY]);
              var previousItems = _getPreviousEvents();
              var notDeliveredItems = itemsInSentBuffer[_DYN_CONCAT](previousItems);
              var buffer = _self._set(bufferItems[_DYN_CONCAT](notDeliveredItems));
              if (buffer[_DYN_LENGTH] > SessionStorageSendBuffer2[_DYN__MAX__BUFFER__SIZE]) {
                buffer[_DYN_LENGTH] = SessionStorageSendBuffer2[_DYN__MAX__BUFFER__SIZE];
              }
              _setBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY], []);
              _setBuffer(SessionStorageSendBuffer2[_DYN__BUFFER__KEY], buffer);
              _self[_DYN_ENQUEUE] = function(payload) {
                if (_self[_DYN_COUNT]() >= SessionStorageSendBuffer2[_DYN__MAX__BUFFER__SIZE]) {
                  if (!_bufferFullMessageSent) {
                    _throwInternal(logger2, 2, 67, "Maximum buffer size reached: " + _self[_DYN_COUNT](), true);
                    _bufferFullMessageSent = true;
                  }
                  return;
                }
                payload.cnt = payload.cnt || 0;
                if (!/* @__PURE__ */ isNullOrUndefined(_maxRetryCnt)) {
                  if (payload.cnt > _maxRetryCnt) {
                    return;
                  }
                }
                _base[_DYN_ENQUEUE](payload);
                _setBuffer(SessionStorageSendBuffer2[_DYN__BUFFER__KEY], _self._get());
              };
              _self[_DYN_CLEAR] = function() {
                _base[_DYN_CLEAR]();
                _setBuffer(SessionStorageSendBuffer2[_DYN__BUFFER__KEY], _self._get());
                _setBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY], []);
                _bufferFullMessageSent = false;
              };
              _self[_DYN_MARK_AS_SENT] = function(payload) {
                _setBuffer(SessionStorageSendBuffer2[_DYN__BUFFER__KEY], _self._set(_removePayloadsFromBuffer(payload, _self._get())));
                var sentElements = _getBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY]);
                if (sentElements instanceof Array && payload instanceof Array) {
                  sentElements = sentElements[_DYN_CONCAT](payload);
                  if (sentElements[_DYN_LENGTH] > SessionStorageSendBuffer2[_DYN__MAX__BUFFER__SIZE]) {
                    _throwInternal(logger2, 1, 67, "Sent buffer reached its maximum size: " + sentElements[_DYN_LENGTH], true);
                    sentElements[_DYN_LENGTH] = SessionStorageSendBuffer2[_DYN__MAX__BUFFER__SIZE];
                  }
                  _setBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY], sentElements);
                }
              };
              _self[_DYN_CLEAR_SENT] = function(payload) {
                var sentElements = _getBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY]);
                sentElements = _removePayloadsFromBuffer(payload, sentElements);
                _setBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY], sentElements);
              };
              _self.createNew = function(newLogger, newConfig, canUseSessionStorage) {
                canUseSessionStorage = !!canUseSessionStorage;
                var unsentItems = _self._get().slice(0);
                var sentItems = _getBuffer(SessionStorageSendBuffer2[_DYN__SENT__BUFFER__KEY]).slice(0);
                newLogger = newLogger || logger2;
                newConfig = newConfig || {};
                _self[_DYN_CLEAR]();
                var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer2(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                arrForEach(unsentItems, function(payload) {
                  newBuffer[_DYN_ENQUEUE](payload);
                });
                if (canUseSessionStorage) {
                  newBuffer[_DYN_MARK_AS_SENT](sentItems);
                }
                return newBuffer;
              };
              function _removePayloadsFromBuffer(payloads, buffer2) {
                var remaining = [];
                var payloadStr = [];
                arrForEach(payloads, function(payload) {
                  payloadStr[_DYN_PUSH](payload.item);
                });
                arrForEach(buffer2, function(value) {
                  if (!isFunction(value) && arrIndexOf(payloadStr, value.item) === -1) {
                    remaining[_DYN_PUSH](value);
                  }
                });
                return remaining;
              }
              function _getBuffer(key) {
                var prefixedKey = key;
                prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                return _getBufferBase(prefixedKey);
              }
              function _getBufferBase(key) {
                try {
                  var bufferJson = getItem(logger2, key);
                  if (bufferJson) {
                    var buffer_1 = getJSON().parse(bufferJson);
                    if (isString(buffer_1)) {
                      buffer_1 = getJSON().parse(buffer_1);
                    }
                    if (buffer_1 && isArray(buffer_1)) {
                      return buffer_1;
                    }
                  }
                } catch (e) {
                  _throwInternal(logger2, 1, 42, " storage key: " + key + ", " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
                }
                return [];
              }
              function _setBuffer(key, buffer2) {
                var prefixedKey = key;
                try {
                  prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                  var bufferJson = JSON[_DYN_STRINGIFY](buffer2);
                  setItem(logger2, prefixedKey, bufferJson);
                } catch (e) {
                  setItem(logger2, prefixedKey, JSON[_DYN_STRINGIFY]([]));
                  _throwInternal(logger2, 2, 41, " storage key: " + prefixedKey + ", " + getExceptionName(e) + ". Buffer cleared", { exception: /* @__PURE__ */ dumpObj(e) });
                }
              }
              function _getPreviousEvents() {
                var items = [];
                try {
                  arrForEach(PREVIOUS_KEYS, function(key) {
                    var events = _getItemsFromPreviousKey(key);
                    items = items[_DYN_CONCAT](events);
                    if (_namePrefix) {
                      var prefixedKey = _namePrefix + "_" + key;
                      var prefixEvents = _getItemsFromPreviousKey(prefixedKey);
                      items = items[_DYN_CONCAT](prefixEvents);
                    }
                  });
                  return items;
                } catch (e) {
                  _throwInternal(logger2, 2, 41, "Transfer events from previous buffers: " + getExceptionName(e) + ". previous Buffer items can not be removed", { exception: /* @__PURE__ */ dumpObj(e) });
                }
                return [];
              }
              function _getItemsFromPreviousKey(key) {
                try {
                  var items = _getBufferBase(key);
                  var transFormedItems_1 = [];
                  arrForEach(items, function(item) {
                    var internalItem = {
                      item,
                      cnt: 0
                    };
                    transFormedItems_1[_DYN_PUSH](internalItem);
                  });
                  utlRemoveSessionStorage(logger2, key);
                  return transFormedItems_1;
                } catch (e) {
                }
                return [];
              }
            });
            return _this;
          }
          var _a2;
          _a2 = SessionStorageSendBuffer2;
          SessionStorageSendBuffer2.VERSION = "_1";
          SessionStorageSendBuffer2.BUFFER_KEY = "AI_buffer" + _a2.VERSION;
          SessionStorageSendBuffer2.SENT_BUFFER_KEY = "AI_sentBuffer" + _a2.VERSION;
          SessionStorageSendBuffer2.MAX_BUFFER_SIZE = 2e3;
          return SessionStorageSendBuffer2;
        }(BaseSendBuffer)
      );
      var Serializer = (
        /** @class */
        function() {
          function Serializer2(logger2) {
            dynamicProto(Serializer2, this, function(_self) {
              _self.serialize = function(input) {
                var output = _serializeObject(input, "root");
                try {
                  return getJSON()[_DYN_STRINGIFY](output);
                } catch (e) {
                  _throwInternal(logger2, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, true);
                }
              };
              function _serializeObject(source, name) {
                var circularReferenceCheck = "__aiCircularRefCheck";
                var output = {};
                if (!source) {
                  _throwInternal(logger2, 1, 48, "cannot serialize object because it is null or undefined", { name }, true);
                  return output;
                }
                if (source[circularReferenceCheck]) {
                  _throwInternal(logger2, 2, 50, "Circular reference detected while serializing object", { name }, true);
                  return output;
                }
                if (!source.aiDataContract) {
                  if (name === "measurements") {
                    output = _serializeStringMap(source, "number", name);
                  } else if (name === "properties") {
                    output = _serializeStringMap(source, "string", name);
                  } else if (name === "tags") {
                    output = _serializeStringMap(source, "string", name);
                  } else if (isArray(source)) {
                    output = _serializeArray(source, name);
                  } else {
                    _throwInternal(logger2, 2, 49, "Attempting to serialize an object which does not implement ISerializable", { name }, true);
                    try {
                      getJSON()[_DYN_STRINGIFY](source);
                      output = source;
                    } catch (e) {
                      _throwInternal(logger2, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, true);
                    }
                  }
                  return output;
                }
                source[circularReferenceCheck] = true;
                objForEachKey(source.aiDataContract, function(field, contract) {
                  var isRequired = isFunction(contract) ? contract() & 1 : contract & 1;
                  var isHidden = isFunction(contract) ? contract() & 4 : contract & 4;
                  var isArray2 = contract & 2;
                  var isPresent = source[field] !== void 0;
                  var isObj = /* @__PURE__ */ isObject(source[field]) && source[field] !== null;
                  if (isRequired && !isPresent && !isArray2) {
                    _throwInternal(logger2, 1, 24, "Missing required field specification. The field is required but not present on source", { field, name });
                  } else if (!isHidden) {
                    var value = void 0;
                    if (isObj) {
                      if (isArray2) {
                        value = _serializeArray(source[field], field);
                      } else {
                        value = _serializeObject(source[field], field);
                      }
                    } else {
                      value = source[field];
                    }
                    if (value !== void 0) {
                      output[field] = value;
                    }
                  }
                });
                delete source[circularReferenceCheck];
                return output;
              }
              function _serializeArray(sources, name) {
                var output;
                if (!!sources) {
                  if (!isArray(sources)) {
                    _throwInternal(logger2, 1, 54, "This field was specified as an array in the contract but the item is not an array.\r\n", { name }, true);
                  } else {
                    output = [];
                    for (var i = 0; i < sources[_DYN_LENGTH]; i++) {
                      var source = sources[i];
                      var item = _serializeObject(source, name + "[" + i + "]");
                      output[_DYN_PUSH](item);
                    }
                  }
                }
                return output;
              }
              function _serializeStringMap(map, expectedType, name) {
                var output;
                if (map) {
                  output = {};
                  objForEachKey(map, function(field, value) {
                    if (expectedType === "string") {
                      if (value === void 0) {
                        output[field] = "undefined";
                      } else if (value === null) {
                        output[field] = "null";
                      } else if (!value[_DYN_TO_STRING]) {
                        output[field] = "invalid field: toString() is not defined.";
                      } else {
                        output[field] = value[_DYN_TO_STRING]();
                      }
                    } else if (expectedType === "number") {
                      if (value === void 0) {
                        output[field] = "undefined";
                      } else if (value === null) {
                        output[field] = "null";
                      } else {
                        var num = parseFloat(value);
                        output[field] = num;
                      }
                    } else {
                      output[field] = "invalid field: " + name + " is of unknown type.";
                      _throwInternal(logger2, 1, output[field], null, true);
                    }
                  });
                }
                return output;
              }
            });
          }
          Serializer2.__ieDyn = 1;
          return Serializer2;
        }()
      );
      var MIN_INPUT_LENGTH = 8;
      var HashCodeScoreGenerator = (
        /** @class */
        function() {
          function HashCodeScoreGenerator2() {
          }
          HashCodeScoreGenerator2.prototype.getHashCodeScore = function(key) {
            var score = this.getHashCode(key) / HashCodeScoreGenerator2.INT_MAX_VALUE;
            return score * 100;
          };
          HashCodeScoreGenerator2.prototype.getHashCode = function(input) {
            if (input === "") {
              return 0;
            }
            while (input[_DYN_LENGTH] < MIN_INPUT_LENGTH) {
              input = input[_DYN_CONCAT](input);
            }
            var hash = 5381;
            for (var i = 0; i < input[_DYN_LENGTH]; ++i) {
              hash = (hash << 5) + hash + input.charCodeAt(i);
              hash = hash & hash;
            }
            return Math.abs(hash);
          };
          HashCodeScoreGenerator2.INT_MAX_VALUE = 2147483647;
          return HashCodeScoreGenerator2;
        }()
      );
      var SamplingScoreGenerator = (
        /** @class */
        /* @__PURE__ */ function() {
          function SamplingScoreGenerator2() {
            var _self = this;
            var hashCodeGenerator = new HashCodeScoreGenerator();
            var keys = new ContextTagKeys();
            _self.getSamplingScore = function(item) {
              var score = 0;
              if (item[_DYN_TAGS] && item[_DYN_TAGS][keys.userId]) {
                score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS][keys.userId]);
              } else if (item.ext && item.ext.user && item.ext.user.id) {
                score = hashCodeGenerator[_DYN_GET_HASH_CODE_SCORE](item.ext.user.id);
              } else if (item[_DYN_TAGS] && item[_DYN_TAGS][keys.operationId]) {
                score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS][keys.operationId]);
              } else if (item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace[_DYN_TRACE_ID]) {
                score = hashCodeGenerator.getHashCodeScore(item.ext.telemetryTrace[_DYN_TRACE_ID]);
              } else {
                score = Math.random() * 100;
              }
              return score;
            };
          }
          return SamplingScoreGenerator2;
        }()
      );
      var Sample = (
        /** @class */
        function() {
          function Sample2(sampleRate, logger2) {
            this.INT_MAX_VALUE = 2147483647;
            var _logger = logger2 || safeGetLogger(null);
            if (sampleRate > 100 || sampleRate < 0) {
              _logger.throwInternal(2, 58, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", { samplingRate: sampleRate }, true);
              sampleRate = 100;
            }
            this[_DYN_SAMPLE_RATE] = sampleRate;
            this.samplingScoreGenerator = new SamplingScoreGenerator();
          }
          Sample2.prototype.isSampledIn = function(envelope) {
            var samplingPercentage = this[_DYN_SAMPLE_RATE];
            var isSampledIn = false;
            if (samplingPercentage === null || samplingPercentage === void 0 || samplingPercentage >= 100) {
              return true;
            } else if (envelope.baseType === Metric[_DYN_DATA_TYPE]) {
              return true;
            }
            isSampledIn = this.samplingScoreGenerator.getSamplingScore(envelope) < samplingPercentage;
            return isSampledIn;
          };
          return Sample2;
        }()
      );
      var _a$1, _b$1;
      var UNDEFINED_VALUE$1 = void 0;
      var EMPTY_STR = "";
      var FetchSyncRequestSizeLimitBytes = 65e3;
      function _getResponseText(xhr) {
        try {
          return xhr.responseText;
        } catch (e) {
        }
        return null;
      }
      function isOverrideFn(httpXHROverride) {
        return httpXHROverride && httpXHROverride.sendPOST;
      }
      var defaultAppInsightsChannelConfig = objDeepFreeze((_a$1 = {
        endpointUrl: cfgDfValidate(isTruthy, DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH)
      }, _a$1[_DYN_EMIT_LINE_DELIMITED_0] = cfgDfBoolean(), _a$1.maxBatchInterval = 15e3, _a$1[_DYN_MAX_BATCH_SIZE_IN_BY1] = 102400, _a$1.disableTelemetry = cfgDfBoolean(), _a$1[_DYN_ENABLE_SESSION_STORA5] = cfgDfBoolean(true), _a$1.isRetryDisabled = cfgDfBoolean(), _a$1[_DYN_IS_BEACON_API_DISABL3] = cfgDfBoolean(true), _a$1[_DYN_DISABLE_SEND_BEACON_7] = cfgDfBoolean(true), _a$1.disableXhr = cfgDfBoolean(), _a$1[_DYN_ONUNLOAD_DISABLE_FET6] = cfgDfBoolean(), _a$1[_DYN_ONUNLOAD_DISABLE_BEA2] = cfgDfBoolean(), _a$1[_DYN_INSTRUMENTATION_KEY$1] = UNDEFINED_VALUE$1, _a$1.namePrefix = UNDEFINED_VALUE$1, _a$1.samplingPercentage = cfgDfValidate(_chkSampling, 100), _a$1[_DYN_CUSTOM_HEADERS] = UNDEFINED_VALUE$1, _a$1.convertUndefined = UNDEFINED_VALUE$1, _a$1.eventsLimitInMem = 1e4, _a$1[_DYN_BUFFER_OVERRIDE] = false, _a$1.httpXHROverride = { isVal: isOverrideFn, v: UNDEFINED_VALUE$1 }, _a$1[_DYN_ALWAYS_USE_XHR_OVERR4] = cfgDfBoolean(), _a$1.transports = UNDEFINED_VALUE$1, _a$1.retryCodes = UNDEFINED_VALUE$1, _a$1.corsPolicy = UNDEFINED_VALUE$1, _a$1.maxRetryCnt = { isVal: isNumber, v: 10 }, _a$1));
      var CrossOriginResourcePolicyHeader = "X-Set-Cross-Origin-Resource-Policy";
      function _chkSampling(value) {
        return !isNaN(value) && value > 0 && value <= 100;
      }
      var EnvelopeTypeCreator = (_b$1 = {}, _b$1[Event$1.dataType] = EventEnvelopeCreator, _b$1[Trace.dataType] = TraceEnvelopeCreator, _b$1[PageView.dataType] = PageViewEnvelopeCreator, _b$1[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator, _b$1[Exception.dataType] = ExceptionEnvelopeCreator, _b$1[Metric.dataType] = MetricEnvelopeCreator, _b$1[RemoteDependencyData.dataType] = DependencyEnvelopeCreator, _b$1);
      var Sender = (
        /** @class */
        function(_super) {
          __extendsFn(Sender2, _super);
          function Sender2() {
            var _this = _super.call(this) || this;
            _this.priority = 1001;
            _this.identifier = BreezeChannelIdentifier;
            var _consecutiveErrors;
            var _retryAt;
            var _paused;
            var _timeoutHandle;
            var _serializer;
            var _stamp_specific_redirects;
            var _headers;
            var _syncFetchPayload = 0;
            var _syncUnloadSender;
            var _offlineListener;
            var _evtNamespace;
            var _endpointUrl;
            var _orgEndpointUrl;
            var _maxBatchSizeInBytes;
            var _beaconSupported;
            var _beaconOnUnloadSupported;
            var _beaconNormalSupported;
            var _customHeaders;
            var _disableTelemetry;
            var _instrumentationKey;
            var _convertUndefined;
            var _isRetryDisabled;
            var _maxBatchInterval;
            var _sessionStorageUsed;
            var _bufferOverrideUsed;
            var _namePrefix;
            var _enableSendPromise;
            var _alwaysUseCustomSend;
            var _disableXhr;
            var _fetchKeepAlive;
            var _xhrSend;
            var _fallbackSend;
            var _disableBeaconSplit;
            var _sendPostMgr;
            var _retryCodes;
            var _zipPayload;
            dynamicProto(Sender2, _this, function(_self, _base) {
              _initDefaults();
              _self.pause = function() {
                _clearScheduledTimer();
                _paused = true;
              };
              _self.resume = function() {
                if (_paused) {
                  _paused = false;
                  _retryAt = null;
                  _checkMaxSize();
                  _setupTimer();
                }
              };
              _self.flush = function(isAsync, callBack, sendReason) {
                if (isAsync === void 0) {
                  isAsync = true;
                }
                if (!_paused) {
                  _clearScheduledTimer();
                  try {
                    return _self[_DYN_TRIGGER_SEND](isAsync, null, sendReason || 1);
                  } catch (e) {
                    _throwInternal(_self[_DYN_DIAG_LOG](), 1, 22, "flush failed, telemetry will not be collected: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
                  }
                }
              };
              _self.onunloadFlush = function() {
                if (!_paused) {
                  if (_beaconSupported || _alwaysUseCustomSend) {
                    try {
                      return _self[_DYN_TRIGGER_SEND](true, _doUnloadSend, 2);
                    } catch (e) {
                      _throwInternal(_self[_DYN_DIAG_LOG](), 1, 20, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
                    }
                  } else {
                    _self.flush(false);
                  }
                }
              };
              _self.addHeader = function(name, value) {
                _headers[name] = value;
              };
              _self[_DYN_INITIALIZE] = function(config, core, extensions3, pluginChain) {
                if (_self.isInitialized()) {
                  _throwInternal(_self[_DYN_DIAG_LOG](), 1, 28, "Sender is already initialized");
                }
                _base[_DYN_INITIALIZE](config, core, extensions3, pluginChain);
                var identifier = _self.identifier;
                _serializer = new Serializer(core.logger);
                _consecutiveErrors = 0;
                _retryAt = null;
                _self[_DYN__SENDER] = null;
                _stamp_specific_redirects = 0;
                var diagLog = _self[_DYN_DIAG_LOG]();
                _evtNamespace = mergeEvtNamespace(createUniqueNamespace("Sender"), core.evtNamespace && core.evtNamespace());
                _offlineListener = createOfflineListener(_evtNamespace);
                _self._addHook(onConfigChange(config, function(details) {
                  var config2 = details.cfg;
                  if (config2.storagePrefix) {
                    utlSetStoragePrefix(config2.storagePrefix);
                  }
                  var ctx = createProcessTelemetryContext(null, config2, core);
                  var senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig);
                  var curExtUrl = senderConfig[_DYN_ENDPOINT_URL$1];
                  if (_endpointUrl && curExtUrl === _endpointUrl) {
                    var coreUrl = config2[_DYN_ENDPOINT_URL$1];
                    if (coreUrl && coreUrl !== curExtUrl) {
                      senderConfig[_DYN_ENDPOINT_URL$1] = coreUrl;
                    }
                  }
                  var csStream = /* @__PURE__ */ getInst("CompressionStream");
                  _zipPayload = isFeatureEnabled("zipPayload", config2, false);
                  if (!isFunction(csStream)) {
                    _zipPayload = false;
                  }
                  var corsPolicy = senderConfig.corsPolicy;
                  if (corsPolicy) {
                    if (corsPolicy === "same-origin" || corsPolicy === "same-site" || corsPolicy === "cross-origin") {
                      _this.addHeader(CrossOriginResourcePolicyHeader, corsPolicy);
                    }
                  } else {
                    delete _headers[CrossOriginResourcePolicyHeader];
                  }
                  if (/* @__PURE__ */ isPromiseLike(senderConfig[_DYN_INSTRUMENTATION_KEY$1])) {
                    senderConfig[_DYN_INSTRUMENTATION_KEY$1] = config2[_DYN_INSTRUMENTATION_KEY$1];
                  }
                  objDefine(_self, "_senderConfig", {
                    g: function() {
                      return senderConfig;
                    }
                  });
                  if (_orgEndpointUrl !== senderConfig[_DYN_ENDPOINT_URL$1]) {
                    _endpointUrl = _orgEndpointUrl = senderConfig[_DYN_ENDPOINT_URL$1];
                  }
                  if (core.activeStatus() === ActiveStatus.PENDING) {
                    _self.pause();
                  } else if (core.activeStatus() === ActiveStatus.ACTIVE) {
                    _self.resume();
                  }
                  if (_customHeaders && _customHeaders !== senderConfig[_DYN_CUSTOM_HEADERS]) {
                    arrForEach(_customHeaders, function(customHeader) {
                      delete _headers[customHeader.header];
                    });
                  }
                  _maxBatchSizeInBytes = senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1];
                  _beaconSupported = (senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2] === false || senderConfig[_DYN_IS_BEACON_API_DISABL3] === false) && isBeaconsSupported();
                  _beaconOnUnloadSupported = senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2] === false && isBeaconsSupported();
                  _beaconNormalSupported = senderConfig[_DYN_IS_BEACON_API_DISABL3] === false && isBeaconsSupported();
                  _alwaysUseCustomSend = senderConfig[_DYN_ALWAYS_USE_XHR_OVERR4];
                  _disableXhr = !!senderConfig.disableXhr;
                  _retryCodes = senderConfig.retryCodes;
                  var bufferOverride = senderConfig[_DYN_BUFFER_OVERRIDE];
                  var canUseSessionStorage = !!senderConfig[_DYN_ENABLE_SESSION_STORA5] && (!!bufferOverride || utlCanUseSessionStorage());
                  var namePrefix = senderConfig.namePrefix;
                  var shouldUpdate = canUseSessionStorage !== _sessionStorageUsed || canUseSessionStorage && _namePrefix !== namePrefix || canUseSessionStorage && _bufferOverrideUsed !== bufferOverride;
                  if (_self[_DYN__BUFFER]) {
                    if (shouldUpdate) {
                      try {
                        _self[_DYN__BUFFER] = _self[_DYN__BUFFER].createNew(diagLog, senderConfig, canUseSessionStorage);
                      } catch (e) {
                        _throwInternal(_self[_DYN_DIAG_LOG](), 1, 12, "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
                      }
                    }
                    _checkMaxSize();
                  } else {
                    _self[_DYN__BUFFER] = canUseSessionStorage ? new SessionStorageSendBuffer(diagLog, senderConfig) : new ArraySendBuffer(diagLog, senderConfig);
                  }
                  _namePrefix = namePrefix;
                  _sessionStorageUsed = canUseSessionStorage;
                  _bufferOverrideUsed = bufferOverride;
                  _fetchKeepAlive = !senderConfig[_DYN_ONUNLOAD_DISABLE_FET6] && isFetchSupported(true);
                  _disableBeaconSplit = !!senderConfig[_DYN_DISABLE_SEND_BEACON_7];
                  _self._sample = new Sample(senderConfig.samplingPercentage, diagLog);
                  _instrumentationKey = senderConfig[_DYN_INSTRUMENTATION_KEY$1];
                  if (!/* @__PURE__ */ isPromiseLike(_instrumentationKey) && !_validateInstrumentationKey(_instrumentationKey, config2)) {
                    _throwInternal(diagLog, 1, 100, "Invalid Instrumentation key " + _instrumentationKey);
                  }
                  _customHeaders = senderConfig[_DYN_CUSTOM_HEADERS];
                  if (isString(_endpointUrl) && !isInternalApplicationInsightsEndpoint(_endpointUrl) && _customHeaders && _customHeaders[_DYN_LENGTH] > 0) {
                    arrForEach(_customHeaders, function(customHeader) {
                      _this.addHeader(customHeader.header, customHeader.value);
                    });
                  } else {
                    _customHeaders = null;
                  }
                  _enableSendPromise = senderConfig.enableSendPromise;
                  var sendPostConfig = _getSendPostMgrConfig();
                  if (!_sendPostMgr) {
                    _sendPostMgr = new SenderPostManager();
                    _sendPostMgr[_DYN_INITIALIZE](sendPostConfig, diagLog);
                  } else {
                    _sendPostMgr.SetConfig(sendPostConfig);
                  }
                  var customInterface = senderConfig.httpXHROverride;
                  var httpInterface = null;
                  var syncInterface = null;
                  var theTransports = prependTransports([3, 1, 2], senderConfig.transports);
                  httpInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST](theTransports, false);
                  var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();
                  _xhrSend = function(payload, isAsync) {
                    return _doSend(xhrInterface, payload, isAsync);
                  };
                  _fallbackSend = function(payload, isAsync) {
                    return _doSend(xhrInterface, payload, isAsync, false);
                  };
                  httpInterface = _alwaysUseCustomSend ? customInterface : httpInterface || customInterface || xhrInterface;
                  _self[_DYN__SENDER] = function(payload, isAsync) {
                    return _doSend(httpInterface, payload, isAsync);
                  };
                  if (_fetchKeepAlive) {
                    _syncUnloadSender = _fetchKeepAliveSender;
                  }
                  var syncTransports = prependTransports([3, 1], senderConfig.unloadTransports);
                  if (!_fetchKeepAlive) {
                    syncTransports = syncTransports.filter(function(transport) {
                      return transport !== 2;
                    });
                  }
                  syncInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST](syncTransports, true);
                  syncInterface = _alwaysUseCustomSend ? customInterface : syncInterface || customInterface;
                  if ((_alwaysUseCustomSend || senderConfig.unloadTransports || !_syncUnloadSender) && syncInterface) {
                    _syncUnloadSender = function(payload, isAsync) {
                      return _doSend(syncInterface, payload, isAsync);
                    };
                  }
                  if (!_syncUnloadSender) {
                    _syncUnloadSender = _xhrSend;
                  }
                  _disableTelemetry = senderConfig.disableTelemetry;
                  _convertUndefined = senderConfig.convertUndefined || UNDEFINED_VALUE$1;
                  _isRetryDisabled = senderConfig.isRetryDisabled;
                  _maxBatchInterval = senderConfig.maxBatchInterval;
                }));
              };
              _self.processTelemetry = function(telemetryItem, itemCtx) {
                itemCtx = _self._getTelCtx(itemCtx);
                var diagLogger = itemCtx[_DYN_DIAG_LOG]();
                try {
                  var isValidate = _validate(telemetryItem, diagLogger);
                  if (!isValidate) {
                    return;
                  }
                  var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);
                  if (!aiEnvelope) {
                    return;
                  }
                  var payload = _serializer.serialize(aiEnvelope);
                  var buffer = _self[_DYN__BUFFER];
                  _checkMaxSize(payload);
                  var payloadItem = {
                    item: payload,
                    cnt: 0
                  };
                  buffer[_DYN_ENQUEUE](payloadItem);
                  _setupTimer();
                } catch (e) {
                  _throwInternal(diagLogger, 2, 12, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
                }
                _self.processNext(telemetryItem, itemCtx);
              };
              _self.isCompletelyIdle = function() {
                return !_paused && _syncFetchPayload === 0 && _self._buffer[_DYN_COUNT]() === 0;
              };
              _self.getOfflineListener = function() {
                return _offlineListener;
              };
              _self._xhrReadyStateChange = function(xhr, payload, countOfItemsInPayload) {
                if (_isStringArr(payload)) {
                  return;
                }
                return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);
              };
              _self[_DYN_TRIGGER_SEND] = function(async, forcedSender, sendReason) {
                if (async === void 0) {
                  async = true;
                }
                var result;
                if (!_paused) {
                  try {
                    var buffer = _self[_DYN__BUFFER];
                    if (!_disableTelemetry) {
                      if (buffer[_DYN_COUNT]() > 0) {
                        var payload = buffer.getItems();
                        _notifySendRequest(sendReason || 0, async);
                        if (forcedSender) {
                          result = forcedSender.call(_self, payload, async);
                        } else {
                          result = _self[_DYN__SENDER](payload, async);
                        }
                      }
                    } else {
                      buffer[_DYN_CLEAR]();
                    }
                    _clearScheduledTimer();
                  } catch (e) {
                    var ieVer = getIEVersion();
                    if (!ieVer || ieVer > 9) {
                      _throwInternal(_self[_DYN_DIAG_LOG](), 1, 40, "Telemetry transmission failed, some telemetry will be lost: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
                    }
                  }
                }
                return result;
              };
              _self.getOfflineSupport = function() {
                return {
                  getUrl: function() {
                    return _endpointUrl;
                  },
                  createPayload: _createPayload,
                  serialize: _serialize,
                  batch: _batch,
                  shouldProcess: function(evt) {
                    return !!_validate(evt);
                  }
                };
              };
              _self._doTeardown = function(unloadCtx, unloadState) {
                _self.onunloadFlush();
                runTargetUnload(_offlineListener, false);
                _initDefaults();
              };
              _self[_DYN__ON_ERROR] = function(payload, message, event) {
                if (_isStringArr(payload)) {
                  return;
                }
                return _onError(payload, message);
              };
              _self[_DYN__ON_PARTIAL_SUCCESS] = function(payload, results) {
                if (_isStringArr(payload)) {
                  return;
                }
                return _onPartialSuccess(payload, results);
              };
              _self[_DYN__ON_SUCCESS] = function(payload, countOfItemsInPayload) {
                if (_isStringArr(payload)) {
                  return;
                }
                return _onSuccess(payload);
              };
              _self._xdrOnLoad = function(xdr, payload) {
                if (_isStringArr(payload)) {
                  return;
                }
                return _xdrOnLoad(xdr, payload);
              };
              function _xdrOnLoad(xdr, payload) {
                var responseText = _getResponseText(xdr);
                if (xdr && (responseText + "" === "200" || responseText === "")) {
                  _consecutiveErrors = 0;
                  _self[_DYN__ON_SUCCESS](payload, 0);
                } else {
                  var results = parseResponse(responseText);
                  if (results && results[_DYN_ITEMS_RECEIVED] && results[_DYN_ITEMS_RECEIVED] > results[_DYN_ITEMS_ACCEPTED] && !_isRetryDisabled) {
                    _self[_DYN__ON_PARTIAL_SUCCESS](payload, results);
                  } else {
                    _self[_DYN__ON_ERROR](payload, formatErrorMessageXdr(xdr));
                  }
                }
              }
              function _getSendPostMgrConfig() {
                try {
                  var onCompleteFuncs = {
                    xdrOnComplete: function(xdr, oncomplete, payload) {
                      var payloadArr = _getPayloadArr(payload);
                      if (!payloadArr) {
                        return;
                      }
                      return _xdrOnLoad(xdr, payloadArr);
                    },
                    fetchOnComplete: function(response, onComplete, resValue, payload) {
                      var payloadArr = _getPayloadArr(payload);
                      if (!payloadArr) {
                        return;
                      }
                      return _checkResponsStatus(response.status, payloadArr, response.url, payloadArr[_DYN_LENGTH], response.statusText, resValue || "");
                    },
                    xhrOnComplete: function(request, oncomplete, payload) {
                      var payloadArr = _getPayloadArr(payload);
                      if (!payloadArr) {
                        return;
                      }
                      return _xhrReadyStateChange(request, payloadArr, payloadArr[_DYN_LENGTH]);
                    },
                    beaconOnRetry: function(data, onComplete, canSend) {
                      return _onBeaconRetry(data, onComplete, canSend);
                    }
                  };
                  var config = {
                    enableSendPromise: _enableSendPromise,
                    isOneDs: false,
                    disableCredentials: false,
                    disableXhr: _disableXhr,
                    disableBeacon: !_beaconNormalSupported,
                    disableBeaconSync: !_beaconOnUnloadSupported,
                    senderOnCompleteCallBack: onCompleteFuncs
                  };
                  return config;
                } catch (e) {
                }
                return null;
              }
              function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {
                if (xhr.readyState === 4) {
                  _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);
                }
              }
              function _onError(payload, message, event) {
                _throwInternal(_self[_DYN_DIAG_LOG](), 2, 26, "Failed to send telemetry.", { message });
                _self._buffer && _self._buffer[_DYN_CLEAR_SENT](payload);
              }
              function _onPartialSuccess(payload, results) {
                var failed = [];
                var retry = [];
                var errors = results.errors.reverse();
                for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
                  var error = errors_1[_i];
                  var extracted = payload.splice(error.index, 1)[0];
                  if (_isRetriable(error.statusCode)) {
                    retry[_DYN_PUSH](extracted);
                  } else {
                    failed[_DYN_PUSH](extracted);
                  }
                }
                if (payload[_DYN_LENGTH] > 0) {
                  _self[_DYN__ON_SUCCESS](payload, results[_DYN_ITEMS_ACCEPTED]);
                }
                if (failed[_DYN_LENGTH] > 0) {
                  _self[_DYN__ON_ERROR](failed, formatErrorMessageXhr(null, ["partial success", results[_DYN_ITEMS_ACCEPTED], "of", results.itemsReceived].join(" ")));
                }
                if (retry[_DYN_LENGTH] > 0) {
                  _resendPayload(retry);
                  _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, "Partial success. Delivered: " + payload[_DYN_LENGTH] + ", Failed: " + failed[_DYN_LENGTH] + ". Will retry to send " + retry[_DYN_LENGTH] + " our of " + results[_DYN_ITEMS_RECEIVED] + " items");
                }
              }
              function _onSuccess(payload, countOfItemsInPayload) {
                _self._buffer && _self._buffer[_DYN_CLEAR_SENT](payload);
              }
              function _getPayloadArr(payload) {
                try {
                  if (payload) {
                    var internalPayload = payload;
                    var arr = internalPayload.oriPayload;
                    if (arr && arr[_DYN_LENGTH]) {
                      return arr;
                    }
                    return null;
                  }
                } catch (e) {
                }
                return null;
              }
              function _validate(telemetryItem, diagLogger) {
                if (_disableTelemetry) {
                  return false;
                }
                if (!telemetryItem) {
                  diagLogger && _throwInternal(diagLogger, 1, 7, "Cannot send empty telemetry");
                  return false;
                }
                if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE]) {
                  diagLogger && _throwInternal(diagLogger, 1, 70, "Cannot send telemetry without baseData and baseType");
                  return false;
                }
                if (!telemetryItem[_DYN_BASE_TYPE]) {
                  telemetryItem[_DYN_BASE_TYPE] = "EventData";
                }
                if (!_self[_DYN__SENDER]) {
                  diagLogger && _throwInternal(diagLogger, 1, 28, "Sender was not initialized");
                  return false;
                }
                if (!_isSampledIn(telemetryItem)) {
                  diagLogger && _throwInternal(diagLogger, 2, 33, "Telemetry item was sampled out and not sent", { SampleRate: _self._sample[_DYN_SAMPLE_RATE] });
                  return false;
                } else {
                  telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE];
                }
                return true;
              }
              function _getEnvelope(telemetryItem, diagLogger) {
                var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey;
                var aiEnvelope = Sender2.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);
                if (!aiEnvelope) {
                  _throwInternal(diagLogger, 1, 47, "Unable to create an AppInsights envelope");
                  return;
                }
                var doNotSendItem = false;
                if (telemetryItem[_DYN_TAGS] && telemetryItem[_DYN_TAGS][ProcessLegacy]) {
                  arrForEach(telemetryItem[_DYN_TAGS][ProcessLegacy], function(callBack) {
                    try {
                      if (callBack && callBack(aiEnvelope) === false) {
                        doNotSendItem = true;
                        _warnToConsole(diagLogger, "Telemetry processor check returns false");
                      }
                    } catch (e) {
                      _throwInternal(diagLogger, 1, 64, "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) }, true);
                    }
                  });
                  delete telemetryItem[_DYN_TAGS][ProcessLegacy];
                }
                if (doNotSendItem) {
                  return;
                }
                return aiEnvelope;
              }
              function _serialize(item) {
                var rlt = EMPTY_STR;
                var diagLogger = _self[_DYN_DIAG_LOG]();
                try {
                  var valid = _validate(item, diagLogger);
                  var envelope = null;
                  if (valid) {
                    envelope = _getEnvelope(item, diagLogger);
                  }
                  if (envelope) {
                    rlt = _serializer.serialize(envelope);
                  }
                } catch (e) {
                }
                return rlt;
              }
              function _batch(arr) {
                var rlt = EMPTY_STR;
                if (arr && arr[_DYN_LENGTH]) {
                  rlt = "[" + arr.join(",") + "]";
                }
                return rlt;
              }
              function _createPayload(data) {
                var headers = _getHeaders();
                return {
                  urlString: _endpointUrl,
                  data,
                  headers
                };
              }
              function _isSampledIn(envelope) {
                return _self._sample.isSampledIn(envelope);
              }
              function _getOnComplete(payload, status, headers, response) {
                if (status === 200 && payload) {
                  _self._onSuccess(payload, payload[_DYN_LENGTH]);
                } else {
                  response && _self[_DYN__ON_ERROR](payload, response);
                }
              }
              function _doSend(sendInterface, payload, isAsync, markAsSent) {
                if (markAsSent === void 0) {
                  markAsSent = true;
                }
                var onComplete = function(status, headers, response) {
                  return _getOnComplete(payload, status, headers, response);
                };
                var payloadData = _getPayload(payload);
                var sendPostFunc = sendInterface && sendInterface.sendPOST;
                if (sendPostFunc && payloadData) {
                  if (markAsSent) {
                    _self._buffer[_DYN_MARK_AS_SENT](payload);
                  }
                  _sendPostMgr.preparePayload(function(processedPayload) {
                    return sendPostFunc(processedPayload, onComplete, !isAsync);
                  }, _zipPayload, payloadData, !isAsync);
                }
                return null;
              }
              function _getPayload(payload) {
                if (isArray(payload) && payload[_DYN_LENGTH] > 0) {
                  var batch = _self[_DYN__BUFFER].batchPayloads(payload);
                  var headers = _getHeaders();
                  var payloadData = {
                    data: batch,
                    urlString: _endpointUrl,
                    headers,
                    disableXhrSync: _disableXhr,
                    disableFetchKeepAlive: !_fetchKeepAlive,
                    oriPayload: payload
                  };
                  return payloadData;
                }
                return null;
              }
              function _getHeaders() {
                try {
                  var headers = _headers || {};
                  if (isInternalApplicationInsightsEndpoint(_endpointUrl)) {
                    headers[RequestHeaders[6]] = RequestHeaders[7];
                  }
                  return headers;
                } catch (e) {
                }
                return null;
              }
              function _checkMaxSize(incomingPayload) {
                var incomingSize = incomingPayload ? incomingPayload[_DYN_LENGTH] : 0;
                if (_self[_DYN__BUFFER].size() + incomingSize > _maxBatchSizeInBytes) {
                  if (!_offlineListener || _offlineListener.isOnline()) {
                    _self[_DYN_TRIGGER_SEND](true, null, 10);
                  }
                  return true;
                }
                return false;
              }
              function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
                var response = null;
                if (!_self._appId) {
                  response = parseResponse(res);
                  if (response && response.appId) {
                    _self._appId = response.appId;
                  }
                }
                if ((status < 200 || status >= 300) && status !== 0) {
                  if (status === 301 || status === 307 || status === 308) {
                    if (!_checkAndUpdateEndPointUrl(responseUrl)) {
                      _self[_DYN__ON_ERROR](payload, errorMessage);
                      return;
                    }
                  }
                  if (_offlineListener && !_offlineListener.isOnline()) {
                    if (!_isRetryDisabled) {
                      var offlineBackOffMultiplier = 10;
                      _resendPayload(payload, offlineBackOffMultiplier);
                      _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Offline - Response Code: ".concat(status, ". Offline status: ").concat(!_offlineListener.isOnline(), ". Will retry to send ").concat(payload.length, " items."));
                    }
                    return;
                  }
                  if (!_isRetryDisabled && _isRetriable(status)) {
                    _resendPayload(payload);
                    _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Response code " + status + ". Will retry to send " + payload[_DYN_LENGTH] + " items.");
                  } else {
                    _self[_DYN__ON_ERROR](payload, errorMessage);
                  }
                } else {
                  _checkAndUpdateEndPointUrl(responseUrl);
                  if (status === 206) {
                    if (!response) {
                      response = parseResponse(res);
                    }
                    if (response && !_isRetryDisabled) {
                      _self[_DYN__ON_PARTIAL_SUCCESS](payload, response);
                    } else {
                      _self[_DYN__ON_ERROR](payload, errorMessage);
                    }
                  } else {
                    _consecutiveErrors = 0;
                    _self[_DYN__ON_SUCCESS](payload, countOfItemsInPayload);
                  }
                }
              }
              function _checkAndUpdateEndPointUrl(responseUrl) {
                if (_stamp_specific_redirects >= 10) {
                  return false;
                }
                if (!/* @__PURE__ */ isNullOrUndefined(responseUrl) && responseUrl !== "") {
                  if (responseUrl !== _endpointUrl) {
                    _endpointUrl = responseUrl;
                    ++_stamp_specific_redirects;
                    return true;
                  }
                }
                return false;
              }
              function _doUnloadSend(payload, isAsync) {
                if (_syncUnloadSender) {
                  _syncUnloadSender(payload, false);
                } else {
                  var beaconInst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST]([3], true);
                  return _doSend(beaconInst, payload, isAsync);
                }
              }
              function _onBeaconRetry(payload, onComplete, canSend) {
                var internalPayload = payload;
                var data = internalPayload && internalPayload.oriPayload;
                if (!_disableBeaconSplit) {
                  var droppedPayload = [];
                  for (var lp = 0; lp < data[_DYN_LENGTH]; lp++) {
                    var thePayload = data[lp];
                    var arr = [thePayload];
                    var item = _getPayload(arr);
                    if (!canSend(item, onComplete)) {
                      droppedPayload[_DYN_PUSH](thePayload);
                    } else {
                      _self._onSuccess(arr, arr[_DYN_LENGTH]);
                    }
                  }
                  if (droppedPayload[_DYN_LENGTH] > 0) {
                    _fallbackSend && _fallbackSend(droppedPayload, true);
                    _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");
                  }
                } else {
                  _fallbackSend && _fallbackSend(data, true);
                  _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");
                }
              }
              function _isStringArr(arr) {
                try {
                  if (arr && arr[_DYN_LENGTH]) {
                    return isString(arr[0]);
                  }
                } catch (e) {
                }
                return null;
              }
              function _fetchKeepAliveSender(payload, isAsync) {
                var transport = null;
                if (isArray(payload)) {
                  var payloadSize = payload[_DYN_LENGTH];
                  for (var lp = 0; lp < payload[_DYN_LENGTH]; lp++) {
                    payloadSize += payload[lp].item[_DYN_LENGTH];
                  }
                  var syncFetchPayload = _sendPostMgr.getSyncFetchPayload();
                  if (syncFetchPayload + payloadSize <= FetchSyncRequestSizeLimitBytes) {
                    transport = 2;
                  } else if (isBeaconsSupported()) {
                    transport = 3;
                  } else {
                    transport = 1;
                    _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with xhrSender.");
                  }
                  var inst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST]([transport], true);
                  return _doSend(inst, payload, isAsync);
                }
                return null;
              }
              function _resendPayload(payload, linearFactor) {
                if (linearFactor === void 0) {
                  linearFactor = 1;
                }
                if (!payload || payload[_DYN_LENGTH] === 0) {
                  return;
                }
                var buffer = _self[_DYN__BUFFER];
                buffer[_DYN_CLEAR_SENT](payload);
                _consecutiveErrors++;
                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
                  var item = payload_1[_i];
                  item.cnt = item.cnt || 0;
                  item.cnt++;
                  buffer[_DYN_ENQUEUE](item);
                }
                _setRetryTime(linearFactor);
                _setupTimer();
              }
              function _setRetryTime(linearFactor) {
                var SlotDelayInSeconds = 10;
                var delayInSeconds;
                if (_consecutiveErrors <= 1) {
                  delayInSeconds = SlotDelayInSeconds;
                } else {
                  var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;
                  var backOffDelay = mathFloor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
                  backOffDelay = linearFactor * backOffDelay;
                  delayInSeconds = mathMax(mathMin(backOffDelay, 3600), SlotDelayInSeconds);
                }
                var retryAfterTimeSpan = /* @__PURE__ */ utcNow() + delayInSeconds * 1e3;
                _retryAt = retryAfterTimeSpan;
              }
              function _setupTimer() {
                if (!_timeoutHandle && !_paused) {
                  var retryInterval = _retryAt ? mathMax(0, _retryAt - /* @__PURE__ */ utcNow()) : 0;
                  var timerValue = mathMax(_maxBatchInterval, retryInterval);
                  _timeoutHandle = scheduleTimeout(function() {
                    _timeoutHandle = null;
                    _self[_DYN_TRIGGER_SEND](true, null, 1);
                  }, timerValue);
                }
              }
              function _clearScheduledTimer() {
                _timeoutHandle && _timeoutHandle.cancel();
                _timeoutHandle = null;
                _retryAt = null;
              }
              function _isRetriable(statusCode) {
                if (!/* @__PURE__ */ isNullOrUndefined(_retryCodes)) {
                  return _retryCodes[_DYN_LENGTH] && _retryCodes.indexOf(statusCode) > -1;
                }
                return statusCode === 401 || statusCode === 408 || statusCode === 429 || statusCode === 500 || statusCode === 502 || statusCode === 503 || statusCode === 504;
              }
              function _getNotifyMgr() {
                var func = "getNotifyMgr";
                var result;
                var core = _self.core;
                if (core) {
                  if (core[func]) {
                    result = core[func]();
                  } else {
                    result = core["_notificationManager"];
                  }
                }
                return result;
              }
              function _notifySendRequest(sendRequest, isAsync) {
                var manager = _getNotifyMgr();
                if (manager && manager.eventsSendRequest) {
                  try {
                    manager.eventsSendRequest(sendRequest, isAsync);
                  } catch (e) {
                    _throwInternal(_self[_DYN_DIAG_LOG](), 1, 74, "send request notification failed: " + getExceptionName(e), { exception: /* @__PURE__ */ dumpObj(e) });
                  }
                }
              }
              function _validateInstrumentationKey(instrumentationKey, config) {
                var disableValidation = config.disableInstrumentationKeyValidation;
                var disableIKeyValidationFlag = /* @__PURE__ */ isNullOrUndefined(disableValidation) ? false : disableValidation;
                if (disableIKeyValidationFlag) {
                  return true;
                }
                var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
                var regexp = new RegExp(UUID_Regex);
                return regexp.test(instrumentationKey);
              }
              function _initDefaults() {
                _self[_DYN__SENDER] = null;
                _self[_DYN__BUFFER] = null;
                _self._appId = null;
                _self._sample = null;
                _headers = {};
                _offlineListener = null;
                _consecutiveErrors = 0;
                _retryAt = null;
                _paused = false;
                _timeoutHandle = null;
                _serializer = null;
                _stamp_specific_redirects = 0;
                _syncFetchPayload = 0;
                _syncUnloadSender = null;
                _evtNamespace = null;
                _endpointUrl = null;
                _orgEndpointUrl = null;
                _maxBatchSizeInBytes = 0;
                _beaconSupported = false;
                _customHeaders = null;
                _disableTelemetry = false;
                _instrumentationKey = null;
                _convertUndefined = UNDEFINED_VALUE$1;
                _isRetryDisabled = false;
                _sessionStorageUsed = null;
                _namePrefix = UNDEFINED_VALUE$1;
                _disableXhr = false;
                _fetchKeepAlive = false;
                _disableBeaconSplit = false;
                _xhrSend = null;
                _fallbackSend = null;
                _sendPostMgr = null;
                objDefine(_self, "_senderConfig", {
                  g: function() {
                    return objExtend({}, defaultAppInsightsChannelConfig);
                  }
                });
              }
            });
            return _this;
          }
          Sender2.constructEnvelope = function(orig, iKey, logger2, convertUndefined) {
            var envelope;
            if (iKey !== orig.iKey && !/* @__PURE__ */ isNullOrUndefined(iKey)) {
              envelope = __assignFn(__assignFn({}, orig), { iKey });
            } else {
              envelope = orig;
            }
            var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;
            return creator(logger2, envelope, convertUndefined);
          };
          return Sender2;
        }(BaseTelemetryPlugin)
      );
      var _DYN_INSTRUMENTATION_KEY = "instrumentationKey";
      var _DYN_CONNECTION_STRING = "connectionString";
      var _DYN_ENDPOINT_URL = "endpointUrl";
      var _DYN_USER_OVERRIDE_ENDPOI0 = "userOverrideEndpointUrl";
      var _a, _b;
      var UNDEFINED_VALUE = void 0;
      var defaultConfigValues = (_a = {
        diagnosticLogInterval: cfgDfValidate(_chkDiagLevel, 1e4)
      }, _a[_DYN_CONNECTION_STRING] = UNDEFINED_VALUE, _a.endpointUrl = UNDEFINED_VALUE, _a[_DYN_INSTRUMENTATION_KEY] = UNDEFINED_VALUE, _a.featureOptIn = (_b = {}, _b["zipPayload"] = { mode: 1 }, _b), _a.extensionConfig = {}, _a);
      function _chkDiagLevel(value) {
        return value && value > 0;
      }
      var ApplicationInsights = (
        /** @class */
        function() {
          function ApplicationInsights2(config) {
            var core = new AppInsightsCore();
            var _config;
            if (/* @__PURE__ */ isNullOrUndefined(config) || /* @__PURE__ */ isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY]) && /* @__PURE__ */ isNullOrUndefined(config[_DYN_CONNECTION_STRING])) {
              throwError("Invalid input configuration");
            }
            dynamicProto(ApplicationInsights2, this, function(_self) {
              objDefine(_self, "config", {
                g: function() {
                  return _config;
                }
              });
              _initialize();
              _self.initialize = _initialize;
              _self.track = _track;
              proxyFunctions(_self, core, [
                "flush",
                "pollInternalLogs",
                "stopPollingInternalLogs",
                "unload",
                "getPlugin",
                "addPlugin",
                "evtNamespace",
                "addUnloadCb",
                "onCfgChange",
                "getTraceCtx",
                "updateCfg",
                "addTelemetryInitializer"
              ]);
              function _initialize() {
                var cfgHandler = createDynamicConfig(config || {}, defaultConfigValues);
                _config = cfgHandler.cfg;
                core.addUnloadHook(onConfigChange(cfgHandler, function() {
                  var configCs = _config[_DYN_CONNECTION_STRING];
                  if (/* @__PURE__ */ isPromiseLike(configCs)) {
                    var ikeyPromise = createSyncPromise(function(resolve3, reject) {
                      doAwaitResponse(configCs, function(res) {
                        var curCs = res.value;
                        var ikey = _config[_DYN_INSTRUMENTATION_KEY];
                        if (!res.rejected && curCs) {
                          _config[_DYN_CONNECTION_STRING] = curCs;
                          var resolvedCs = parseConnectionString(curCs);
                          ikey = resolvedCs.instrumentationkey || ikey;
                        }
                        resolve3(ikey);
                      });
                    });
                    var urlPromise = createSyncPromise(function(resolve3, reject) {
                      doAwaitResponse(configCs, function(res) {
                        var curCs = res.value;
                        var url = _config[_DYN_ENDPOINT_URL];
                        if (!res.rejected && curCs) {
                          var resolvedCs = parseConnectionString(curCs);
                          var ingest2 = resolvedCs.ingestionendpoint;
                          url = ingest2 ? ingest2 + DEFAULT_BREEZE_PATH : url;
                        }
                        resolve3(url);
                      });
                    });
                    _config[_DYN_INSTRUMENTATION_KEY] = ikeyPromise;
                    _config[_DYN_ENDPOINT_URL] = _config[_DYN_USER_OVERRIDE_ENDPOI0] || urlPromise;
                  }
                  if (isString(configCs)) {
                    var cs = parseConnectionString(configCs);
                    var ingest = cs.ingestionendpoint;
                    _config[_DYN_ENDPOINT_URL] = _config[_DYN_USER_OVERRIDE_ENDPOI0] ? _config[_DYN_USER_OVERRIDE_ENDPOI0] : ingest + DEFAULT_BREEZE_PATH;
                    _config[_DYN_INSTRUMENTATION_KEY] = cs.instrumentationkey || _config[_DYN_INSTRUMENTATION_KEY];
                  }
                  _config[_DYN_ENDPOINT_URL] = _config[_DYN_USER_OVERRIDE_ENDPOI0] ? _config[_DYN_USER_OVERRIDE_ENDPOI0] : _config[_DYN_ENDPOINT_URL];
                }));
                core.initialize(_config, [new Sender()]);
              }
            });
            function _track(item) {
              if (item) {
                item.baseData = item.baseData || {};
                item.baseType = item.baseType || "EventData";
              }
              core.track(item);
            }
          }
          ApplicationInsights2.__ieDyn = 1;
          return ApplicationInsights2;
        }()
      );
      exports3.AppInsightsCore = AppInsightsCore;
      exports3.ApplicationInsights = ApplicationInsights;
      exports3.Sender = Sender;
      exports3.SeverityLevel = SeverityLevel;
      exports3.arrForEach = arrForEach;
      exports3.isNullOrUndefined = isNullOrUndefined;
      exports3.proxyFunctions = proxyFunctions;
      exports3.throwError = throwError;
    });
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/appInsightsClientFactory.js
var require_appInsightsClientFactory = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/appInsightsClientFactory.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.appInsightsClientFactory = void 0;
    var applicationinsights_common_1 = require_applicationinsights_common();
    var util_1 = require_util();
    var appInsightsClientFactory = async (connectionString, machineId, sessionId, xhrOverride, replacementOptions) => {
      let appInsightsClient;
      try {
        const basicAISDK = await Promise.resolve().then(() => __importStar(require_applicationinsights_web_basic()));
        const extensionConfig = {};
        if (xhrOverride) {
          const channelConfig = {
            alwaysUseXhrOverride: true,
            httpXHROverride: xhrOverride
          };
          extensionConfig[applicationinsights_common_1.BreezeChannelIdentifier] = channelConfig;
        }
        let instrumentationKey;
        if (!connectionString.startsWith("InstrumentationKey=")) {
          instrumentationKey = connectionString;
        }
        const authConfig = instrumentationKey ? { instrumentationKey } : { connectionString };
        appInsightsClient = new basicAISDK.ApplicationInsights({
          ...authConfig,
          disableAjaxTracking: true,
          disableExceptionTracking: true,
          disableFetchTracking: true,
          disableCorrelationHeaders: true,
          disableCookiesUsage: true,
          autoTrackPageVisitTime: false,
          emitLineDelimitedJson: false,
          disableInstrumentationKeyValidation: true,
          extensionConfig
        });
      } catch (e) {
        return Promise.reject(e);
      }
      const telemetryClient = {
        logEvent: (eventName, data) => {
          const properties = { ...data?.properties, ...data?.measurements };
          if (replacementOptions?.length) {
            util_1.TelemetryUtil.applyReplacements(properties, replacementOptions);
          }
          appInsightsClient?.track({
            name: eventName,
            data: properties,
            baseType: "EventData",
            ext: { user: { id: machineId, authId: machineId }, app: { sesId: sessionId } },
            baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
          });
        },
        flush: async () => {
          appInsightsClient?.flush(false);
        },
        dispose: async () => {
          const unloadPromise = new Promise((resolve3) => {
            appInsightsClient?.unload(true, () => {
              resolve3();
              appInsightsClient = void 0;
            }, 1e3);
          });
          return unloadPromise;
        }
      };
      return telemetryClient;
    };
    exports2.appInsightsClientFactory = appInsightsClientFactory;
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetryReporter.js
var require_baseTelemetryReporter = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetryReporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseTelemetryReporter = void 0;
    var BaseTelemetryReporter = class {
      constructor(telemetrySender, vscodeAPI, initializationOptions) {
        this.telemetrySender = telemetrySender;
        this.vscodeAPI = vscodeAPI;
        this.userOptIn = false;
        this.errorOptIn = false;
        this.disposables = [];
        this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter();
        this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event;
        this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, initializationOptions);
        this.updateUserOptIn();
        this.telemetryLogger.onDidChangeEnableStates(() => {
          this.updateUserOptIn();
        });
      }
      /**
       * Updates the user's telemetry opt-in status
       */
      updateUserOptIn() {
        this.errorOptIn = this.telemetryLogger.isErrorsEnabled;
        this.userOptIn = this.telemetryLogger.isUsageEnabled;
        if (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) {
          this.telemetrySender.instantiateSender();
        }
        this._onDidChangeTelemetryLevel.fire(this.telemetryLevel);
      }
      get telemetryLevel() {
        if (this.errorOptIn && this.userOptIn) {
          return "all";
        } else if (this.errorOptIn) {
          return "error";
        } else {
          return "off";
        }
      }
      /**
       * Internal function which logs telemetry events and takes extra options.
       * @param eventName The name of the event
       * @param properties The properties of the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures
       * @param dangerous Whether or not to ignore telemetry level
       */
      internalSendTelemetryEvent(eventName, properties, measurements, dangerous) {
        if (dangerous) {
          this.telemetrySender.sendEventData(eventName, { properties, measurements });
        } else {
          this.telemetryLogger.logUsage(eventName, { properties, measurements });
        }
      }
      /**
       * Given an event name, some properties, and measurements sends a telemetry event.
       * Properties are sanitized on best-effort basis to remove sensitive data prior to sending.
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       */
      sendTelemetryEvent(eventName, properties, measurements) {
        this.internalSendTelemetryEvent(eventName, properties, measurements, false);
      }
      /**
       * Sends a raw (unsanitized) telemetry event with the given properties and measurements.
       * NOTE: This will not be logged to the output channel due to API limitations.
       * @param eventName The name of the event
       * @param properties The set of properties to add to the event in the form of a string key value pair
       * @param measurements The set of measurements to add to the event in the form of a string key  number value pair
       */
      sendRawTelemetryEvent(eventName, properties, measurements) {
        const modifiedProperties = { ...properties };
        for (const propertyKey of Object.keys(modifiedProperties ?? {})) {
          const propertyValue = modifiedProperties[propertyKey];
          if (typeof propertyKey === "string" && propertyValue !== void 0) {
            modifiedProperties[propertyKey] = new this.vscodeAPI.TelemetryTrustedValue(typeof propertyValue === "string" ? propertyValue : propertyValue.value);
          }
        }
        this.sendTelemetryEvent(eventName, modifiedProperties, measurements);
      }
      /**
       * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry event without checking telemetry setting
       * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures, defaults to true
       */
      sendDangerousTelemetryEvent(eventName, properties, measurements) {
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryEvent(eventName, properties, measurements, true);
      }
      /**
       * Internal function which logs telemetry error events and takes extra options.
       * @param eventName The name of the event
       * @param properties The properties of the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures
       * @param dangerous Whether or not to ignore telemetry level
       */
      internalSendTelemetryErrorEvent(eventName, properties, measurements, dangerous) {
        if (dangerous) {
          this.telemetrySender.sendEventData(eventName, { properties, measurements });
        } else {
          this.telemetryLogger.logError(eventName, { properties, measurements });
        }
      }
      /**
       * Given an event name, some properties, and measurements sends an error event
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       */
      sendTelemetryErrorEvent(eventName, properties, measurements) {
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, false);
      }
      /**
       * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry error event without checking telemetry setting
       * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to run the properties and measures through sanitiziation, defaults to true
       */
      sendDangerousTelemetryErrorEvent(eventName, properties, measurements) {
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, true);
      }
      /**
       * Disposes of the telemetry reporter
       */
      async dispose() {
        await this.telemetrySender.dispose();
        this.telemetryLogger.dispose();
        return Promise.all(this.disposables.map((d) => d.dispose()));
      }
    };
    exports2.BaseTelemetryReporter = BaseTelemetryReporter;
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetrySender.js
var require_baseTelemetrySender = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetrySender.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseTelemetrySender = void 0;
    var InstantiationStatus;
    (function(InstantiationStatus2) {
      InstantiationStatus2[InstantiationStatus2["NOT_INSTANTIATED"] = 0] = "NOT_INSTANTIATED";
      InstantiationStatus2[InstantiationStatus2["INSTANTIATING"] = 1] = "INSTANTIATING";
      InstantiationStatus2[InstantiationStatus2["INSTANTIATED"] = 2] = "INSTANTIATED";
    })(InstantiationStatus || (InstantiationStatus = {}));
    var BaseTelemetrySender = class {
      constructor(key, clientFactory) {
        this._instantiationStatus = InstantiationStatus.NOT_INSTANTIATED;
        this._eventQueue = [];
        this._exceptionQueue = [];
        this._clientFactory = clientFactory;
        this._key = key;
      }
      /**
       * Sends the event to the passed in telemetry client
       * The sender does no telemetry level checks as those are done by the reporter.
       * @param eventName The name of the event to log
       * @param data The data contanied in the event
       */
      sendEventData(eventName, data) {
        if (!this._telemetryClient) {
          if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
            this._eventQueue.push({ eventName, data });
          }
          return;
        }
        this._telemetryClient.logEvent(eventName, data);
      }
      /**
       * Sends an exception to the passed in telemetry client
       * The sender does no telemetry level checks as those are done by the reporter.
       * @param exception The exception to collect
       * @param data Data associated with the exception
       */
      sendErrorData(exception, data) {
        if (!this._telemetryClient) {
          if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
            this._exceptionQueue.push({ exception, data });
          }
          return;
        }
        const errorData = { stack: exception.stack, message: exception.message, name: exception.name };
        if (data) {
          const errorProperties = data.properties || data;
          data.properties = { ...errorProperties, ...errorData };
        } else {
          data = { properties: errorData };
        }
        this._telemetryClient.logEvent("unhandlederror", data);
      }
      /**
       * Flushes the buffered telemetry data
       */
      async flush() {
        return this._telemetryClient?.flush();
      }
      async dispose() {
        if (this._telemetryClient) {
          await this._telemetryClient.dispose();
          this._telemetryClient = void 0;
        }
        return;
      }
      /**
       * Flushes the queued events that existed before the client was instantiated
       */
      _flushQueues() {
        this._eventQueue.forEach(({ eventName, data }) => this.sendEventData(eventName, data));
        this._eventQueue = [];
        this._exceptionQueue.forEach(({ exception, data }) => this.sendErrorData(exception, data));
        this._exceptionQueue = [];
      }
      /**
       * Instantiates the telemetry client to make the sender "active"
       */
      instantiateSender() {
        if (this._instantiationStatus !== InstantiationStatus.NOT_INSTANTIATED) {
          return;
        }
        this._instantiationStatus = InstantiationStatus.INSTANTIATING;
        this._clientFactory(this._key).then((client) => {
          this._telemetryClient = client;
          this._instantiationStatus = InstantiationStatus.INSTANTIATED;
          this._flushQueues();
        }).catch((err) => {
          console.error(err);
          this._instantiationStatus = InstantiationStatus.INSTANTIATED;
        });
      }
    };
    exports2.BaseTelemetrySender = BaseTelemetrySender;
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/node/telemetryReporter.js
var require_telemetryReporter = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/node/telemetryReporter.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var https = __importStar(require("https"));
    var os5 = __importStar(require("os"));
    var vscode22 = __importStar(require("vscode"));
    var _1dsClientFactory_1 = require_dsClientFactory();
    var appInsightsClientFactory_1 = require_appInsightsClientFactory();
    var baseTelemetryReporter_1 = require_baseTelemetryReporter();
    var baseTelemetrySender_1 = require_baseTelemetrySender();
    var util_1 = require_util();
    function getXHROverride() {
      const customHttpXHROverride = {
        sendPOST: (payload, oncomplete) => {
          const options = {
            method: "POST",
            headers: {
              ...payload.headers,
              "Content-Type": "application/json",
              "Content-Length": Buffer.byteLength(payload.data)
            }
          };
          try {
            const req = https.request(payload.urlString, options, (res) => {
              res.on("data", function(responseData) {
                oncomplete(res.statusCode ?? 200, res.headers, responseData.toString());
              });
              res.on("error", function() {
                oncomplete(0, {});
              });
            });
            req.write(payload.data, (err) => {
              if (err) {
                oncomplete(0, {});
              }
            });
            req.end();
          } catch {
            oncomplete(0, {});
          }
        }
      };
      return customHttpXHROverride;
    }
    var TelemetryReporter2 = class extends baseTelemetryReporter_1.BaseTelemetryReporter {
      constructor(connectionString, replacementOptions) {
        let clientFactory = (connectionString2) => (0, appInsightsClientFactory_1.appInsightsClientFactory)(connectionString2, vscode22.env.machineId, vscode22.env.sessionId, getXHROverride(), replacementOptions);
        if (util_1.TelemetryUtil.shouldUseOneDataSystemSDK(connectionString)) {
          clientFactory = (key) => (0, _1dsClientFactory_1.oneDataSystemClientFactory)(key, vscode22, getXHROverride());
        }
        const osShim = {
          release: os5.release(),
          platform: os5.platform(),
          architecture: os5.arch()
        };
        const sender = new baseTelemetrySender_1.BaseTelemetrySender(connectionString, clientFactory);
        if (connectionString && connectionString.indexOf("AIF-") === 0) {
          throw new Error("AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions");
        }
        super(sender, vscode22, { additionalCommonProperties: util_1.TelemetryUtil.getAdditionalCommonProperties(osShim) });
      }
    };
    exports2.default = TelemetryReporter2;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asPromise = exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
    function asPromise(value) {
      if (value instanceof Promise) {
        return value;
      } else if (thenable(value)) {
        return new Promise((resolve3, reject) => {
          value.then((resolved) => resolve3(resolved), (error2) => reject(error2));
        });
      } else {
        return Promise.resolve(value);
      }
    }
    exports2.asPromise = asPromise;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType03 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType03;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType6;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType22;
    var RequestType32 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType32;
    var RequestType42 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType42;
    var RequestType52 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType52;
    var RequestType62 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType62;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType7;
    var NotificationType02 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType02;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType22;
    var NotificationType32 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType32;
    var NotificationType42 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType42;
    var NotificationType52 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType52;
    var NotificationType62 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType62;
    var NotificationType72 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType72;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message2;
    (function(Message3) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message3.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message3.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message3.isResponse = isResponse;
    })(Message2 || (exports2.Message = Message2 = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable3;
    (function(Disposable4) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable4.create = create;
    })(Disposable3 || (exports2.Disposable = Disposable3 = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event2;
    (function(Event3) {
      const _disposable = { dispose() {
      } };
      Event3.None = function() {
        return _disposable;
      };
    })(Event2 || (exports2.Event = Event2 = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource2 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve3, reject) => {
          this._waiting.push({ thunk, resolve: resolve3, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger2 = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger2.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger2.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger2.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger2.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger2.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger2.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger2.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger2.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger2.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger2.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger2.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger2.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger2.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger2.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger2.error("Received empty message.");
          return;
        }
        logger2.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger2.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger2.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger2.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve3, reject) => {
            const resolveWithCleanup = (r) => {
              resolve3(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger2.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve3, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve3();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path11 = require("path");
    var os5 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process3) {
        super();
        this.process = process3;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process3) {
        super();
        this.process = process3;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path11.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path11.join(os5.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger2, options) {
      if (!logger2) {
        logger2 = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger2, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports3.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (exports3.URI = URI = {}));
      var integer2;
      (function(integer3) {
        integer3.MIN_VALUE = -2147483648;
        integer3.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer3.MIN_VALUE <= value && value <= integer3.MAX_VALUE;
        }
        integer3.is = is;
      })(integer2 || (exports3.integer = integer2 = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports3.uinteger = uinteger = {}));
      var Position3;
      (function(Position4) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position4.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position4.is = is;
      })(Position3 || (exports3.Position = Position3 = {}));
      var Range5;
      (function(Range6) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position3.create(one, two), end: Position3.create(three, four) };
          } else if (Position3.is(one) && Position3.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range6.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position3.is(candidate.start) && Position3.is(candidate.end);
        }
        Range6.is = is;
      })(Range5 || (exports3.Range = Range5 = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range5.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports3.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range5.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range5.is(candidate.targetSelectionRange) && (Range5.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports3.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports3.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range5.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports3.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit2.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit2.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports3.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports3.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports3.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location2, message) {
          return {
            location: location2,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports3.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports3.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports3.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range5.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports3.Diagnostic = Diagnostic = {}));
      var Command2;
      (function(Command3) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command3.is = is;
      })(Command2 || (exports3.Command = Command2 = {}));
      var TextEdit2;
      (function(TextEdit3) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit3.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit3.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit3.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range5.is(candidate.range);
        }
        TextEdit3.is = is;
      })(TextEdit2 || (exports3.TextEdit = TextEdit2 = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports3.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit2.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports3.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports3.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports3.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports3.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports3.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit2;
      (function(WorkspaceEdit3) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit3.is = is;
      })(WorkspaceEdit2 || (exports3.WorkspaceEdit = WorkspaceEdit2 = {}));
      var TextEditChangeImpl = (
        /** @class */
        function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit2.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit2.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit2.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }()
      );
      var ChangeAnnotations = (
        /** @class */
        function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }()
      );
      var WorkspaceChange = (
        /** @class */
        function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier2;
      (function(TextDocumentIdentifier3) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier3.is = is;
      })(TextDocumentIdentifier2 || (exports3.TextDocumentIdentifier = TextDocumentIdentifier2 = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports3.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports3.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports3.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports3.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports3.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports3.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range5.is(candidate.insert) && Range5.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports3.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports3.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports3.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports3.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports3.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range5.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports3.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports3.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports3.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports3.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports3.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports3.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports3.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports3.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports3.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range5.is(candidate.range) && Range5.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports3.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports3.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports3.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports3.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command2.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit2.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports3.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range5.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports3.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports3.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range5.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports3.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range5.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports3.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports3.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports3.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports3.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range5.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports3.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range5.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports3.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range5.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range5.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports3.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports3.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports3.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position3.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit2.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports3.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports3.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports3.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports3.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports3.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports3.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports3.WorkspaceFolder = WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument || (exports3.TextDocument = TextDocument = {}));
      var FullTextDocument = (
        /** @class */
        function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position3.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position3.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument2;
        }()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer3(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer3;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector3;
    (function(DocumentSelector4) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector4.is = is;
    })(DocumentSelector3 || (exports2.DocumentSelector = DocumentSelector3 = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector3.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports2.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger2, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger2, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger2, options) {
      return (0, node_1.createMessageConnection)(input, output, logger2, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/async.js
var require_async = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEach = exports2.mapAsync = exports2.map = exports2.clearTestMode = exports2.setTestMode = exports2.Semaphore = exports2.Delayer = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Delayer = class {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = void 0;
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
      }
      trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
          this.cancelTimeout();
        }
        if (!this.completionPromise) {
          this.completionPromise = new Promise((resolve3) => {
            this.onSuccess = resolve3;
          }).then(() => {
            this.completionPromise = void 0;
            this.onSuccess = void 0;
            var result = this.task();
            this.task = void 0;
            return result;
          });
        }
        if (delay >= 0 || this.timeout === void 0) {
          this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.timeout = void 0;
            this.onSuccess(void 0);
          }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
      }
      forceDelivery() {
        if (!this.completionPromise) {
          return void 0;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
        return result;
      }
      isTriggered() {
        return this.timeout !== void 0;
      }
      cancel() {
        this.cancelTimeout();
        this.completionPromise = void 0;
      }
      cancelTimeout() {
        if (this.timeout !== void 0) {
          this.timeout.dispose();
          this.timeout = void 0;
        }
      }
    };
    exports2.Delayer = Delayer;
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve3, reject) => {
          this._waiting.push({ thunk, resolve: resolve3, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
    var $test = false;
    function setTestMode() {
      $test = true;
    }
    exports2.setTestMode = setTestMode;
    function clearTestMode() {
      $test = false;
    }
    exports2.clearTestMode = clearTestMode;
    var defaultYieldTimeout = 15;
    var Timer = class {
      constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
      }
      start() {
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
        this.startTime = Date.now();
      }
      shouldYield() {
        if (++this.counter >= this.counterInterval) {
          const timeTaken = Date.now() - this.startTime;
          const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
          this.total += this.counter;
          this.counter = 0;
          if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
            this.counterInterval = 1;
            this.total = 0;
            return true;
          } else {
            switch (timeTaken) {
              case 0:
              case 1:
                this.counterInterval = this.total * 2;
                break;
            }
          }
        }
        return false;
      }
    };
    async function map(items, func, token, options) {
      if (items.length === 0) {
        return [];
      }
      const result = new Array(items.length);
      const timer = new Timer(options?.yieldAfter);
      function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
          result[i] = func(items[i]);
          if (timer.shouldYield()) {
            options?.yieldCallback && options.yieldCallback();
            return i + 1;
          }
        }
        return -1;
      }
      let index = convertBatch(0);
      while (index !== -1) {
        if (token !== void 0 && token.isCancellationRequested) {
          break;
        }
        index = await new Promise((resolve3) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            resolve3(convertBatch(index));
          });
        });
      }
      return result;
    }
    exports2.map = map;
    async function mapAsync(items, func, token, options) {
      if (items.length === 0) {
        return [];
      }
      const result = new Array(items.length);
      const timer = new Timer(options?.yieldAfter);
      async function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
          result[i] = await func(items[i], token);
          if (timer.shouldYield()) {
            options?.yieldCallback && options.yieldCallback();
            return i + 1;
          }
        }
        return -1;
      }
      let index = await convertBatch(0);
      while (index !== -1) {
        if (token !== void 0 && token.isCancellationRequested) {
          break;
        }
        index = await new Promise((resolve3) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            resolve3(convertBatch(index));
          });
        });
      }
      return result;
    }
    exports2.mapAsync = mapAsync;
    async function forEach(items, func, token, options) {
      if (items.length === 0) {
        return;
      }
      const timer = new Timer(options?.yieldAfter);
      function runBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
          func(items[i]);
          if (timer.shouldYield()) {
            options?.yieldCallback && options.yieldCallback();
            return i + 1;
          }
        }
        return -1;
      }
      let index = runBatch(0);
      while (index !== -1) {
        if (token !== void 0 && token.isCancellationRequested) {
          break;
        }
        index = await new Promise((resolve3) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            resolve3(runBatch(index));
          });
        });
      }
    }
    exports2.forEach = forEach;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js
var require_protocolCompletionItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCompletionItem = class extends code.CompletionItem {
      constructor(label) {
        super(label);
      }
    };
    exports2.default = ProtocolCompletionItem;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCodeLens.js
var require_protocolCodeLens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCodeLens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCodeLens = class extends code.CodeLens {
      constructor(range) {
        super(range);
      }
    };
    exports2.default = ProtocolCodeLens;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js
var require_protocolDocumentLink = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolDocumentLink = class extends code.DocumentLink {
      constructor(range, target) {
        super(range, target);
      }
    };
    exports2.default = ProtocolDocumentLink;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCodeAction.js
var require_protocolCodeAction = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCodeAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode22 = require("vscode");
    var ProtocolCodeAction = class extends vscode22.CodeAction {
      constructor(title, data) {
        super(title);
        this.data = data;
      }
    };
    exports2.default = ProtocolCodeAction;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js
var require_protocolDiagnostic = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolDiagnostic = exports2.DiagnosticCode = void 0;
    var vscode22 = require("vscode");
    var Is = require_is();
    var DiagnosticCode;
    (function(DiagnosticCode2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
      }
      DiagnosticCode2.is = is;
    })(DiagnosticCode || (exports2.DiagnosticCode = DiagnosticCode = {}));
    var ProtocolDiagnostic = class extends vscode22.Diagnostic {
      constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
      }
    };
    exports2.ProtocolDiagnostic = ProtocolDiagnostic;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js
var require_protocolCallHierarchyItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCallHierarchyItem = class extends code.CallHierarchyItem {
      constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports2.default = ProtocolCallHierarchyItem;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js
var require_protocolTypeHierarchyItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolTypeHierarchyItem = class extends code.TypeHierarchyItem {
      constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports2.default = ProtocolTypeHierarchyItem;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js
var require_protocolWorkspaceSymbol = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var WorkspaceSymbol = class extends code.SymbolInformation {
      constructor(name, kind, containerName, locationOrUri, data) {
        const hasRange = !(locationOrUri instanceof code.Uri);
        super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
        this.hasRange = hasRange;
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports2.default = WorkspaceSymbol;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolInlayHint.js
var require_protocolInlayHint = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolInlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolInlayHint = class extends code.InlayHint {
      constructor(position, label, kind) {
        super(position, label, kind);
      }
    };
    exports2.default = ProtocolInlayHint;
  }
});

// node_modules/vscode-languageclient/lib/common/codeConverter.js
var require_codeConverter = __commonJS({
  "node_modules/vscode-languageclient/lib/common/codeConverter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConverter = void 0;
    var code = require("vscode");
    var proto = require_main3();
    var Is = require_is();
    var async = require_async();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
    var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
    var protocolInlayHint_1 = require_protocolInlayHint();
    var InsertReplaceRange;
    (function(InsertReplaceRange2) {
      function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
      }
      InsertReplaceRange2.is = is;
    })(InsertReplaceRange || (InsertReplaceRange = {}));
    function createConverter(uriConverter) {
      const nullConverter = (value) => value.toString();
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri)
        };
      }
      function asTextDocumentItem(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri),
          languageId: textDocument.languageId,
          version: textDocument.version,
          text: textDocument.getText()
        };
      }
      function asVersionedTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri),
          version: textDocument.version
        };
      }
      function asOpenTextDocumentParams(textDocument) {
        return {
          textDocument: asTextDocumentItem(textDocument)
        };
      }
      function isTextDocumentChangeEvent(value) {
        const candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
      }
      function isTextDocument(value) {
        const candidate = value;
        return !!candidate.uri && !!candidate.version;
      }
      function asChangeTextDocumentParams(arg0, arg1, arg2) {
        if (isTextDocument(arg0)) {
          const result = {
            textDocument: {
              uri: _uriConverter(arg0.uri),
              version: arg0.version
            },
            contentChanges: [{ text: arg0.getText() }]
          };
          return result;
        } else if (isTextDocumentChangeEvent(arg0)) {
          const uri = arg1;
          const version = arg2;
          const result = {
            textDocument: {
              uri: _uriConverter(uri),
              version
            },
            contentChanges: arg0.contentChanges.map((change) => {
              const range = change.range;
              return {
                range: {
                  start: { line: range.start.line, character: range.start.character },
                  end: { line: range.end.line, character: range.end.character }
                },
                rangeLength: change.rangeLength,
                text: change.text
              };
            })
          };
          return result;
        } else {
          throw Error("Unsupported text document change parameter");
        }
      }
      function asCloseTextDocumentParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
          result.text = textDocument.getText();
        }
        return result;
      }
      function asTextDocumentSaveReason(reason) {
        switch (reason) {
          case code.TextDocumentSaveReason.Manual:
            return proto.TextDocumentSaveReason.Manual;
          case code.TextDocumentSaveReason.AfterDelay:
            return proto.TextDocumentSaveReason.AfterDelay;
          case code.TextDocumentSaveReason.FocusOut:
            return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
      }
      function asWillSaveTextDocumentParams(event) {
        return {
          textDocument: asTextDocumentIdentifier(event.document),
          reason: asTextDocumentSaveReason(event.reason)
        };
      }
      function asDidCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asDidRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asDidDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asWillDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asTextDocumentPositionParams(textDocument, position) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position)
        };
      }
      function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.CompletionTriggerKind.TriggerCharacter:
            return proto.CompletionTriggerKind.TriggerCharacter;
          case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
            return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
          default:
            return proto.CompletionTriggerKind.Invoked;
        }
      }
      function asCompletionParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            triggerKind: asCompletionTriggerKind(context.triggerKind),
            triggerCharacter: context.triggerCharacter
          }
        };
      }
      function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.SignatureHelpTriggerKind.Invoke:
            return proto.SignatureHelpTriggerKind.Invoked;
          case code.SignatureHelpTriggerKind.TriggerCharacter:
            return proto.SignatureHelpTriggerKind.TriggerCharacter;
          case code.SignatureHelpTriggerKind.ContentChange:
            return proto.SignatureHelpTriggerKind.ContentChange;
        }
      }
      function asParameterInformation(value) {
        return {
          label: value.label
        };
      }
      function asParameterInformations(values) {
        return values.map(asParameterInformation);
      }
      function asSignatureInformation(value) {
        return {
          label: value.label,
          parameters: asParameterInformations(value.parameters)
        };
      }
      function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
      }
      function asSignatureHelp(value) {
        if (value === void 0) {
          return value;
        }
        return {
          signatures: asSignatureInformations(value.signatures),
          activeSignature: value.activeSignature,
          activeParameter: value.activeParameter
        };
      }
      function asSignatureHelpParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            isRetrigger: context.isRetrigger,
            triggerCharacter: context.triggerCharacter,
            triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
            activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
          }
        };
      }
      function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
      }
      function asPosition2(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
      }
      function asPositions(values, token) {
        return async.map(values, asPosition2, token);
      }
      function asPositionsSync(values) {
        return values.map(asPosition2);
      }
      function asRange2(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { start: asPosition2(value.start), end: asPosition2(value.end) };
      }
      function asRanges(values) {
        return values.map(asRange2);
      }
      function asLocation(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return proto.Location.create(asUri(value.uri), asRange2(value.range));
      }
      function asDiagnosticSeverity(value) {
        switch (value) {
          case code.DiagnosticSeverity.Error:
            return proto.DiagnosticSeverity.Error;
          case code.DiagnosticSeverity.Warning:
            return proto.DiagnosticSeverity.Warning;
          case code.DiagnosticSeverity.Information:
            return proto.DiagnosticSeverity.Information;
          case code.DiagnosticSeverity.Hint:
            return proto.DiagnosticSeverity.Hint;
        }
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case code.DiagnosticTag.Unnecessary:
            return proto.DiagnosticTag.Unnecessary;
          case code.DiagnosticTag.Deprecated:
            return proto.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asRelatedInformation(item) {
        return {
          message: item.message,
          location: asLocation(item.location)
        };
      }
      function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
      }
      function asDiagnosticCode(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        if (Is.number(value) || Is.string(value)) {
          return value;
        }
        return { value: value.value, target: asUri(value.target) };
      }
      function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange2(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
        if (protocolDiagnostic !== void 0 && protocolDiagnostic.data !== void 0) {
          result.data = protocolDiagnostic.data;
        }
        const code2 = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code2)) {
          if (protocolDiagnostic !== void 0 && protocolDiagnostic.hasDiagnosticCode) {
            result.code = code2;
          } else {
            result.code = code2.value;
            result.codeDescription = { href: code2.target };
          }
        } else {
          result.code = code2;
        }
        if (Is.number(item.severity)) {
          result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
          result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
          result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
          result.source = item.source;
        }
        return result;
      }
      function asDiagnostics(items, token) {
        if (items === void 0 || items === null) {
          return items;
        }
        return async.map(items, asDiagnostic, token);
      }
      function asDiagnosticsSync(items) {
        if (items === void 0 || items === null) {
          return items;
        }
        return items.map(asDiagnostic);
      }
      function asDocumentation(format, documentation) {
        switch (format) {
          case "$string":
            return documentation;
          case proto.MarkupKind.PlainText:
            return { kind: format, value: documentation };
          case proto.MarkupKind.Markdown:
            return { kind: format, value: documentation.value };
          default:
            return `Unsupported Markup content received. Kind is: ${format}`;
        }
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case code.CompletionItemTag.Deprecated:
            return proto.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0) {
          return tags;
        }
        const result = [];
        for (let tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItemKind(value, original) {
        if (original !== void 0) {
          return original;
        }
        return value + 1;
      }
      function asCompletionItem(item, labelDetailsSupport = false) {
        let label;
        let labelDetails;
        if (Is.string(item.label)) {
          label = item.label;
        } else {
          label = item.label.label;
          if (labelDetailsSupport && (item.label.detail !== void 0 || item.label.description !== void 0)) {
            labelDetails = { detail: item.label.detail, description: item.label.description };
          }
        }
        let result = { label };
        if (labelDetails !== void 0) {
          result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          if (!protocolItem || protocolItem.documentationFormat === "$string") {
            result.documentation = item.documentation;
          } else {
            result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
          }
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
          result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
          result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
          if (protocolItem.data !== void 0) {
            result.data = protocolItem.data;
          }
          if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
            if (protocolItem.deprecated === true && tags !== void 0 && tags.length > 0) {
              const index = tags.indexOf(code.CompletionItemTag.Deprecated);
              if (index !== -1) {
                tags.splice(index, 1);
              }
            }
            result.deprecated = protocolItem.deprecated;
          }
          if (protocolItem.insertTextMode !== void 0) {
            result.insertTextMode = protocolItem.insertTextMode;
          }
        }
        if (tags !== void 0 && tags.length > 0) {
          result.tags = tags;
        }
        if (result.insertTextMode === void 0 && item.keepWhitespace === true) {
          result.insertTextMode = proto.InsertTextMode.adjustIndentation;
        }
        return result;
      }
      function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = void 0;
        let range = void 0;
        if (source.textEdit) {
          text = source.textEdit.newText;
          range = source.textEdit.range;
        } else if (source.insertText instanceof code.SnippetString) {
          format = proto.InsertTextFormat.Snippet;
          text = source.insertText.value;
        } else {
          text = source.insertText;
        }
        if (source.range) {
          range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== void 0 && range !== void 0) {
          target.textEdit = asCompletionTextEdit(text, range);
        } else {
          target.insertText = text;
        }
      }
      function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
          return proto.InsertReplaceEdit.create(newText, asRange2(range.inserting), asRange2(range.replacing));
        } else {
          return { newText, range: asRange2(range) };
        }
      }
      function asTextEdit(edit) {
        return { range: asRange2(edit.range), newText: edit.newText };
      }
      function asTextEdits(edits) {
        if (edits === void 0 || edits === null) {
          return edits;
        }
        return edits.map(asTextEdit);
      }
      function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
          return item + 1;
        }
        return proto.SymbolKind.Property;
      }
      function asSymbolTag(item) {
        return item;
      }
      function asSymbolTags(items) {
        return items.map(asSymbolTag);
      }
      function asReferenceParams(textDocument, position, options) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: { includeDeclaration: options.includeDeclaration }
        };
      }
      async function asCodeAction(item, token) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = await asDiagnostics(item.diagnostics, token);
        }
        if (item.edit !== void 0) {
          throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeActionSync(item) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnosticsSync(item.diagnostics);
        }
        if (item.edit !== void 0) {
          throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      async function asCodeActionContext(context, token) {
        if (context === void 0 || context === null) {
          return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
          only = [context.only.value];
        }
        return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
      }
      function asCodeActionContextSync(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
          only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnosticsSync(context.diagnostics), only, asCodeActionTriggerKind(context.triggerKind));
      }
      function asCodeActionTriggerKind(kind) {
        switch (kind) {
          case code.CodeActionTriggerKind.Invoke:
            return proto.CodeActionTriggerKind.Invoked;
          case code.CodeActionTriggerKind.Automatic:
            return proto.CodeActionTriggerKind.Automatic;
          default:
            return void 0;
        }
      }
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        return item.value;
      }
      function asInlineValueContext(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        return proto.InlineValueContext.create(context.frameId, asRange2(context.stoppedLocation));
      }
      function asInlineCompletionParams(document, position, context) {
        return {
          context: proto.InlineCompletionContext.create(context.triggerKind, context.selectedCompletionInfo),
          textDocument: asTextDocumentIdentifier(document),
          position: asPosition2(position)
        };
      }
      function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange2(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
          if (item.data) {
            result.data = item.data;
          }
        }
        return result;
      }
      function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
          result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
          result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
          result.insertFinalNewline = true;
        }
        return result;
      }
      function asDocumentSymbolParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCodeLensParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange2(item.range));
        if (item.target) {
          result.target = asUri(item.target);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
        if (protocolItem && protocolItem.data) {
          result.data = protocolItem.data;
        }
        return result;
      }
      function asDocumentLinkParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCallHierarchyItem(value) {
        const result = {
          name: value.name,
          kind: asSymbolKind(value.kind),
          uri: asUri(value.uri),
          range: asRange2(value.range),
          selectionRange: asRange2(value.selectionRange)
        };
        if (value.detail !== void 0 && value.detail.length > 0) {
          result.detail = value.detail;
        }
        if (value.tags !== void 0) {
          result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asTypeHierarchyItem(value) {
        const result = {
          name: value.name,
          kind: asSymbolKind(value.kind),
          uri: asUri(value.uri),
          range: asRange2(value.range),
          selectionRange: asRange2(value.selectionRange)
        };
        if (value.detail !== void 0 && value.detail.length > 0) {
          result.detail = value.detail;
        }
        if (value.tags !== void 0) {
          result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asWorkspaceSymbol(item) {
        const result = item instanceof protocolWorkspaceSymbol_1.default ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data } : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        if (item.containerName !== "") {
          result.containerName = item.containerName;
        }
        return result;
      }
      function asInlayHint(item) {
        const label = typeof item.label === "string" ? item.label : item.label.map(asInlayHintLabelPart);
        const result = proto.InlayHint.create(asPosition2(item.position), label);
        if (item.kind !== void 0) {
          result.kind = item.kind;
        }
        if (item.textEdits !== void 0) {
          result.textEdits = asTextEdits(item.textEdits);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = asTooltip(item.tooltip);
        }
        if (item.paddingLeft !== void 0) {
          result.paddingLeft = item.paddingLeft;
        }
        if (item.paddingRight !== void 0) {
          result.paddingRight = item.paddingRight;
        }
        if (item instanceof protocolInlayHint_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        return result;
      }
      function asInlayHintLabelPart(item) {
        const result = proto.InlayHintLabelPart.create(item.value);
        if (item.location !== void 0) {
          result.location = asLocation(item.location);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = asTooltip(item.tooltip);
        }
        return result;
      }
      function asTooltip(value) {
        if (typeof value === "string") {
          return value;
        }
        const result = {
          kind: proto.MarkupKind.Markdown,
          value: value.value
        };
        return result;
      }
      return {
        asUri,
        asTextDocumentIdentifier,
        asTextDocumentItem,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange: asRange2,
        asRanges,
        asPosition: asPosition2,
        asPositions,
        asPositionsSync,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asDiagnosticsSync,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionSync,
        asCodeActionContext,
        asCodeActionContextSync,
        asInlineValueContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem,
        asTypeHierarchyItem,
        asInlayHint,
        asWorkspaceSymbol,
        asInlineCompletionParams
      };
    }
    exports2.createConverter = createConverter;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolConverter.js
var require_protocolConverter = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolConverter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConverter = void 0;
    var code = require("vscode");
    var ls = require_main3();
    var Is = require_is();
    var async = require_async();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
    var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
    var protocolInlayHint_1 = require_protocolInlayHint();
    var vscode_languageserver_protocol_1 = require_main3();
    var CodeBlock;
    (function(CodeBlock2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
      }
      CodeBlock2.is = is;
    })(CodeBlock || (CodeBlock = {}));
    function createConverter(uriConverter, trustMarkdown, supportHtml) {
      const nullConverter = (value) => code.Uri.parse(value);
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asDocumentSelector(selector) {
        const result = [];
        for (const filter of selector) {
          if (typeof filter === "string") {
            result.push(filter);
          } else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
            if (typeof filter.notebook === "string") {
              result.push({ notebookType: filter.notebook, language: filter.language });
            } else {
              const notebookType = filter.notebook.notebookType ?? "*";
              result.push({ notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
            }
          } else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
            result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
          }
        }
        return result;
      }
      async function asDiagnostics(diagnostics, token) {
        return async.map(diagnostics, asDiagnostic, token);
      }
      function asDiagnosticsSync(diagnostics) {
        const result = new Array(diagnostics.length);
        for (let i = 0; i < diagnostics.length; i++) {
          result[i] = asDiagnostic(diagnostics[i]);
        }
        return result;
      }
      function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange2(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== void 0) {
          if (typeof diagnostic.code === "string" || typeof diagnostic.code === "number") {
            if (ls.CodeDescription.is(diagnostic.codeDescription)) {
              result.code = {
                value: diagnostic.code,
                target: asUri(diagnostic.codeDescription.href)
              };
            } else {
              result.code = diagnostic.code;
            }
          } else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
            result.hasDiagnosticCode = true;
            const diagnosticCode = diagnostic.code;
            result.code = {
              value: diagnosticCode.value,
              target: asUri(diagnosticCode.target)
            };
          }
        }
        if (diagnostic.source) {
          result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
          result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
          result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
      }
      function asRelatedInformation(relatedInformation) {
        const result = new Array(relatedInformation.length);
        for (let i = 0; i < relatedInformation.length; i++) {
          const info = relatedInformation[i];
          result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
        }
        return result;
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case ls.DiagnosticTag.Unnecessary:
            return code.DiagnosticTag.Unnecessary;
          case ls.DiagnosticTag.Deprecated:
            return code.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asPosition2(value) {
        return value ? new code.Position(value.line, value.character) : void 0;
      }
      function asRange2(value) {
        return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : void 0;
      }
      async function asRanges(items, token) {
        return async.map(items, (range) => {
          return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
        }, token);
      }
      function asDiagnosticSeverity(value) {
        if (value === void 0 || value === null) {
          return code.DiagnosticSeverity.Error;
        }
        switch (value) {
          case ls.DiagnosticSeverity.Error:
            return code.DiagnosticSeverity.Error;
          case ls.DiagnosticSeverity.Warning:
            return code.DiagnosticSeverity.Warning;
          case ls.DiagnosticSeverity.Information:
            return code.DiagnosticSeverity.Information;
          case ls.DiagnosticSeverity.Hint:
            return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
      }
      function asHoverContent(value) {
        if (Is.string(value)) {
          return asMarkdownString(value);
        } else if (CodeBlock.is(value)) {
          let result = asMarkdownString();
          return result.appendCodeblock(value.value, value.language);
        } else if (Array.isArray(value)) {
          let result = [];
          for (let element of value) {
            let item = asMarkdownString();
            if (CodeBlock.is(element)) {
              item.appendCodeblock(element.value, element.language);
            } else {
              item.appendMarkdown(element);
            }
            result.push(item);
          }
          return result;
        } else {
          return asMarkdownString(value);
        }
      }
      function asDocumentation(value) {
        if (Is.string(value)) {
          return value;
        } else {
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              return asMarkdownString(value.value);
            case ls.MarkupKind.PlainText:
              return value.value;
            default:
              return `Unsupported Markup content received. Kind is: ${value.kind}`;
          }
        }
      }
      function asMarkdownString(value) {
        let result;
        if (value === void 0 || typeof value === "string") {
          result = new code.MarkdownString(value);
        } else {
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              result = new code.MarkdownString(value.value);
              break;
            case ls.MarkupKind.PlainText:
              result = new code.MarkdownString();
              result.appendText(value.value);
              break;
            default:
              result = new code.MarkdownString();
              result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
              break;
          }
        }
        result.isTrusted = trustMarkdown;
        result.supportHtml = supportHtml;
        return result;
      }
      function asHover(hover) {
        if (!hover) {
          return void 0;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange2(hover.range));
      }
      async function asCompletionResult(value, allCommitCharacters, token) {
        if (!value) {
          return void 0;
        }
        if (Array.isArray(value)) {
          return async.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
        }
        const list = value;
        const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
        const converted = await async.map(list.items, (item) => {
          return asCompletionItem(item, commitCharacters, defaultRange, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat, list.itemDefaults?.data);
        }, token);
        return new code.CompletionList(converted, list.isIncomplete);
      }
      function getCompletionItemDefaults(list, allCommitCharacters) {
        const rangeDefaults = list.itemDefaults?.editRange;
        const commitCharacters = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
        return ls.Range.is(rangeDefaults) ? { defaultRange: asRange2(rangeDefaults), commitCharacters } : rangeDefaults !== void 0 ? { defaultRange: { inserting: asRange2(rangeDefaults.insert), replacing: asRange2(rangeDefaults.replace) }, commitCharacters } : { defaultRange: void 0, commitCharacters };
      }
      function asCompletionItemKind(value) {
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
          return [value - 1, void 0];
        }
        return [code.CompletionItemKind.Text, value];
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case ls.CompletionItemTag.Deprecated:
            return code.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0 || tags === null) {
          return [];
        }
        const result = [];
        for (const tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
        const tags = asCompletionItemTags(item.tags);
        const label = asCompletionItemLabel(item);
        const result = new protocolCompletionItem_1.default(label);
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
          result.documentationFormat = Is.string(item.documentation) ? "$string" : item.documentation.kind;
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
        if (insertText) {
          result.insertText = insertText.text;
          result.range = insertText.range;
          result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
          let [itemKind, original] = asCompletionItemKind(item.kind);
          result.kind = itemKind;
          if (original) {
            result.originalItemKind = original;
          }
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
        }
        const commitCharacters = item.commitCharacters !== void 0 ? Is.stringArray(item.commitCharacters) ? item.commitCharacters : void 0 : defaultCommitCharacters;
        if (commitCharacters) {
          result.commitCharacters = commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
          result.deprecated = item.deprecated;
          if (item.deprecated === true) {
            tags.push(code.CompletionItemTag.Deprecated);
          }
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        const data = item.data ?? defaultData;
        if (data !== void 0) {
          result.data = data;
        }
        if (tags.length > 0) {
          result.tags = tags;
        }
        const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
        if (insertTextMode !== void 0) {
          result.insertTextMode = insertTextMode;
          if (insertTextMode === ls.InsertTextMode.asIs) {
            result.keepWhitespace = true;
          }
        }
        return result;
      }
      function asCompletionItemLabel(item) {
        if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
          return {
            label: item.label,
            detail: item.labelDetails.detail,
            description: item.labelDetails.description
          };
        } else {
          return item.label;
        }
      }
      function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
        const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
        if (item.textEdit !== void 0 || defaultRange !== void 0) {
          const [range, newText] = item.textEdit !== void 0 ? getCompletionRangeAndText(item.textEdit) : [defaultRange, item.textEditText ?? item.label];
          if (insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(newText), range, fromEdit: true };
          } else {
            return { text: newText, range, fromEdit: true };
          }
        } else if (item.insertText) {
          if (insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(item.insertText), fromEdit: false };
          } else {
            return { text: item.insertText, fromEdit: false };
          }
        } else {
          return void 0;
        }
      }
      function getCompletionRangeAndText(value) {
        if (ls.InsertReplaceEdit.is(value)) {
          return [{ inserting: asRange2(value.insert), replacing: asRange2(value.replace) }, value.newText];
        } else {
          return [asRange2(value.range), value.newText];
        }
      }
      function asTextEdit(edit) {
        if (!edit) {
          return void 0;
        }
        return new code.TextEdit(asRange2(edit.range), edit.newText);
      }
      async function asTextEdits(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asTextEdit, token);
      }
      function asTextEditsSync(items) {
        if (!items) {
          return void 0;
        }
        const result = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
          result[i] = asTextEdit(items[i]);
        }
        return result;
      }
      async function asSignatureHelp(item, token) {
        if (!item) {
          return void 0;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
          result.activeSignature = item.activeSignature;
        } else {
          result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
          result.activeParameter = item.activeParameter;
        } else {
          result.activeParameter = 0;
        }
        if (item.signatures) {
          result.signatures = await asSignatureInformations(item.signatures, token);
        }
        return result;
      }
      async function asSignatureInformations(items, token) {
        return async.mapAsync(items, asSignatureInformation, token);
      }
      async function asSignatureInformation(item, token) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== void 0) {
          result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== void 0) {
          result.parameters = await asParameterInformations(item.parameters, token);
        }
        if (item.activeParameter !== void 0) {
          result.activeParameter = item.activeParameter;
        }
        {
          return result;
        }
      }
      function asParameterInformations(items, token) {
        return async.map(items, asParameterInformation, token);
      }
      function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
        }
        return result;
      }
      function asLocation(item) {
        return item ? new code.Location(_uriConverter(item.uri), asRange2(item.range)) : void 0;
      }
      async function asDeclarationResult(item, token) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item, token);
      }
      async function asDefinitionResult(item, token) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item, token);
      }
      function asLocationLink(item) {
        if (!item) {
          return void 0;
        }
        let result = {
          targetUri: _uriConverter(item.targetUri),
          targetRange: asRange2(item.targetRange),
          originSelectionRange: asRange2(item.originSelectionRange),
          targetSelectionRange: asRange2(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
          throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
      }
      async function asLocationResult(item, token) {
        if (!item) {
          return void 0;
        }
        if (Is.array(item)) {
          if (item.length === 0) {
            return [];
          } else if (ls.LocationLink.is(item[0])) {
            const links = item;
            return async.map(links, asLocationLink, token);
          } else {
            const locations = item;
            return async.map(locations, asLocation, token);
          }
        } else if (ls.LocationLink.is(item)) {
          return [asLocationLink(item)];
        } else {
          return asLocation(item);
        }
      }
      async function asReferences(values, token) {
        if (!values) {
          return void 0;
        }
        return async.map(values, asLocation, token);
      }
      async function asDocumentHighlights(values, token) {
        if (!values) {
          return void 0;
        }
        return async.map(values, asDocumentHighlight, token);
      }
      function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange2(item.range));
        if (Is.number(item.kind)) {
          result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
      }
      function asDocumentHighlightKind(item) {
        switch (item) {
          case ls.DocumentHighlightKind.Text:
            return code.DocumentHighlightKind.Text;
          case ls.DocumentHighlightKind.Read:
            return code.DocumentHighlightKind.Read;
          case ls.DocumentHighlightKind.Write:
            return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
      }
      async function asSymbolInformations(values, token) {
        if (!values) {
          return void 0;
        }
        return async.map(values, asSymbolInformation, token);
      }
      function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
          return item - 1;
        }
        return code.SymbolKind.Property;
      }
      function asSymbolTag(value) {
        switch (value) {
          case ls.SymbolTag.Deprecated:
            return code.SymbolTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asSymbolTags(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        const result = [];
        for (const item of items) {
          const converted = asSymbolTag(item);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length === 0 ? void 0 : result;
      }
      function asSymbolInformation(item) {
        const data = item.data;
        const location2 = item.location;
        const result = location2.range === void 0 || data !== void 0 ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? "", location2.range === void 0 ? _uriConverter(location2.uri) : new code.Location(_uriConverter(item.location.uri), asRange2(location2.range)), data) : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? "", new code.Location(_uriConverter(item.location.uri), asRange2(location2.range)));
        fillTags(result, item);
        return result;
      }
      async function asDocumentSymbols(values, token) {
        if (values === void 0 || values === null) {
          return void 0;
        }
        return async.map(values, asDocumentSymbol, token);
      }
      function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange2(value.range), asRange2(value.selectionRange));
        fillTags(result, value);
        if (value.children !== void 0 && value.children.length > 0) {
          let children = [];
          for (let child of value.children) {
            children.push(asDocumentSymbol(child));
          }
          result.children = children;
        }
        return result;
      }
      function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
          if (!result.tags) {
            result.tags = [code.SymbolTag.Deprecated];
          } else {
            if (!result.tags.includes(code.SymbolTag.Deprecated)) {
              result.tags = result.tags.concat(code.SymbolTag.Deprecated);
            }
          }
        }
      }
      function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      async function asCommands(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asCommand, token);
      }
      const kindMapping = /* @__PURE__ */ new Map();
      kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
      kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
      kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
      kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
      kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
      kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
      kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
      kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = kindMapping.get(item);
        if (result) {
          return result;
        }
        let parts = item.split(".");
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
          result = result.append(part);
        }
        return result;
      }
      function asCodeActionKinds(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        return items.map((kind) => asCodeActionKind(kind));
      }
      async function asCodeAction(item, token) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnosticsSync(item.diagnostics);
        }
        if (item.edit !== void 0) {
          result.edit = await asWorkspaceEdit(item.edit, token);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeActionResult(items, token) {
        return async.mapAsync(items, async (item) => {
          if (ls.Command.is(item)) {
            return asCommand(item);
          } else {
            return asCodeAction(item, token);
          }
        }, token);
      }
      function asCodeLens(item) {
        if (!item) {
          return void 0;
        }
        let result = new protocolCodeLens_1.default(asRange2(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.data !== void 0 && item.data !== null) {
          result.data = item.data;
        }
        return result;
      }
      async function asCodeLenses(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asCodeLens, token);
      }
      async function asWorkspaceEdit(item, token) {
        if (!item) {
          return void 0;
        }
        const sharedMetadata = /* @__PURE__ */ new Map();
        if (item.changeAnnotations !== void 0) {
          const changeAnnotations = item.changeAnnotations;
          await async.forEach(Object.keys(changeAnnotations), (key) => {
            const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
            sharedMetadata.set(key, metaData);
          }, token);
        }
        const asMetadata = (annotation) => {
          if (annotation === void 0) {
            return void 0;
          } else {
            return sharedMetadata.get(annotation);
          }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
          const documentChanges = item.documentChanges;
          await async.forEach(documentChanges, (change) => {
            if (ls.CreateFile.is(change)) {
              result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.RenameFile.is(change)) {
              result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
            } else if (ls.DeleteFile.is(change)) {
              result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.TextDocumentEdit.is(change)) {
              const uri = _uriConverter(change.textDocument.uri);
              for (const edit of change.edits) {
                if (ls.AnnotatedTextEdit.is(edit)) {
                  result.replace(uri, asRange2(edit.range), edit.newText, asMetadata(edit.annotationId));
                } else {
                  result.replace(uri, asRange2(edit.range), edit.newText);
                }
              }
            } else {
              throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
            }
          }, token);
        } else if (item.changes) {
          const changes = item.changes;
          await async.forEach(Object.keys(changes), (key) => {
            result.set(_uriConverter(key), asTextEditsSync(changes[key]));
          }, token);
        }
        return result;
      }
      function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === void 0) {
          return void 0;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
      }
      function asDocumentLink(item) {
        let range = asRange2(item.range);
        let target = item.target ? asUri(item.target) : void 0;
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== void 0) {
          link.tooltip = item.tooltip;
        }
        if (item.data !== void 0 && item.data !== null) {
          link.data = item.data;
        }
        return link;
      }
      async function asDocumentLinks(items, token) {
        if (!items) {
          return void 0;
        }
        return async.map(items, asDocumentLink, token);
      }
      function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
      }
      function asColorInformation(ci) {
        return new code.ColorInformation(asRange2(ci.range), asColor(ci.color));
      }
      async function asColorInformations(colorInformation, token) {
        if (!colorInformation) {
          return void 0;
        }
        return async.map(colorInformation, asColorInformation, token);
      }
      function asColorPresentation(cp2) {
        let presentation = new code.ColorPresentation(cp2.label);
        presentation.additionalTextEdits = asTextEditsSync(cp2.additionalTextEdits);
        if (cp2.textEdit) {
          presentation.textEdit = asTextEdit(cp2.textEdit);
        }
        return presentation;
      }
      async function asColorPresentations(colorPresentations, token) {
        if (!colorPresentations) {
          return void 0;
        }
        return async.map(colorPresentations, asColorPresentation, token);
      }
      function asFoldingRangeKind(kind) {
        if (kind) {
          switch (kind) {
            case ls.FoldingRangeKind.Comment:
              return code.FoldingRangeKind.Comment;
            case ls.FoldingRangeKind.Imports:
              return code.FoldingRangeKind.Imports;
            case ls.FoldingRangeKind.Region:
              return code.FoldingRangeKind.Region;
          }
        }
        return void 0;
      }
      function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
      }
      async function asFoldingRanges(foldingRanges, token) {
        if (!foldingRanges) {
          return void 0;
        }
        return async.map(foldingRanges, asFoldingRange, token);
      }
      function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange2(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : void 0);
      }
      async function asSelectionRanges(selectionRanges, token) {
        if (!Array.isArray(selectionRanges)) {
          return [];
        }
        return async.map(selectionRanges, asSelectionRange, token);
      }
      function asInlineValue(inlineValue) {
        if (ls.InlineValueText.is(inlineValue)) {
          return new code.InlineValueText(asRange2(inlineValue.range), inlineValue.text);
        } else if (ls.InlineValueVariableLookup.is(inlineValue)) {
          return new code.InlineValueVariableLookup(asRange2(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
        } else {
          return new code.InlineValueEvaluatableExpression(asRange2(inlineValue.range), inlineValue.expression);
        }
      }
      async function asInlineValues(inlineValues, token) {
        if (!Array.isArray(inlineValues)) {
          return [];
        }
        return async.map(inlineValues, asInlineValue, token);
      }
      async function asInlayHint(value, token) {
        const label = typeof value.label === "string" ? value.label : await async.map(value.label, asInlayHintLabelPart, token);
        const result = new protocolInlayHint_1.default(asPosition2(value.position), label);
        if (value.kind !== void 0) {
          result.kind = value.kind;
        }
        if (value.textEdits !== void 0) {
          result.textEdits = await asTextEdits(value.textEdits, token);
        }
        if (value.tooltip !== void 0) {
          result.tooltip = asTooltip(value.tooltip);
        }
        if (value.paddingLeft !== void 0) {
          result.paddingLeft = value.paddingLeft;
        }
        if (value.paddingRight !== void 0) {
          result.paddingRight = value.paddingRight;
        }
        if (value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asInlayHintLabelPart(part) {
        const result = new code.InlayHintLabelPart(part.value);
        if (part.location !== void 0) {
          result.location = asLocation(part.location);
        }
        if (part.tooltip !== void 0) {
          result.tooltip = asTooltip(part.tooltip);
        }
        if (part.command !== void 0) {
          result.command = asCommand(part.command);
        }
        return result;
      }
      function asTooltip(value) {
        if (typeof value === "string") {
          return value;
        }
        return asMarkdownString(value);
      }
      async function asInlayHints(values, token) {
        if (!Array.isArray(values)) {
          return void 0;
        }
        return async.mapAsync(values, asInlayHint, token);
      }
      function asCallHierarchyItem(item) {
        if (item === null) {
          return void 0;
        }
        const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange2(item.range), asRange2(item.selectionRange), item.data);
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        return result;
      }
      async function asCallHierarchyItems(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.map(items, asCallHierarchyItem, token);
      }
      async function asCallHierarchyIncomingCall(item, token) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
      }
      async function asCallHierarchyIncomingCalls(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.mapAsync(items, asCallHierarchyIncomingCall, token);
      }
      async function asCallHierarchyOutgoingCall(item, token) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
      }
      async function asCallHierarchyOutgoingCalls(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
      }
      async function asSemanticTokens(value, _token) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
      }
      function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
      }
      async function asSemanticTokensEdits(value, _token) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
      }
      function asSemanticTokensLegend(value) {
        return value;
      }
      async function asLinkedEditingRanges(value, token) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
      }
      function asRegularExpression(value) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new RegExp(value);
      }
      function asTypeHierarchyItem(item) {
        if (item === null) {
          return void 0;
        }
        let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange2(item.range), asRange2(item.selectionRange), item.data);
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        return result;
      }
      async function asTypeHierarchyItems(items, token) {
        if (items === null) {
          return void 0;
        }
        return async.map(items, asTypeHierarchyItem, token);
      }
      function asGlobPattern(pattern) {
        if (Is.string(pattern)) {
          return pattern;
        }
        if (ls.RelativePattern.is(pattern)) {
          if (ls.URI.is(pattern.baseUri)) {
            return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
          } else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
            const workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
            return workspaceFolder !== void 0 ? new code.RelativePattern(workspaceFolder, pattern.pattern) : void 0;
          }
        }
        return void 0;
      }
      async function asInlineCompletionResult(value, token) {
        if (!value) {
          return void 0;
        }
        if (Array.isArray(value)) {
          return async.map(value, (item) => asInlineCompletionItem(item), token);
        }
        const list = value;
        const converted = await async.map(list.items, (item) => {
          return asInlineCompletionItem(item);
        }, token);
        return new code.InlineCompletionList(converted);
      }
      function asInlineCompletionItem(item) {
        let insertText;
        if (typeof item.insertText === "string") {
          insertText = item.insertText;
        } else {
          insertText = new code.SnippetString(item.insertText.value);
        }
        let command = void 0;
        if (item.command) {
          command = asCommand(item.command);
        }
        const inlineCompletionItem = new code.InlineCompletionItem(insertText, asRange2(item.range), command);
        if (item.filterText) {
          inlineCompletionItem.filterText = item.filterText;
        }
        return inlineCompletionItem;
      }
      return {
        asUri,
        asDocumentSelector,
        asDiagnostics,
        asDiagnostic,
        asRange: asRange2,
        asRanges,
        asPosition: asPosition2,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeActionResult,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asInlineValue,
        asInlineValues,
        asInlayHint,
        asInlayHints,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges,
        asTypeHierarchyItem,
        asTypeHierarchyItems,
        asGlobPattern,
        asInlineCompletionResult,
        asInlineCompletionItem
      };
    }
    exports2.createConverter = createConverter;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v42() {
      return new V4UUID();
    }
    exports2.v4 = v42;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v42().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageclient/lib/common/progressPart.js
var require_progressPart = __commonJS({
  "node_modules/vscode-languageclient/lib/common/progressPart.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressPart = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ProgressPart = class {
      constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._infinite = false;
        this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done();
              done && done(this);
              break;
          }
        });
      }
      begin(params) {
        this._infinite = params.percentage === void 0;
        if (this._lspProgressDisposable === void 0) {
          return;
        }
        void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
          if (this._lspProgressDisposable === void 0) {
            return;
          }
          this._progress = progress;
          this._cancellationToken = cancellationToken;
          this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
            this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
          });
          this.report(params);
          return new Promise((resolve3, reject) => {
            this._resolve = resolve3;
            this._reject = reject;
          });
        });
      }
      report(params) {
        if (this._infinite && Is.string(params.message)) {
          this._progress !== void 0 && this._progress.report({ message: params.message });
        } else if (Is.number(params.percentage)) {
          const percentage = Math.max(0, Math.min(params.percentage, 100));
          const delta = Math.max(0, percentage - this._reported);
          this._reported += delta;
          this._progress !== void 0 && this._progress.report({ message: params.message, increment: delta });
        }
      }
      cancel() {
        this.cleanup();
        if (this._reject !== void 0) {
          this._reject();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      done() {
        this.cleanup();
        if (this._resolve !== void 0) {
          this._resolve();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      cleanup() {
        if (this._lspProgressDisposable !== void 0) {
          this._lspProgressDisposable.dispose();
          this._lspProgressDisposable = void 0;
        }
        if (this._tokenDisposable !== void 0) {
          this._tokenDisposable.dispose();
          this._tokenDisposable = void 0;
        }
        this._progress = void 0;
        this._cancellationToken = void 0;
      }
    };
    exports2.ProgressPart = ProgressPart;
  }
});

// node_modules/vscode-languageclient/lib/common/features.js
var require_features = __commonJS({
  "node_modules/vscode-languageclient/lib/common/features.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFeature = exports2.TextDocumentLanguageFeature = exports2.TextDocumentEventFeature = exports2.DynamicDocumentFeature = exports2.DynamicFeature = exports2.StaticFeature = exports2.ensure = exports2.LSPCancellationError = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var LSPCancellationError = class extends vscode_1.CancellationError {
      constructor(data) {
        super();
        this.data = data;
      }
    };
    exports2.LSPCancellationError = LSPCancellationError;
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    exports2.ensure = ensure;
    var StaticFeature;
    (function(StaticFeature2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.clear) && (candidate.fillInitializeParams === void 0 || Is.func(candidate.fillInitializeParams));
      }
      StaticFeature2.is = is;
    })(StaticFeature || (exports2.StaticFeature = StaticFeature = {}));
    var DynamicFeature;
    (function(DynamicFeature2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.clear) && (candidate.fillInitializeParams === void 0 || Is.func(candidate.fillInitializeParams)) && Is.func(candidate.register) && Is.func(candidate.unregister) && candidate.registrationType !== void 0;
      }
      DynamicFeature2.is = is;
    })(DynamicFeature || (exports2.DynamicFeature = DynamicFeature = {}));
    var DynamicDocumentFeature = class {
      constructor(client) {
        this._client = client;
      }
      /**
       * Returns the state the feature is in.
       */
      getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
          count++;
          for (const document of vscode_1.workspace.textDocuments) {
            if (vscode_1.languages.match(selector, document) > 0) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
        }
        const registrations = count > 0;
        return { kind: "document", id: this.registrationType.method, registrations, matches: false };
      }
    };
    exports2.DynamicDocumentFeature = DynamicDocumentFeature;
    var TextDocumentEventFeature = class extends DynamicDocumentFeature {
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (vscode_1.languages.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      constructor(client, event, type, middleware, createParams, textDocument, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._textDocument = textDocument;
        this._selectorFilter = selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
      }
      getStateInfo() {
        return [this._selectors.values(), false];
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event((data2) => {
            this.callback(data2).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed.`, error);
            });
          });
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
      }
      async callback(data) {
        const doSend = async (data2) => {
          const params = this._createParams(data2);
          await this._client.sendNotification(this._type, params);
          this.notificationSent(this.getTextDocument(data2), this._type, params);
        };
        if (this.matches(data)) {
          const middleware = this._middleware();
          return middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data);
        }
      }
      matches(data) {
        if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
          return false;
        }
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(textDocument, type, params) {
        this._onNotificationSent.fire({ textDocument, type, params });
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      clear() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document) {
        for (const selector of this._selectors.values()) {
          if (vscode_1.languages.match(selector, document) > 0) {
            return {
              send: (data) => {
                return this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    exports2.TextDocumentEventFeature = TextDocumentEventFeature;
    var TextDocumentLanguageFeature = class extends DynamicDocumentFeature {
      constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
          const selector = registration.data.registerOptions.documentSelector;
          if (selector === null) {
            continue;
          }
          yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
        }
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      clear() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector2, capability) {
        if (!capability) {
          return [void 0, void 0];
        } else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
          const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
          const selector = capability.documentSelector ?? documentSelector2;
          if (selector) {
            return [id, Object.assign({}, capability, { documentSelector: selector })];
          }
        } else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
          if (!documentSelector2) {
            return [void 0, void 0];
          }
          const options = Is.boolean(capability) && capability === true ? { documentSelector: documentSelector2 } : Object.assign({}, capability, { documentSelector: documentSelector2 });
          return [UUID.generateUuid(), options];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector2, capability) {
        if (!documentSelector2 || !capability) {
          return void 0;
        }
        return Is.boolean(capability) && capability === true ? { documentSelector: documentSelector2 } : Object.assign({}, capability, { documentSelector: documentSelector2 });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
    exports2.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
    var WorkspaceFeature = class {
      constructor(client, registrationType) {
        this._client = client;
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      getState() {
        const registrations = this._registrations.size > 0;
        return { kind: "workspace", id: this._registrationType.method, registrations };
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      clear() {
        this._registrations.forEach((registration) => {
          registration.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    exports2.WorkspaceFeature = WorkspaceFeature;
  }
});

// node_modules/vscode-languageclient/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/vscode-languageclient/node_modules/minimatch/lib/path.js"(exports2, module2) {
    var isWindows2 = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows2 ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/vscode-languageclient/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/vscode-languageclient/node_modules/minimatch/minimatch.js"(exports2, module2) {
    var minimatch = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch;
    var path11 = require_path();
    minimatch.sep = path11.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options) options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug) this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate) return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit) return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "") return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options.dot || dotTravAllowed;
        const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            /* istanbul ignore next */
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            // the various stateChar values
            // for the "extglob" stuff.
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1) c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext) clearStateChar();
              continue;
            case "(": {
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              const plEntry = {
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              };
              this.debug(this.pattern, "	", plEntry);
              patternListStack.push(plEntry);
              re += plEntry.open;
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            }
            case ")": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\)";
                continue;
              }
              patternListStack.pop();
              clearStateChar();
              hasMagic = true;
              pl = plEntry;
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(Object.assign(pl, { reEnd: re.length }));
              }
              continue;
            }
            case "|": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              continue;
            }
            // these are mostly the same in regexp and glob
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const closeParensBefore = nlBefore.split(")").length;
          const openParensBefore = nlBefore.split("(").length - closeParensBefore;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart() + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (options.nocase && !hasMagic) {
          hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate) re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) return false;
        if (this.empty) return f === "";
        if (f === "/" && partial) return true;
        const options = this.options;
        if (path11.sep !== "/") {
          f = f.split(path11.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename) break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) return true;
            return !this.negate;
          }
        }
        if (options.flipNegate) return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});

// node_modules/vscode-languageclient/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageclient/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = exports2.DiagnosticPullMode = exports2.vsdiag = void 0;
    var minimatch = require_minimatch();
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var features_1 = require_features();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var vsdiag;
    (function(vsdiag2) {
      let DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2["full"] = "full";
        DocumentDiagnosticReportKind2["unChanged"] = "unChanged";
      })(DocumentDiagnosticReportKind = vsdiag2.DocumentDiagnosticReportKind || (vsdiag2.DocumentDiagnosticReportKind = {}));
    })(vsdiag || (exports2.vsdiag = vsdiag = {}));
    var DiagnosticPullMode;
    (function(DiagnosticPullMode2) {
      DiagnosticPullMode2["onType"] = "onType";
      DiagnosticPullMode2["onSave"] = "onSave";
    })(DiagnosticPullMode || (exports2.DiagnosticPullMode = DiagnosticPullMode = {}));
    var RequestStateKind;
    (function(RequestStateKind2) {
      RequestStateKind2["active"] = "open";
      RequestStateKind2["reschedule"] = "reschedule";
      RequestStateKind2["outDated"] = "drop";
    })(RequestStateKind || (RequestStateKind = {}));
    var Tabs = class _Tabs {
      constructor() {
        this.open = /* @__PURE__ */ new Set();
        this._onOpen = new vscode_1.EventEmitter();
        this._onClose = new vscode_1.EventEmitter();
        _Tabs.fillTabResources(this.open);
        const openTabsHandler = (event) => {
          if (event.closed.length === 0 && event.opened.length === 0) {
            return;
          }
          const oldTabs = this.open;
          const currentTabs = /* @__PURE__ */ new Set();
          _Tabs.fillTabResources(currentTabs);
          const closed = /* @__PURE__ */ new Set();
          const opened = new Set(currentTabs);
          for (const tab of oldTabs.values()) {
            if (currentTabs.has(tab)) {
              opened.delete(tab);
            } else {
              closed.add(tab);
            }
          }
          this.open = currentTabs;
          if (closed.size > 0) {
            const toFire = /* @__PURE__ */ new Set();
            for (const item of closed) {
              toFire.add(vscode_1.Uri.parse(item));
            }
            this._onClose.fire(toFire);
          }
          if (opened.size > 0) {
            const toFire = /* @__PURE__ */ new Set();
            for (const item of opened) {
              toFire.add(vscode_1.Uri.parse(item));
            }
            this._onOpen.fire(toFire);
          }
        };
        if (vscode_1.window.tabGroups.onDidChangeTabs !== void 0) {
          this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);
        } else {
          this.disposable = { dispose: () => {
          } };
        }
      }
      get onClose() {
        return this._onClose.event;
      }
      get onOpen() {
        return this._onOpen.event;
      }
      dispose() {
        this.disposable.dispose();
      }
      isActive(document) {
        return document instanceof vscode_1.Uri ? vscode_1.window.activeTextEditor?.document.uri === document : vscode_1.window.activeTextEditor?.document === document;
      }
      isVisible(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.open.has(uri.toString());
      }
      getTabResources() {
        const result = /* @__PURE__ */ new Set();
        _Tabs.fillTabResources(/* @__PURE__ */ new Set(), result);
        return result;
      }
      static fillTabResources(strings, uris) {
        const seen = strings ?? /* @__PURE__ */ new Set();
        for (const group of vscode_1.window.tabGroups.all) {
          for (const tab of group.tabs) {
            const input = tab.input;
            let uri;
            if (input instanceof vscode_1.TabInputText) {
              uri = input.uri;
            } else if (input instanceof vscode_1.TabInputTextDiff) {
              uri = input.modified;
            } else if (input instanceof vscode_1.TabInputCustom) {
              uri = input.uri;
            }
            if (uri !== void 0 && !seen.has(uri.toString())) {
              seen.add(uri.toString());
              uris !== void 0 && uris.add(uri);
            }
          }
        }
      }
    };
    var PullState;
    (function(PullState2) {
      PullState2[PullState2["document"] = 1] = "document";
      PullState2[PullState2["workspace"] = 2] = "workspace";
    })(PullState || (PullState = {}));
    var DocumentOrUri;
    (function(DocumentOrUri2) {
      function asKey(document) {
        return document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
      }
      DocumentOrUri2.asKey = asKey;
    })(DocumentOrUri || (DocumentOrUri = {}));
    var DocumentPullStateTracker = class {
      constructor() {
        this.documentPullStates = /* @__PURE__ */ new Map();
        this.workspacePullStates = /* @__PURE__ */ new Map();
      }
      track(kind, document, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1] : [document.uri.toString(), document.uri, document.version];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId: void 0 };
          states.set(key, state);
        }
        return state;
      }
      update(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1, arg2] : [document.uri.toString(), document.uri, document.version, arg1];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId };
          states.set(key, state);
        } else {
          state.pulledVersion = version;
          state.resultId = resultId;
        }
      }
      unTrack(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
      }
      tracks(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
      }
      getResultId(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.get(key)?.resultId;
      }
      getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
          if (this.documentPullStates.has(uri)) {
            value = this.documentPullStates.get(uri);
          }
          if (value.resultId !== void 0) {
            result.push({ uri, value: value.resultId });
          }
        }
        return result;
      }
    };
    var DiagnosticRequestor = class {
      constructor(client, tabs, options) {
        this.client = client;
        this.tabs = tabs;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = /* @__PURE__ */ new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
      }
      knows(kind, document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.documentStates.tracks(kind, document) || this.openRequests.has(uri.toString());
      }
      forget(kind, document) {
        this.documentStates.unTrack(kind, document);
      }
      pull(document, cb) {
        if (this.isDisposed) {
          return;
        }
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        this.pullAsync(document).then(() => {
          if (cb) {
            cb();
          }
        }, (error) => {
          this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
        });
      }
      async pullAsync(document, version) {
        if (this.isDisposed) {
          return;
        }
        const isUri = document instanceof vscode_1.Uri;
        const uri = isUri ? document : document.uri;
        const key = uri.toString();
        version = isUri ? version : document.version;
        const currentRequestState = this.openRequests.get(key);
        const documentState = isUri ? this.documentStates.track(PullState.document, document, version) : this.documentStates.track(PullState.document, document);
        if (currentRequestState === void 0) {
          const tokenSource = new vscode_1.CancellationTokenSource();
          this.openRequests.set(key, { state: RequestStateKind.active, document, version, tokenSource });
          let report;
          let afterState;
          try {
            report = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
          } catch (error) {
            if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
              afterState = { state: RequestStateKind.outDated, document };
            }
            if (afterState === void 0 && error instanceof vscode_1.CancellationError) {
              afterState = { state: RequestStateKind.reschedule, document };
            } else {
              throw error;
            }
          }
          afterState = afterState ?? this.openRequests.get(key);
          if (afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
            this.diagnostics.delete(uri);
            return;
          }
          this.openRequests.delete(key);
          if (!this.tabs.isVisible(document)) {
            this.documentStates.unTrack(PullState.document, document);
            return;
          }
          if (afterState.state === RequestStateKind.outDated) {
            return;
          }
          if (report !== void 0) {
            if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              this.diagnostics.set(uri, report.items);
            }
            documentState.pulledVersion = version;
            documentState.resultId = report.resultId;
          }
          if (afterState.state === RequestStateKind.reschedule) {
            this.pull(document);
          }
        } else {
          if (currentRequestState.state === RequestStateKind.active) {
            currentRequestState.tokenSource.cancel();
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
          } else if (currentRequestState.state === RequestStateKind.outDated) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
          }
        }
      }
      forgetDocument(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        const key = uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics) {
          if (request !== void 0) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, document });
          } else {
            this.pull(document, () => {
              this.forget(PullState.document, document);
            });
          }
        } else {
          if (request !== void 0) {
            if (request.state === RequestStateKind.active) {
              request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document });
          }
          this.diagnostics.delete(uri);
          this.forget(PullState.document, document);
        }
      }
      pullWorkspace() {
        if (this.isDisposed) {
          return;
        }
        this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, 2e3);
        }, (error) => {
          if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
            this.client.error(`Workspace diagnostic pull failed.`, error, false);
            this.workspaceErrorCounter++;
          }
          if (this.workspaceErrorCounter <= 5) {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, 2e3);
          }
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
          return;
        }
        if (this.workspaceCancellation !== void 0) {
          this.workspaceCancellation.cancel();
          this.workspaceCancellation = void 0;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
          return {
            uri: this.client.protocol2CodeConverter.asUri(item.uri),
            value: item.value
          };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
          if (!chunk || this.isDisposed) {
            return;
          }
          for (const item of chunk.items) {
            if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              if (!this.documentStates.tracks(PullState.document, item.uri)) {
                this.diagnostics.set(item.uri, item.items);
              }
            }
            this.documentStates.update(PullState.workspace, item.uri, item.version ?? void 0, item.resultId);
          }
        });
      }
      createProvider() {
        const result = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: (document, previousResultId, token) => {
            const provideDiagnostics = (document2, previousResultId2, token2) => {
              const params = {
                identifier: this.options.identifier,
                textDocument: { uri: this.client.code2ProtocolConverter.asUri(document2 instanceof vscode_1.Uri ? document2 : document2.uri) },
                previousResultId: previousResultId2
              };
              if (this.isDisposed === true || !this.client.isRunning()) {
                return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
              }
              return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token2).then(async (result2) => {
                if (result2 === void 0 || result2 === null || this.isDisposed || token2.isCancellationRequested) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                }
                if (result2.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result2.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result2.items, token2) };
                } else {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result2.resultId };
                }
              }, (error) => {
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics) : provideDiagnostics(document, previousResultId, token);
          }
        };
        if (this.options.workspaceDiagnostics) {
          result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
            const convertReport = async (report) => {
              if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version,
                  items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                };
              } else {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version
                };
              }
            };
            const convertPreviousResultIds = (resultIds2) => {
              const converted = [];
              for (const item of resultIds2) {
                converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
              }
              return converted;
            };
            const provideDiagnostics = (resultIds2, token2) => {
              const partialResultToken = (0, uuid_1.generateUuid)();
              const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                if (partialResult === void 0 || partialResult === null) {
                  resultReporter(null);
                  return;
                }
                const converted = {
                  items: []
                };
                for (const item of partialResult.items) {
                  try {
                    converted.items.push(await convertReport(item));
                  } catch (error) {
                    this.client.error(`Converting workspace diagnostics failed.`, error);
                  }
                }
                resultReporter(converted);
              });
              const params = {
                identifier: this.options.identifier,
                previousResultIds: convertPreviousResultIds(resultIds2),
                partialResultToken
              };
              if (this.isDisposed === true || !this.client.isRunning()) {
                return { items: [] };
              }
              return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token2).then(async (result2) => {
                if (token2.isCancellationRequested) {
                  return { items: [] };
                }
                const converted = {
                  items: []
                };
                for (const item of result2.items) {
                  converted.items.push(await convertReport(item));
                }
                disposable.dispose();
                resultReporter(converted);
                return { items: [] };
              }, (error) => {
                disposable.dispose();
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { items: [] });
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token, resultReporter);
          };
        }
        return result;
      }
      dispose() {
        this.isDisposed = true;
        this.workspaceCancellation?.cancel();
        this.workspaceTimeout?.dispose();
        for (const [key, request] of this.openRequests) {
          if (request.state === RequestStateKind.active) {
            request.tokenSource.cancel();
          }
          this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
        }
        this.diagnostics.dispose();
      }
    };
    var BackgroundScheduler = class {
      constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
        this.isDisposed = false;
      }
      add(document) {
        if (this.isDisposed === true) {
          return;
        }
        const key = DocumentOrUri.asKey(document);
        if (this.documents.has(key)) {
          return;
        }
        this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
      }
      remove(document) {
        const key = DocumentOrUri.asKey(document);
        this.documents.delete(key);
        if (this.documents.size === 0) {
          this.stop();
        } else if (key === this.endDocumentKey()) {
          this.endDocument = this.documents.last;
        }
      }
      trigger() {
        if (this.isDisposed === true) {
          return;
        }
        if (this.intervalHandle !== void 0) {
          this.endDocument = this.documents.last;
          return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
          const document = this.documents.first;
          if (document !== void 0) {
            const key = DocumentOrUri.asKey(document);
            this.diagnosticRequestor.pull(document);
            this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
            if (key === this.endDocumentKey()) {
              this.stop();
            }
          }
        }, 200);
      }
      dispose() {
        this.isDisposed = true;
        this.stop();
        this.documents.clear();
      }
      stop() {
        this.intervalHandle?.dispose();
        this.intervalHandle = void 0;
        this.endDocument = void 0;
      }
      endDocumentKey() {
        return this.endDocument !== void 0 ? DocumentOrUri.asKey(this.endDocument) : void 0;
      }
    };
    var DiagnosticFeatureProviderImpl = class {
      constructor(client, tabs, options) {
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
        const documentSelector2 = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        const disposables = [];
        const matchResource = (resource) => {
          const selector = options.documentSelector;
          if (diagnosticPullOptions.match !== void 0) {
            return diagnosticPullOptions.match(selector, resource);
          }
          for (const filter of selector) {
            if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
              continue;
            }
            if (typeof filter === "string") {
              return false;
            }
            if (filter.language !== void 0 && filter.language !== "*") {
              return false;
            }
            if (filter.scheme !== void 0 && filter.scheme !== "*" && filter.scheme !== resource.scheme) {
              return false;
            }
            if (filter.pattern !== void 0) {
              const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
              if (!matcher.makeRe()) {
                return false;
              }
              if (!matcher.match(resource.fsPath)) {
                return false;
              }
            }
          }
          return true;
        };
        const matches = (document) => {
          return document instanceof vscode_1.Uri ? matchResource(document) : vscode_1.languages.match(documentSelector2, document) > 0 && tabs.isVisible(document);
        };
        const isActiveDocument = (document) => {
          return document instanceof vscode_1.Uri ? this.activeTextDocument?.uri.toString() === document.toString() : this.activeTextDocument === document;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document) => {
          if (!matches(document) || !options.interFileDependencies || isActiveDocument(document)) {
            return;
          }
          this.backgroundScheduler.add(document);
        };
        this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
          const oldActive = this.activeTextDocument;
          this.activeTextDocument = editor?.document;
          if (oldActive !== void 0) {
            addToBackgroundIfNeeded(oldActive);
          }
          if (this.activeTextDocument !== void 0) {
            this.backgroundScheduler.remove(this.activeTextDocument);
          }
        });
        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
          const textDocument = event.textDocument;
          if (this.diagnosticRequestor.knows(PullState.document, textDocument)) {
            return;
          }
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        disposables.push(tabs.onOpen((opened) => {
          for (const resource of opened) {
            if (this.diagnosticRequestor.knows(PullState.document, resource)) {
              continue;
            }
            const uriStr = resource.toString();
            let textDocument;
            for (const item of vscode_1.workspace.textDocuments) {
              if (uriStr === item.uri.toString()) {
                textDocument = item;
                break;
              }
            }
            if (textDocument !== void 0 && matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            }
          }
        }));
        const pulledTextDocuments = /* @__PURE__ */ new Set();
        for (const textDocument of vscode_1.workspace.textDocuments) {
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
            pulledTextDocuments.add(textDocument.uri.toString());
          }
        }
        if (diagnosticPullOptions.onTabs === true) {
          for (const resource of tabs.getTabResources()) {
            if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {
              this.diagnosticRequestor.pull(resource, () => {
                addToBackgroundIfNeeded(resource);
              });
            }
          }
        }
        if (diagnosticPullOptions.onChange === true) {
          const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async (event) => {
            const textDocument = event.textDocument;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        if (diagnosticPullOptions.onSave === true) {
          const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent((event) => {
            const textDocument = event.textDocument;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
              this.diagnosticRequestor.pull(event.textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
          this.cleanUpDocument(event.textDocument);
        }));
        tabs.onClose((closed) => {
          for (const document of closed) {
            this.cleanUpDocument(document);
          }
        });
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        });
        if (options.workspaceDiagnostics === true && options.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
          this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
      cleanUpDocument(document) {
        if (this.diagnosticRequestor.knows(PullState.document, document)) {
          this.diagnosticRequestor.forgetDocument(document);
          this.backgroundScheduler.remove(document);
        }
      }
    };
    var DiagnosticFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = false;
        ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeDiagnosticsEmitter.fire();
          }
        });
        let [id, options] = this.getRegistration(documentSelector2, capabilities.diagnosticProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      clear() {
        if (this.tabs !== void 0) {
          this.tabs.dispose();
          this.tabs = void 0;
        }
        super.clear();
      }
      registerLanguageProvider(options) {
        if (this.tabs === void 0) {
          this.tabs = new Tabs();
        }
        const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
        return [provider.disposable, provider];
      }
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageclient/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocumentSyncFeature = void 0;
    var vscode22 = require("vscode");
    var minimatch = require_minimatch();
    var proto = require_main3();
    var UUID = require_uuid();
    var Is = require_is();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var Converter;
    (function(Converter2) {
      let c2p;
      (function(c2p2) {
        function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
          return {
            version: notebookDocument.version,
            uri: base.asUri(notebookDocument.uri)
          };
        }
        c2p2.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
        function asNotebookDocument(notebookDocument, cells, base) {
          const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
          if (Object.keys(notebookDocument.metadata).length > 0) {
            result.metadata = asMetadata(notebookDocument.metadata);
          }
          return result;
        }
        c2p2.asNotebookDocument = asNotebookDocument;
        function asNotebookCells(cells, base) {
          return cells.map((cell) => asNotebookCell(cell, base));
        }
        c2p2.asNotebookCells = asNotebookCells;
        function asMetadata(metadata) {
          const seen = /* @__PURE__ */ new Set();
          return deepCopy(seen, metadata);
        }
        c2p2.asMetadata = asMetadata;
        function asNotebookCell(cell, base) {
          const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
          if (Object.keys(cell.metadata).length > 0) {
            result.metadata = asMetadata(cell.metadata);
          }
          if (cell.executionSummary !== void 0 && (Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success))) {
            result.executionSummary = {
              executionOrder: cell.executionSummary.executionOrder,
              success: cell.executionSummary.success
            };
          }
          return result;
        }
        c2p2.asNotebookCell = asNotebookCell;
        function asNotebookCellKind(kind) {
          switch (kind) {
            case vscode22.NotebookCellKind.Markup:
              return proto.NotebookCellKind.Markup;
            case vscode22.NotebookCellKind.Code:
              return proto.NotebookCellKind.Code;
          }
        }
        function deepCopy(seen, value) {
          if (seen.has(value)) {
            throw new Error(`Can't deep copy cyclic structures.`);
          }
          if (Array.isArray(value)) {
            const result = [];
            for (const elem of value) {
              if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                result.push(deepCopy(seen, elem));
              } else {
                if (elem instanceof RegExp) {
                  throw new Error(`Can't transfer regular expressions to the server`);
                }
                result.push(elem);
              }
            }
            return result;
          } else {
            const props = Object.keys(value);
            const result = /* @__PURE__ */ Object.create(null);
            for (const prop of props) {
              const elem = value[prop];
              if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                result[prop] = deepCopy(seen, elem);
              } else {
                if (elem instanceof RegExp) {
                  throw new Error(`Can't transfer regular expressions to the server`);
                }
                result[prop] = elem;
              }
            }
            return result;
          }
        }
        function asTextContentChange(event, base) {
          const params = base.asChangeTextDocumentParams(event, event.document.uri, event.document.version);
          return { document: params.textDocument, changes: params.contentChanges };
        }
        c2p2.asTextContentChange = asTextContentChange;
        function asNotebookDocumentChangeEvent(event, base) {
          const result = /* @__PURE__ */ Object.create(null);
          if (event.metadata) {
            result.metadata = Converter2.c2p.asMetadata(event.metadata);
          }
          if (event.cells !== void 0) {
            const cells = /* @__PURE__ */ Object.create(null);
            const changedCells = event.cells;
            if (changedCells.structure) {
              cells.structure = {
                array: {
                  start: changedCells.structure.array.start,
                  deleteCount: changedCells.structure.array.deleteCount,
                  cells: changedCells.structure.array.cells !== void 0 ? changedCells.structure.array.cells.map((cell) => Converter2.c2p.asNotebookCell(cell, base)) : void 0
                },
                didOpen: changedCells.structure.didOpen !== void 0 ? changedCells.structure.didOpen.map((cell) => base.asOpenTextDocumentParams(cell.document).textDocument) : void 0,
                didClose: changedCells.structure.didClose !== void 0 ? changedCells.structure.didClose.map((cell) => base.asCloseTextDocumentParams(cell.document).textDocument) : void 0
              };
            }
            if (changedCells.data !== void 0) {
              cells.data = changedCells.data.map((cell) => Converter2.c2p.asNotebookCell(cell, base));
            }
            if (changedCells.textContent !== void 0) {
              cells.textContent = changedCells.textContent.map((event2) => Converter2.c2p.asTextContentChange(event2, base));
            }
            if (Object.keys(cells).length > 0) {
              result.cells = cells;
            }
          }
          return result;
        }
        c2p2.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
      })(c2p = Converter2.c2p || (Converter2.c2p = {}));
    })(Converter || (Converter = {}));
    var $NotebookCell;
    (function($NotebookCell2) {
      function computeDiff(originalCells, modifiedCells, compareMetadata) {
        const originalLength = originalCells.length;
        const modifiedLength = modifiedCells.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          const deleteCount = originalEndIndex + 1 - startIndex;
          const newCells = startIndex === modifiedEndIndex + 1 ? void 0 : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
          return newCells !== void 0 ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
        } else if (startIndex < modifiedLength) {
          return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
        } else if (startIndex < originalLength) {
          return { start: startIndex, deleteCount: originalLength - startIndex };
        } else {
          return void 0;
        }
      }
      $NotebookCell2.computeDiff = computeDiff;
      function equals(one, other, compareMetaData = true) {
        if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId || !equalsExecution(one.executionSummary, other.executionSummary)) {
          return false;
        }
        return !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);
      }
      function equalsExecution(one, other) {
        if (one === other) {
          return true;
        }
        if (one === void 0 || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
      }
      function equalsTiming(one, other) {
        if (one === other) {
          return true;
        }
        if (one === void 0 || other === void 0) {
          return false;
        }
        return one.startTime === other.startTime && one.endTime === other.endTime;
      }
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (isObjectLiteral(one) && isObjectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function isObjectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      $NotebookCell2.isObjectLiteral = isObjectLiteral;
    })($NotebookCell || ($NotebookCell = {}));
    var $NotebookDocumentFilter;
    (function($NotebookDocumentFilter2) {
      function matchNotebook(filter, notebookDocument) {
        if (typeof filter === "string") {
          return filter === "*" || notebookDocument.notebookType === filter;
        }
        if (filter.notebookType !== void 0 && filter.notebookType !== "*" && notebookDocument.notebookType !== filter.notebookType) {
          return false;
        }
        const uri = notebookDocument.uri;
        if (filter.scheme !== void 0 && filter.scheme !== "*" && uri.scheme !== filter.scheme) {
          return false;
        }
        if (filter.pattern !== void 0) {
          const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
          if (!matcher.makeRe()) {
            return false;
          }
          if (!matcher.match(uri.fsPath)) {
            return false;
          }
        }
        return true;
      }
      $NotebookDocumentFilter2.matchNotebook = matchNotebook;
    })($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
    var $NotebookDocumentSyncOptions;
    (function($NotebookDocumentSyncOptions2) {
      function asDocumentSelector(options) {
        const selector = options.notebookSelector;
        const result = [];
        for (const element of selector) {
          const notebookType = (typeof element.notebook === "string" ? element.notebook : element.notebook?.notebookType) ?? "*";
          const scheme = typeof element.notebook === "string" ? void 0 : element.notebook?.scheme;
          const pattern = typeof element.notebook === "string" ? void 0 : element.notebook?.pattern;
          if (element.cells !== void 0) {
            for (const cell of element.cells) {
              result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
            }
          } else {
            result.push(asDocumentFilter(notebookType, scheme, pattern, void 0));
          }
        }
        return result;
      }
      $NotebookDocumentSyncOptions2.asDocumentSelector = asDocumentSelector;
      function asDocumentFilter(notebookType, scheme, pattern, language) {
        return scheme === void 0 && pattern === void 0 ? { notebook: notebookType, language } : { notebook: { notebookType, scheme, pattern }, language };
      }
    })($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
    var SyncInfo;
    (function(SyncInfo2) {
      function create(cells) {
        return {
          cells,
          uris: new Set(cells.map((cell) => cell.document.uri.toString()))
        };
      }
      SyncInfo2.create = create;
    })(SyncInfo || (SyncInfo = {}));
    var NotebookDocumentSyncFeatureProvider = class {
      constructor(client, options) {
        this.client = client;
        this.options = options;
        this.notebookSyncInfo = /* @__PURE__ */ new Map();
        this.notebookDidOpen = /* @__PURE__ */ new Set();
        this.disposables = [];
        this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
        vscode22.workspace.onDidOpenNotebookDocument((notebookDocument) => {
          this.notebookDidOpen.add(notebookDocument.uri.toString());
          this.didOpen(notebookDocument);
        }, void 0, this.disposables);
        for (const notebookDocument of vscode22.workspace.notebookDocuments) {
          this.notebookDidOpen.add(notebookDocument.uri.toString());
          this.didOpen(notebookDocument);
        }
        vscode22.workspace.onDidChangeNotebookDocument((event) => this.didChangeNotebookDocument(event), void 0, this.disposables);
        if (this.options.save === true) {
          vscode22.workspace.onDidSaveNotebookDocument((notebookDocument) => this.didSave(notebookDocument), void 0, this.disposables);
        }
        vscode22.workspace.onDidCloseNotebookDocument((notebookDocument) => {
          this.didClose(notebookDocument);
          this.notebookDidOpen.delete(notebookDocument.uri.toString());
        }, void 0, this.disposables);
      }
      getState() {
        for (const notebook of vscode22.workspace.notebookDocuments) {
          const matchingCells = this.getMatchingCells(notebook);
          if (matchingCells !== void 0) {
            return { kind: "document", id: "$internal", registrations: true, matches: true };
          }
        }
        return { kind: "document", id: "$internal", registrations: true, matches: false };
      }
      get mode() {
        return "notebook";
      }
      handles(textDocument) {
        return vscode22.languages.match(this.selector, textDocument) > 0;
      }
      didOpenNotebookCellTextDocument(notebookDocument, cell) {
        if (vscode22.languages.match(this.selector, cell.document) === 0) {
          return;
        }
        if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
          return;
        }
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        const cellMatches = this.cellMatches(notebookDocument, cell);
        if (syncInfo !== void 0) {
          const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
          if (cellMatches && cellIsSynced || !cellMatches && !cellIsSynced) {
            return;
          }
          if (cellMatches) {
            const matchingCells = this.getMatchingCells(notebookDocument);
            if (matchingCells !== void 0) {
              const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
              if (event !== void 0) {
                this.doSendChange(event, matchingCells).catch(() => {
                });
              }
            }
          }
        } else {
          if (cellMatches) {
            this.doSendOpen(notebookDocument, [cell]).catch(() => {
            });
          }
        }
      }
      didChangeNotebookCellTextDocument(notebookDocument, event) {
        if (vscode22.languages.match(this.selector, event.document) === 0) {
          return;
        }
        this.doSendChange({
          notebook: notebookDocument,
          cells: { textContent: [event] }
        }, void 0).catch(() => {
        });
      }
      didCloseNotebookCellTextDocument(notebookDocument, cell) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        const cellUri = cell.document.uri;
        const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
        if (index === -1) {
          return;
        }
        if (index === 0 && syncInfo.cells.length === 1) {
          this.doSendClose(notebookDocument, syncInfo.cells).catch(() => {
          });
        } else {
          const newCells = syncInfo.cells.slice();
          const deleted = newCells.splice(index, 1);
          this.doSendChange({
            notebook: notebookDocument,
            cells: {
              structure: {
                array: { start: index, deleteCount: 1 },
                didClose: deleted
              }
            }
          }, newCells).catch(() => {
          });
        }
      }
      dispose() {
        for (const disposable of this.disposables) {
          disposable.dispose();
        }
      }
      didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo !== void 0) {
          if (matchingCells !== void 0) {
            const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
            if (event !== void 0) {
              this.doSendChange(event, matchingCells).catch(() => {
              });
            }
          } else {
            this.doSendClose(notebookDocument, []).catch(() => {
            });
          }
        } else {
          if (matchingCells === void 0) {
            return;
          }
          this.doSendOpen(notebookDocument, matchingCells).catch(() => {
          });
        }
      }
      didChangeNotebookDocument(event) {
        const notebookDocument = event.notebook;
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          if (event.contentChanges.length === 0) {
            return;
          }
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            return;
          }
          this.didOpen(notebookDocument, cells, syncInfo);
        } else {
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            this.didClose(notebookDocument, syncInfo);
            return;
          }
          const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
          if (newEvent !== void 0) {
            this.doSendChange(newEvent, cells).catch(() => {
            });
          }
        }
      }
      didSave(notebookDocument) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        this.doSendSave(notebookDocument).catch(() => {
        });
      }
      didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo === void 0) {
          return;
        }
        const syncedCells = notebookDocument.getCells().filter((cell) => syncInfo.uris.has(cell.document.uri.toString()));
        this.doSendClose(notebookDocument, syncedCells).catch(() => {
        });
      }
      async sendDidOpenNotebookDocument(notebookDocument) {
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === void 0) {
          return;
        }
        return this.doSendOpen(notebookDocument, cells);
      }
      async doSendOpen(notebookDocument, cells) {
        const send = async (notebookDocument2, cells2) => {
          const nb = Converter.c2p.asNotebookDocument(notebookDocument2, cells2, this.client.code2ProtocolConverter);
          const cellDocuments = cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
          try {
            await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
              notebookDocument: nb,
              cellTextDocuments: cellDocuments
            });
          } catch (error) {
            this.client.error("Sending DidOpenNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
        return middleware?.didOpen !== void 0 ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
      }
      async sendDidChangeNotebookDocument(event) {
        return this.doSendChange(event, void 0);
      }
      async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
        const send = async (event2) => {
          try {
            await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
              notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event2.notebook, this.client.code2ProtocolConverter),
              change: Converter.c2p.asNotebookDocumentChangeEvent(event2, this.client.code2ProtocolConverter)
            });
          } catch (error) {
            this.client.error("Sending DidChangeNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        if (event.cells?.structure !== void 0) {
          this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
        }
        return middleware?.didChange !== void 0 ? middleware?.didChange(event, send) : send(event);
      }
      async sendDidSaveNotebookDocument(notebookDocument) {
        return this.doSendSave(notebookDocument);
      }
      async doSendSave(notebookDocument) {
        const send = async (notebookDocument2) => {
          try {
            await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
              notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) }
            });
          } catch (error) {
            this.client.error("Sending DidSaveNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        return middleware?.didSave !== void 0 ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
      }
      async sendDidCloseNotebookDocument(notebookDocument) {
        return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
      }
      async doSendClose(notebookDocument, cells) {
        const send = async (notebookDocument2, cells2) => {
          try {
            await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
              notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) },
              cellTextDocuments: cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
            });
          } catch (error) {
            this.client.error("Sending DidCloseNotebookDocumentNotification failed", error);
            throw error;
          }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.delete(notebookDocument.uri.toString());
        return middleware?.didClose !== void 0 ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
      }
      asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
        if (event !== void 0 && event.notebook !== notebook) {
          throw new Error("Notebook must be identical");
        }
        const result = {
          notebook
        };
        if (event?.metadata !== void 0) {
          result.metadata = Converter.c2p.asMetadata(event.metadata);
        }
        let matchingCellsSet;
        if (event?.cellChanges !== void 0 && event.cellChanges.length > 0) {
          const data = [];
          matchingCellsSet = new Set(matchingCells.map((cell) => cell.document.uri.toString()));
          for (const cellChange of event.cellChanges) {
            if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== void 0 || cellChange.metadata !== void 0)) {
              data.push(cellChange.cell);
            }
          }
          if (data.length > 0) {
            result.cells = result.cells ?? {};
            result.cells.data = data;
          }
        }
        if ((event?.contentChanges !== void 0 && event.contentChanges.length > 0 || event === void 0) && syncInfo !== void 0 && matchingCells !== void 0) {
          const oldCells = syncInfo.cells;
          const newCells = matchingCells;
          const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
          let addedCells;
          let removedCells;
          if (diff !== void 0) {
            addedCells = diff.cells === void 0 ? /* @__PURE__ */ new Map() : new Map(diff.cells.map((cell) => [cell.document.uri.toString(), cell]));
            removedCells = diff.deleteCount === 0 ? /* @__PURE__ */ new Map() : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map((cell) => [cell.document.uri.toString(), cell]));
            for (const key of Array.from(removedCells.keys())) {
              if (addedCells.has(key)) {
                removedCells.delete(key);
                addedCells.delete(key);
              }
            }
            result.cells = result.cells ?? {};
            const didOpen = [];
            const didClose = [];
            if (addedCells.size > 0 || removedCells.size > 0) {
              for (const cell of addedCells.values()) {
                didOpen.push(cell);
              }
              for (const cell of removedCells.values()) {
                didClose.push(cell);
              }
            }
            result.cells.structure = {
              array: diff,
              didOpen,
              didClose
            };
          }
        }
        return Object.keys(result).length > 1 ? result : void 0;
      }
      getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
        if (this.options.notebookSelector === void 0) {
          return void 0;
        }
        for (const item of this.options.notebookSelector) {
          if (item.notebook === void 0 || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
            const filtered = this.filterCells(notebookDocument, cells, item.cells);
            return filtered.length === 0 ? void 0 : filtered;
          }
        }
        return void 0;
      }
      cellMatches(notebookDocument, cell) {
        const cells = this.getMatchingCells(notebookDocument, [cell]);
        return cells !== void 0 && cells[0] === cell;
      }
      filterCells(notebookDocument, cells, cellSelector) {
        const filtered = cellSelector !== void 0 ? cells.filter((cell) => {
          const cellLanguage = cell.document.languageId;
          return cellSelector.some((filter) => filter.language === "*" || cellLanguage === filter.language);
        }) : cells;
        return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === "function" ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered) : filtered;
      }
    };
    var NotebookDocumentSyncFeature = class _NotebookDocumentSyncFeature {
      constructor(client) {
        this.client = client;
        this.registrations = /* @__PURE__ */ new Map();
        this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
        vscode22.workspace.onDidOpenTextDocument((textDocument) => {
          if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
          if (notebookDocument === void 0 || notebookCell === void 0) {
            return;
          }
          for (const provider of this.registrations.values()) {
            if (provider instanceof NotebookDocumentSyncFeatureProvider) {
              provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
            }
          }
        });
        vscode22.workspace.onDidChangeTextDocument((event) => {
          if (event.contentChanges.length === 0) {
            return;
          }
          const textDocument = event.document;
          if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument] = this.findNotebookDocumentAndCell(textDocument);
          if (notebookDocument === void 0) {
            return;
          }
          for (const provider of this.registrations.values()) {
            if (provider instanceof NotebookDocumentSyncFeatureProvider) {
              provider.didChangeNotebookCellTextDocument(notebookDocument, event);
            }
          }
        });
        vscode22.workspace.onDidCloseTextDocument((textDocument) => {
          if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
          if (notebookDocument === void 0 || notebookCell === void 0) {
            return;
          }
          for (const provider of this.registrations.values()) {
            if (provider instanceof NotebookDocumentSyncFeatureProvider) {
              provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
            }
          }
        });
      }
      getState() {
        if (this.registrations.size === 0) {
          return { kind: "document", id: this.registrationType.method, registrations: false, matches: false };
        }
        for (const provider of this.registrations.values()) {
          const state = provider.getState();
          if (state.kind === "document" && state.registrations === true && state.matches === true) {
            return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
          }
        }
        return { kind: "document", id: this.registrationType.method, registrations: true, matches: false };
      }
      fillClientCapabilities(capabilities) {
        const synchronization = ensure(ensure(capabilities, "notebookDocument"), "synchronization");
        synchronization.dynamicRegistration = true;
        synchronization.executionSummarySupport = true;
      }
      preInitialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === void 0) {
          return;
        }
        this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
      }
      initialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === void 0) {
          return;
        }
        const id = options.id ?? UUID.generateUuid();
        this.register({ id, registerOptions: options });
      }
      register(data) {
        const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
        this.registrations.set(data.id, provider);
      }
      unregister(id) {
        const provider = this.registrations.get(id);
        provider && provider.dispose();
      }
      clear() {
        for (const provider of this.registrations.values()) {
          provider.dispose();
        }
        this.registrations.clear();
      }
      handles(textDocument) {
        if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) {
          return false;
        }
        if (this.dedicatedChannel !== void 0 && vscode22.languages.match(this.dedicatedChannel, textDocument) > 0) {
          return true;
        }
        for (const provider of this.registrations.values()) {
          if (provider.handles(textDocument)) {
            return true;
          }
        }
        return false;
      }
      getProvider(notebookCell) {
        for (const provider of this.registrations.values()) {
          if (provider.handles(notebookCell.document)) {
            return provider;
          }
        }
        return void 0;
      }
      findNotebookDocumentAndCell(textDocument) {
        const uri = textDocument.uri.toString();
        for (const notebookDocument of vscode22.workspace.notebookDocuments) {
          for (const cell of notebookDocument.getCells()) {
            if (cell.document.uri.toString() === uri) {
              return [notebookDocument, cell];
            }
          }
        }
        return [void 0, void 0];
      }
    };
    exports2.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
    NotebookDocumentSyncFeature.CellScheme = "vscode-notebook-cell";
  }
});

// node_modules/vscode-languageclient/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageclient/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SyncConfigurationFeature = exports2.toJSONObject = exports2.ConfigurationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var features_1 = require_features();
    var ConfigurationFeature = class {
      constructor(client) {
        this._client = client;
      }
      getState() {
        return { kind: "static" };
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
      }
      initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
          let configuration = (params2) => {
            let result = [];
            for (let item of params2.items) {
              let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
              result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
            }
            return result;
          };
          let middleware = client.middleware.workspace;
          return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section) {
        let result = null;
        if (section) {
          let index = section.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));
          } else {
            let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
            if (config) {
              result = toJSONObject(config.get(section.substr(index + 1)));
            }
          }
        } else {
          let config = vscode_1.workspace.getConfiguration(void 0, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        if (result === void 0) {
          result = null;
        }
        return result;
      }
      clear() {
      }
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
    function toJSONObject(obj) {
      if (obj) {
        if (Array.isArray(obj)) {
          return obj.map(toJSONObject);
        } else if (typeof obj === "object") {
          const res = /* @__PURE__ */ Object.create(null);
          for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              res[key] = toJSONObject(obj[key]);
            }
          }
          return res;
        }
      }
      return obj;
    }
    exports2.toJSONObject = toJSONObject;
    var SyncConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this.isCleared = false;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        this.isCleared = false;
        let section = this._client.clientOptions.synchronize?.configurationSection;
        if (section !== void 0) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: {
              section
            }
          });
        }
      }
      register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
          this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== void 0) {
          this.onDidChangeConfiguration(data.registerOptions.section, void 0);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      clear() {
        for (const disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
        this.isCleared = true;
      }
      onDidChangeConfiguration(configurationSection, event) {
        if (this.isCleared) {
          return;
        }
        let sections;
        if (Is.string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
          let affected = sections.some((section) => event.affectsConfiguration(section));
          if (!affected) {
            return;
          }
        }
        const didChangeConfiguration = async (sections2) => {
          if (sections2 === void 0) {
            return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
          } else {
            return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections2) });
          }
        };
        let middleware = this._client.middleware.workspace?.didChangeConfiguration;
        (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
          this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
        });
      }
      extractSettingsInformation(keys) {
        function ensurePath(config, path11) {
          let current = config;
          for (let i = 0; i < path11.length - 1; i++) {
            let obj = current[path11[i]];
            if (!obj) {
              obj = /* @__PURE__ */ Object.create(null);
              current[path11[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0;
        let result = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config = null;
          if (index >= 0) {
            config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
          } else {
            config = vscode_1.workspace.getConfiguration(void 0, resource).get(key);
          }
          if (config) {
            let path11 = keys[i].split(".");
            ensurePath(result, path11)[path11[path11.length - 1]] = toJSONObject(config);
          }
        }
        return result;
      }
    };
    exports2.SyncConfigurationFeature = SyncConfigurationFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/textSynchronization.js
var require_textSynchronization = __commonJS({
  "node_modules/vscode-languageclient/lib/common/textSynchronization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidSaveTextDocumentFeature = exports2.WillSaveWaitUntilFeature = exports2.WillSaveFeature = exports2.DidChangeTextDocumentFeature = exports2.DidCloseTextDocumentFeature = exports2.DidOpenTextDocumentFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DidOpenTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
      }
      get openDocuments() {
        return this._syncedDocuments.values();
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector2 && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector2 } });
        }
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
          return;
        }
        const documentSelector2 = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
          const uri = textDocument.uri.toString();
          if (this._syncedDocuments.has(uri)) {
            return;
          }
          if (vscode_1.languages.match(documentSelector2, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
            const middleware = this._client.middleware;
            const didOpen = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed`, error);
            });
            this._syncedDocuments.set(uri, textDocument);
          }
        });
      }
      getTextDocument(data) {
        return data;
      }
      notificationSent(textDocument, type, params) {
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
        super.notificationSent(textDocument, type, params);
      }
    };
    exports2.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
    var DidCloseTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client, syncedDocuments, pendingTextDocumentChanges) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
        this._pendingTextDocumentChanges = pendingTextDocumentChanges;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector2 && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector2 } });
        }
      }
      async callback(data) {
        await super.callback(data);
        this._pendingTextDocumentChanges.delete(data.uri.toString());
      }
      getTextDocument(data) {
        return data;
      }
      notificationSent(textDocument, type, params) {
        this._syncedDocuments.delete(textDocument.uri.toString());
        super.notificationSent(textDocument, type, params);
      }
      unregister(id) {
        const selector = this._selectors.get(id);
        super.unregister(id);
        const selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
            let middleware = this._client.middleware;
            let didClose = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed`, error);
            });
          }
        });
      }
    };
    exports2.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
    var DidChangeTextDocumentFeature = class extends features_1.DynamicDocumentFeature {
      constructor(client, pendingTextDocumentChanges) {
        super(client);
        this._changeData = /* @__PURE__ */ new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
        this._onPendingChangeAdded = new vscode_1.EventEmitter();
        this._pendingTextDocumentChanges = pendingTextDocumentChanges;
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      get onPendingChangeAdded() {
        return this._onPendingChangeAdded.event;
      }
      get syncKind() {
        return this._syncKind;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector2 && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector2 }, { syncKind: textDocumentSyncOptions.change })
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          syncKind: data.registerOptions.syncKind,
          documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector)
        });
        this.updateSyncKind(data.registerOptions.syncKind);
      }
      *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
          yield data.documentSelector;
        }
      }
      async callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        const uri = event.document.uri;
        const version = event.document.version;
        const promises = [];
        for (const changeData of this._changeData.values()) {
          if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
            const middleware = this._client.middleware;
            if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
              const didChange = async (event2) => {
                const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2, uri, version);
                await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2.document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              };
              promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
            } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
              const didChange = async (event2) => {
                const eventUri = event2.document.uri.toString();
                this._pendingTextDocumentChanges.set(eventUri, event2.document);
                this._onPendingChangeAdded.fire();
              };
              promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
            }
          }
        }
        return Promise.all(promises).then(void 0, (error) => {
          this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
          throw error;
        });
      }
      notificationSent(textDocument, type, params) {
        this._onNotificationSent.fire({ textDocument, type, params });
      }
      unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0) {
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
          this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        } else {
          this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
          for (const changeData of this._changeData.values()) {
            this.updateSyncKind(changeData.syncKind);
            if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
              break;
            }
          }
        }
      }
      clear() {
        this._pendingTextDocumentChanges.clear();
        this._changeData.clear();
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getPendingDocumentChanges(excludes) {
        if (this._pendingTextDocumentChanges.size === 0) {
          return [];
        }
        let result;
        if (excludes.size === 0) {
          result = Array.from(this._pendingTextDocumentChanges.values());
          this._pendingTextDocumentChanges.clear();
        } else {
          result = [];
          for (const entry of this._pendingTextDocumentChanges) {
            if (!excludes.has(entry[0])) {
              result.push(entry[1]);
              this._pendingTextDocumentChanges.delete(entry[0]);
            }
          }
        }
        return result;
      }
      getProvider(document) {
        for (const changeData of this._changeData.values()) {
          if (vscode_1.languages.match(changeData.documentSelector, document) > 0) {
            return {
              send: (event) => {
                return this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
      updateSyncKind(syncKind) {
        if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
          return;
        }
        switch (syncKind) {
          case vscode_languageserver_protocol_1.TextDocumentSyncKind.Full:
            this._syncKind = syncKind;
            break;
          case vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental:
            if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
              this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
            }
            break;
        }
      }
    };
    exports2.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
    var WillSaveFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector2) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector2 && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector: documentSelector2 }
          });
        }
      }
      getTextDocument(data) {
        return data.document;
      }
    };
    exports2.WillSaveFeature = WillSaveFeature;
    var WillSaveWaitUntilFeature = class extends features_1.DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._selectors = /* @__PURE__ */ new Map();
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector2) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector2 && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector: documentSelector2 }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
      }
      callback(event) {
        if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
          let middleware = this._client.middleware;
          let willSaveWaitUntil = (event2) => {
            return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2)).then(async (edits) => {
              let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
              return vEdits === void 0 ? [] : vEdits;
            });
          };
          event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      clear() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    exports2.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
    var DidSaveTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
      constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._includeText = false;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector2) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector2 && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector2 }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
      getTextDocument(data) {
        return data;
      }
    };
    exports2.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/completion.js
var require_completion = __commonJS({
  "node_modules/vscode-languageclient/lib/common/completion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompletionItemFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var SupportedCompletionItemKinds = [
      vscode_languageserver_protocol_1.CompletionItemKind.Text,
      vscode_languageserver_protocol_1.CompletionItemKind.Method,
      vscode_languageserver_protocol_1.CompletionItemKind.Function,
      vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
      vscode_languageserver_protocol_1.CompletionItemKind.Field,
      vscode_languageserver_protocol_1.CompletionItemKind.Variable,
      vscode_languageserver_protocol_1.CompletionItemKind.Class,
      vscode_languageserver_protocol_1.CompletionItemKind.Interface,
      vscode_languageserver_protocol_1.CompletionItemKind.Module,
      vscode_languageserver_protocol_1.CompletionItemKind.Property,
      vscode_languageserver_protocol_1.CompletionItemKind.Unit,
      vscode_languageserver_protocol_1.CompletionItemKind.Value,
      vscode_languageserver_protocol_1.CompletionItemKind.Enum,
      vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
      vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
      vscode_languageserver_protocol_1.CompletionItemKind.Color,
      vscode_languageserver_protocol_1.CompletionItemKind.File,
      vscode_languageserver_protocol_1.CompletionItemKind.Reference,
      vscode_languageserver_protocol_1.CompletionItemKind.Folder,
      vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
      vscode_languageserver_protocol_1.CompletionItemKind.Constant,
      vscode_languageserver_protocol_1.CompletionItemKind.Struct,
      vscode_languageserver_protocol_1.CompletionItemKind.Event,
      vscode_languageserver_protocol_1.CompletionItemKind.Operator,
      vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
    ];
    var CompletionItemFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
        this.labelDetailsSupport = /* @__PURE__ */ new Map();
      }
      fillClientCapabilities(capabilities) {
        let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport: true,
          commitCharactersSupport: true,
          documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
          deprecatedSupport: true,
          preselectSupport: true,
          tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
          insertReplaceSupport: true,
          resolveSupport: {
            properties: ["documentation", "detail", "additionalTextEdits"]
          },
          insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
          labelDetailsSupport: true
        };
        completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.completionList = {
          itemDefaults: [
            "commitCharacters",
            "editRange",
            "insertTextFormat",
            "insertTextMode",
            "data"
          ]
        };
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.completionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options, id) {
        this.labelDetailsSupport.set(id, !!options.completionItem?.labelDetailsSupport);
        const triggerCharacters = options.triggerCharacters ?? [];
        const defaultCommitCharacters = options.allCommitCharacters;
        const selector = options.documentSelector;
        const provider = {
          provideCompletionItems: (document, position, token, context) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const provideCompletionItems = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document2, position2, context2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token2, error, null);
              });
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems) : provideCompletionItems(document, position, context, token);
          },
          resolveCompletionItem: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item2, !!this.labelDetailsSupport.get(id)), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asCompletionItem(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, ...triggerCharacters), provider];
      }
    };
    exports2.CompletionItemFeature = CompletionItemFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/hover.js
var require_hover = __commonJS({
  "node_modules/vscode-languageclient/lib/common/hover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HoverFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var HoverFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "hover");
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.hoverProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideHover: (document, position, token) => {
            const client = this._client;
            const provideHover = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asHover(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideHover ? middleware.provideHover(document, position, token, provideHover) : provideHover(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.HoverFeature = HoverFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/definition.js
var require_definition = __commonJS({
  "node_modules/vscode-languageclient/lib/common/definition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefinitionFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.definitionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDefinition: (document, position, token) => {
            const client = this._client;
            const provideDefinition = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDefinitionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document, position, token, provideDefinition) : provideDefinition(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.DefinitionFeature = DefinitionFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/signatureHelp.js
var require_signatureHelp = __commonJS({
  "node_modules/vscode-languageclient/lib/common/signatureHelp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignatureHelpFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var SignatureHelpFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.signatureHelpProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideSignatureHelp: (document, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document2, position2, context2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSignatureHelp(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp) : providerSignatureHelp(document, position, context, token);
          }
        };
        return [this.registerProvider(options, provider), provider];
      }
      registerProvider(options, provider) {
        const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        if (options.retriggerCharacters === void 0) {
          const triggerCharacters = options.triggerCharacters || [];
          return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
        } else {
          const metaData = {
            triggerCharacters: options.triggerCharacters || [],
            retriggerCharacters: options.retriggerCharacters || []
          };
          return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
        }
      }
    };
    exports2.SignatureHelpFeature = SignatureHelpFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/documentHighlight.js
var require_documentHighlight = __commonJS({
  "node_modules/vscode-languageclient/lib/common/documentHighlight.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentHighlightFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DocumentHighlightFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.documentHighlightProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentHighlights: (document, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDocumentHighlights(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document, position, token);
          }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
      }
    };
    exports2.DocumentHighlightFeature = DocumentHighlightFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/documentSymbol.js
var require_documentSymbol = __commonJS({
  "node_modules/vscode-languageclient/lib/common/documentSymbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentSymbolFeature = exports2.SupportedSymbolTags = exports2.SupportedSymbolKinds = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    exports2.SupportedSymbolKinds = [
      vscode_languageserver_protocol_1.SymbolKind.File,
      vscode_languageserver_protocol_1.SymbolKind.Module,
      vscode_languageserver_protocol_1.SymbolKind.Namespace,
      vscode_languageserver_protocol_1.SymbolKind.Package,
      vscode_languageserver_protocol_1.SymbolKind.Class,
      vscode_languageserver_protocol_1.SymbolKind.Method,
      vscode_languageserver_protocol_1.SymbolKind.Property,
      vscode_languageserver_protocol_1.SymbolKind.Field,
      vscode_languageserver_protocol_1.SymbolKind.Constructor,
      vscode_languageserver_protocol_1.SymbolKind.Enum,
      vscode_languageserver_protocol_1.SymbolKind.Interface,
      vscode_languageserver_protocol_1.SymbolKind.Function,
      vscode_languageserver_protocol_1.SymbolKind.Variable,
      vscode_languageserver_protocol_1.SymbolKind.Constant,
      vscode_languageserver_protocol_1.SymbolKind.String,
      vscode_languageserver_protocol_1.SymbolKind.Number,
      vscode_languageserver_protocol_1.SymbolKind.Boolean,
      vscode_languageserver_protocol_1.SymbolKind.Array,
      vscode_languageserver_protocol_1.SymbolKind.Object,
      vscode_languageserver_protocol_1.SymbolKind.Key,
      vscode_languageserver_protocol_1.SymbolKind.Null,
      vscode_languageserver_protocol_1.SymbolKind.EnumMember,
      vscode_languageserver_protocol_1.SymbolKind.Struct,
      vscode_languageserver_protocol_1.SymbolKind.Event,
      vscode_languageserver_protocol_1.SymbolKind.Operator,
      vscode_languageserver_protocol_1.SymbolKind.TypeParameter
    ];
    exports2.SupportedSymbolTags = [
      vscode_languageserver_protocol_1.SymbolTag.Deprecated
    ];
    var DocumentSymbolFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: exports2.SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: exports2.SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.documentSymbolProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentSymbols: (document, token) => {
            const client = this._client;
            const _provideDocumentSymbols = async (document2, token2) => {
              try {
                const data = await client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document2), token2);
                if (token2.isCancellationRequested || data === void 0 || data === null) {
                  return null;
                }
                if (data.length === 0) {
                  return [];
                } else {
                  const first = data[0];
                  if (vscode_languageserver_protocol_1.DocumentSymbol.is(first)) {
                    return await client.protocol2CodeConverter.asDocumentSymbols(data, token2);
                  } else {
                    return await client.protocol2CodeConverter.asSymbolInformations(data, token2);
                  }
                }
              } catch (error) {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token2, error, null);
              }
            };
            const middleware = client.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols) : _provideDocumentSymbols(document, token);
          }
        };
        const metaData = options.label !== void 0 ? { label: options.label } : void 0;
        return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, metaData), provider];
      }
    };
    exports2.DocumentSymbolFeature = DocumentSymbolFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/workspaceSymbol.js
var require_workspaceSymbol = __commonJS({
  "node_modules/vscode-languageclient/lib/common/workspaceSymbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var documentSymbol_1 = require_documentSymbol();
    var UUID = require_uuid();
    var WorkspaceSymbolFeature = class extends features_1.WorkspaceFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: documentSymbol_1.SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: documentSymbol_1.SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ["location.range"] };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query2 }, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSymbolInformations(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          },
          resolveWorkspaceSymbol: options.resolveProvider === true ? (item, token) => {
            const client = this._client;
            const resolveWorkspaceSymbol = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSymbolInformation(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
      }
    };
    exports2.WorkspaceSymbolFeature = WorkspaceSymbolFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/reference.js
var require_reference = __commonJS({
  "node_modules/vscode-languageclient/lib/common/reference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReferencesFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var ReferencesFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "references").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.referencesProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideReferences: (document, position, options2, token) => {
            const client = this._client;
            const _providerReferences = (document2, position2, options3, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document2, position2, options3), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asReferences(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document, position, options2, token, _providerReferences) : _providerReferences(document, position, options2, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.ReferencesFeature = ReferencesFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/codeAction.js
var require_codeAction = __commonJS({
  "node_modules/vscode-languageclient/lib/common/codeAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeActionFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var CodeActionFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              vscode_languageserver_protocol_1.CodeActionKind.Empty,
              vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
              vscode_languageserver_protocol_1.CodeActionKind.Refactor,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
              vscode_languageserver_protocol_1.CodeActionKind.Source,
              vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
            ]
          }
        };
        cap.honorsChangeAnnotations = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.codeActionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideCodeActions: (document, range, context, token) => {
            const client = this._client;
            const _provideCodeActions = async (document2, range2, context2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(range2),
                context: client.code2ProtocolConverter.asCodeActionContextSync(context2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token2).then((values) => {
                if (token2.isCancellationRequested || values === null || values === void 0) {
                  return null;
                }
                return client.protocol2CodeConverter.asCodeActionResult(values, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions) : _provideCodeActions(document, range, context, token);
          },
          resolveCodeAction: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const resolveCodeAction = async (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, client.code2ProtocolConverter.asCodeActionSync(item2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return item2;
                }
                return client.protocol2CodeConverter.asCodeAction(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.codeActionKinds ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) } : void 0), provider];
      }
    };
    exports2.CodeActionFeature = CodeActionFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/codeLens.js
var require_codeLens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/codeLens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeLensFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var CodeLensFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options = this.getRegistrationOptions(documentSelector2, capabilities.codeLensProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
          onDidChangeCodeLenses: eventEmitter.event,
          provideCodeLenses: (document, token) => {
            const client = this._client;
            const provideCodeLenses = (document2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asCodeLenses(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document, token, provideCodeLenses) : provideCodeLenses(document, token);
          },
          resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return codeLens2;
                }
                return client.protocol2CodeConverter.asCodeLens(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token2, error, codeLens2);
              });
            };
            const middleware = client.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
      }
    };
    exports2.CodeLensFeature = CodeLensFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/formatting.js
var require_formatting = __commonJS({
  "node_modules/vscode-languageclient/lib/common/formatting.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentOnTypeFormattingFeature = exports2.DocumentRangeFormattingFeature = exports2.DocumentFormattingFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var FileFormattingOptions;
    (function(FileFormattingOptions2) {
      function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration("files", document);
        return {
          trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
          trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
          insertFinalNewline: filesConfig.get("insertFinalNewline")
        };
      }
      FileFormattingOptions2.fromConfiguration = fromConfiguration;
    })(FileFormattingOptions || (FileFormattingOptions = {}));
    var DocumentFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.documentFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentFormattingEdits: (document, options2, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document, options2, token);
          }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
      }
    };
    exports2.DocumentFormattingFeature = DocumentFormattingFeature;
    var DocumentRangeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rangeFormatting");
        capability.dynamicRegistration = true;
        capability.rangesSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.documentRangeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentRangeFormattingEdits: (document, range, options2, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document2, range2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(range2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document, range, options2, token);
          }
        };
        if (options.rangesSupport) {
          provider.provideDocumentRangesFormattingEdits = (document, ranges, options2, token) => {
            const client = this._client;
            const provideDocumentRangesFormattingEdits = (document2, ranges2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                ranges: client.code2ProtocolConverter.asRanges(ranges2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangesFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangesFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentRangesFormattingEdits ? middleware.provideDocumentRangesFormattingEdits(document, ranges, options2, token, provideDocumentRangesFormattingEdits) : provideDocumentRangesFormattingEdits(document, ranges, options2, token);
          };
        }
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
      }
    };
    exports2.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
    var DocumentOnTypeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideOnTypeFormattingEdits: (document, position, ch, options2, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document2, position2, ch2, options3, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2),
                ch: ch2,
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asTextEdits(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document, position, ch, options2, token);
          }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
      }
    };
    exports2.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/rename.js
var require_rename = __commonJS({
  "node_modules/vscode-languageclient/lib/common/rename.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RenameFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var Is = require_is();
    var features_1 = require_features();
    var RenameFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.renameProvider);
        if (!options) {
          return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
          options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideRenameEdits: (document, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document2, position2, newName2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2),
                newName: newName2
              };
              return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asWorkspaceEdit(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token2, error, null, false);
              });
            };
            const middleware = client.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits) : provideRenameEdits(document, position, newName, token);
          },
          prepareRename: options.prepareProvider ? (document, position, token) => {
            const client = this._client;
            const prepareRename = (document2, position2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                if (vscode_languageserver_protocol_1.Range.is(result)) {
                  return client.protocol2CodeConverter.asRange(result);
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                  return {
                    range: client.protocol2CodeConverter.asRange(result.range),
                    placeholder: result.placeholder
                  };
                }
                return Promise.reject(new Error(`The element can't be renamed.`));
              }, (error) => {
                if (typeof error.message === "string") {
                  throw new Error(error.message);
                } else {
                  throw new Error(`The element can't be renamed.`);
                }
              });
            };
            const middleware = client.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document, position, token, prepareRename) : prepareRename(document, position, token);
          } : void 0
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
      }
    };
    exports2.RenameFeature = RenameFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/documentLink.js
var require_documentLink = __commonJS({
  "node_modules/vscode-languageclient/lib/common/documentLink.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentLinkFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var DocumentLinkFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.documentLinkProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentLinks: (document, token) => {
            const client = this._client;
            const provideDocumentLinks = (document2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDocumentLinks(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document, token, provideDocumentLinks) : provideDocumentLinks(document, token);
          },
          resolveDocumentLink: options.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return link2;
                }
                return client.protocol2CodeConverter.asDocumentLink(result);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token2, error, link2);
              });
            };
            const middleware = client.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
      }
    };
    exports2.DocumentLinkFeature = DocumentLinkFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/executeCommand.js
var require_executeCommand = __commonJS({
  "node_modules/vscode-languageclient/lib/common/executeCommand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExecuteCommandFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var UUID = require_uuid();
    var features_1 = require_features();
    var ExecuteCommandFeature = class {
      constructor(client) {
        this._client = client;
        this._commands = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
          let params = {
            command,
            arguments: args
          };
          return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, void 0, error, void 0);
          });
        };
        if (data.registerOptions.commands) {
          const disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      clear() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
    exports2.ExecuteCommandFeature = ExecuteCommandFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js
var require_fileSystemWatcher = __commonJS({
  "node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileSystemWatcherFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var FileSystemWatcherFeature = class {
      constructor(client, notifyFileEvent) {
        this._client = client;
        this._notifyFileEvent = notifyFileEvent;
        this._watchers = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
      }
      initialize(_capabilities, _documentSelector) {
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        const disposables = [];
        for (const watcher of data.registerOptions.watchers) {
          const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
          if (globPattern === void 0) {
            continue;
          }
          let watchCreate = true, watchChange = true, watchDelete = true;
          if (watcher.kind !== void 0 && watcher.kind !== null) {
            watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
            watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
          }
          const fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
          this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
          this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Created
          }), null, listeners);
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Changed
          }), null, listeners);
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Deleted
          }), null, listeners);
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        }
      }
      clear() {
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
    exports2.FileSystemWatcherFeature = FileSystemWatcherFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/colorProvider.js
var require_colorProvider = __commonJS({
  "node_modules/vscode-languageclient/lib/common/colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorProviderFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var ColorProviderFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        let [id, options] = this.getRegistration(documentSelector2, capabilities.colorProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
                range: client.code2ProtocolConverter.asRange(context2.range)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return this._client.protocol2CodeConverter.asColorPresentations(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document, token) => {
            const client = this._client;
            const provideDocumentColors = (document2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return this._client.protocol2CodeConverter.asColorInformations(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document, token, provideDocumentColors) : provideDocumentColors(document, token);
          }
        };
        return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
      }
    };
    exports2.ColorProviderFeature = ColorProviderFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/implementation.js
var require_implementation = __commonJS({
  "node_modules/vscode-languageclient/lib/common/implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var ImplementationFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        let [id, options] = this.getRegistration(documentSelector2, capabilities.implementationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideImplementation: (document, position, token) => {
            const client = this._client;
            const provideImplementation = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDefinitionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document, position, token, provideImplementation) : provideImplementation(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.ImplementationFeature = ImplementationFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/typeDefinition.js
var require_typeDefinition = __commonJS({
  "node_modules/vscode-languageclient/lib/common/typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var TypeDefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition").dynamicRegistration = true;
        let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        let [id, options] = this.getRegistration(documentSelector2, capabilities.typeDefinitionProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideTypeDefinition: (document, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDefinitionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition) : provideTypeDefinition(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.TypeDefinitionFeature = TypeDefinitionFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageclient/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = exports2.arrayDiff = void 0;
    var UUID = require_uuid();
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    function access(target, key) {
      if (target === void 0 || target === null) {
        return void 0;
      }
      return target[key];
    }
    function arrayDiff(left, right) {
      return left.filter((element) => right.indexOf(element) < 0);
    }
    exports2.arrayDiff = arrayDiff;
    var WorkspaceFoldersFeature = class {
      constructor(client) {
        this._client = client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
      }
      fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
          const workspaceFolders = () => {
            const folders = vscode_1.workspace.workspaceFolders;
            if (folders === void 0) {
              return null;
            }
            const result = folders.map((folder) => {
              return this.asProtocol(folder);
            });
            return result;
          };
          const middleware = client.middleware.workspace;
          return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value === true) {
          id = UUID.generateUuid();
        }
        if (id) {
          this.register({ id, registerOptions: void 0 });
        }
      }
      sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            promise = this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          promise = this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise !== void 0) {
          promise.catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
      }
      register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (event2) => {
            return this.doSendEvent(event2.added, event2.removed);
          };
          let middleware = client.middleware.workspace;
          const promise = middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
          promise.catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
          return;
        }
        this._listeners.delete(id);
        disposable.dispose();
      }
      clear() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
          return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
      }
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageclient/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var FoldingRangeFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "foldingRange").refreshSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        this._client.onRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeFoldingRange.fire();
          }
        });
        let [id, options] = this.getRegistration(documentSelector2, capabilities.foldingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
          onDidChangeFoldingRanges: eventEmitter.event,
          provideFoldingRanges: (document, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document2, _, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asFoldingRanges(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges) : provideFoldingRanges(document, context, token);
          }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeFoldingRange: eventEmitter }];
      }
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/declaration.js
var require_declaration = __commonJS({
  "node_modules/vscode-languageclient/lib/common/declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var DeclarationFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const [id, options] = this.getRegistration(documentSelector2, capabilities.declarationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDeclaration: (document, position, token) => {
            const client = this._client;
            const provideDeclaration = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asDeclarationResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document, position, token, provideDeclaration) : provideDeclaration(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.DeclarationFeature = DeclarationFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/selectionRange.js
var require_selectionRange = __commonJS({
  "node_modules/vscode-languageclient/lib/common/selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var SelectionRangeFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const [id, options] = this.getRegistration(documentSelector2, capabilities.selectionRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideSelectionRanges: (document, positions, token) => {
            const client = this._client;
            const provideSelectionRanges = async (document2, positions2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                positions: client.code2ProtocolConverter.asPositionsSync(positions2, token2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token2).then((ranges) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asSelectionRanges(ranges, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges) : provideSelectionRanges(document, positions, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.SelectionRangeFeature = SelectionRangeFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageclient/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var progressPart_1 = require_progressPart();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = /* @__PURE__ */ Object.create(null);
      }
      return target[key];
    }
    var ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = /* @__PURE__ */ new Set();
      }
      getState() {
        return { kind: "window", id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "window").workDoneProgress = true;
      }
      initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
      }
      clear() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
    exports2.ProgressFeature = ProgressFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageclient/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var CallHierarchyProvider = class {
      constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
      }
      prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document2, position2, token2) => {
          const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2);
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asCallHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token2, error, null);
          });
        };
        return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy) : prepareCallHierarchy(document, position, token);
      }
      provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token2, error, null);
          });
        };
        return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
      }
      provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token2, error, null);
          });
        };
        return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
      }
    };
    var CallHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const [id, options] = this.getRegistration(documentSelector2, capabilities.callHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
      }
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensFeature = void 0;
    var vscode22 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var Is = require_is();
    var SemanticTokensFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
          vscode_languageserver_protocol_1.SemanticTokenTypes.type,
          vscode_languageserver_protocol_1.SemanticTokenTypes.class,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
          vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
          vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
          vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
          vscode_languageserver_protocol_1.SemanticTokenTypes.property,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
          vscode_languageserver_protocol_1.SemanticTokenTypes.event,
          vscode_languageserver_protocol_1.SemanticTokenTypes.function,
          vscode_languageserver_protocol_1.SemanticTokenTypes.method,
          vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
          vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
          vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
          vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
          vscode_languageserver_protocol_1.SemanticTokenTypes.string,
          vscode_languageserver_protocol_1.SemanticTokenTypes.number,
          vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
          vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
          vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
        ];
        capability.tokenModifiers = [
          vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector2, capabilities.semanticTokensProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== void 0;
        const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
        const eventEmitter = new vscode22.EventEmitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document, token) => {
            const client2 = this._client;
            const middleware = client2.middleware;
            const provideDocumentSemanticTokens = (document2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document, previousResultId, token) => {
            const client2 = this._client;
            const middleware = client2.middleware;
            const provideDocumentSemanticTokensEdits = (document2, previousResultId2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                previousResultId: previousResultId2
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token2).then(async (result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                  return await client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                } else {
                  return await client2.protocol2CodeConverter.asSemanticTokensEdits(result, token2);
                }
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document, range, token) => {
            const client2 = this._client;
            const middleware = client2.middleware;
            const provideDocumentRangeSemanticTokens = (document2, range2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client2.code2ProtocolConverter.asRange(range2)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document, range, token);
          }
        } : void 0;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        const documentSelector2 = client.protocol2CodeConverter.asDocumentSelector(selector);
        if (documentProvider !== void 0) {
          disposables.push(vscode22.languages.registerDocumentSemanticTokensProvider(documentSelector2, documentProvider, legend));
        }
        if (rangeProvider !== void 0) {
          disposables.push(vscode22.languages.registerDocumentRangeSemanticTokensProvider(documentSelector2, rangeProvider, legend));
        }
        return [new vscode22.Disposable(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageclient/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesFeature = exports2.WillRenameFilesFeature = exports2.WillCreateFilesFeature = exports2.DidDeleteFilesFeature = exports2.DidRenameFilesFeature = exports2.DidCreateFilesFeature = void 0;
    var code = require("vscode");
    var minimatch = require_minimatch();
    var proto = require_main3();
    var UUID = require_uuid();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    function access(target, key) {
      return target[key];
    }
    function assign(target, key, value) {
      target[key] = value;
    }
    var FileOperationFeature = class _FileOperationFeature {
      constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
        this._filters = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
      }
      filterSize() {
        return this._filters.size;
      }
      get registrationType() {
        return this._registrationType;
      }
      fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
        assign(value, "dynamicRegistration", true);
        assign(value, this._clientCapability, true);
      }
      initialize(capabilities) {
        const options = capabilities.workspace?.fileOperations;
        const capability = options !== void 0 ? access(options, this._serverCapability) : void 0;
        if (capability?.filters !== void 0) {
          try {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: { filters: capability.filters }
            });
          } catch (e) {
            this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
          }
        }
      }
      register(data) {
        if (!this._listener) {
          this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
          const matcher = new minimatch.Minimatch(filter.pattern.glob, _FileOperationFeature.asMinimatchOptions(filter.pattern.options));
          if (!matcher.makeRe()) {
            throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
          }
          return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
      }
      unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      clear() {
        this._filters.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getFileType(uri) {
        return _FileOperationFeature.getFileType(uri);
      }
      async filter(event, prop) {
        const fileMatches = await Promise.all(event.files.map(async (item) => {
          const uri = prop(item);
          const path11 = uri.fsPath.replace(/\\/g, "/");
          for (const filters of this._filters.values()) {
            for (const filter of filters) {
              if (filter.scheme !== void 0 && filter.scheme !== uri.scheme) {
                continue;
              }
              if (filter.matcher.match(path11)) {
                if (filter.kind === void 0) {
                  return true;
                }
                const fileType = await this.getFileType(uri);
                if (fileType === void 0) {
                  this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                  return true;
                }
                if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) {
                  return true;
                }
              } else if (filter.kind === proto.FileOperationPatternKind.folder) {
                const fileType = await _FileOperationFeature.getFileType(uri);
                if (fileType === code.FileType.Directory && filter.matcher.match(`${path11}/`)) {
                  return true;
                }
              }
            }
          }
          return false;
        }));
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
      }
      static async getFileType(uri) {
        try {
          return (await code.workspace.fs.stat(uri)).type;
        } catch (e) {
          return void 0;
        }
      }
      static asMinimatchOptions(options) {
        const result = { dot: true };
        if (options?.ignoreCase === true) {
          result.nocase = true;
        }
        return result;
      }
    };
    var NotificationFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = async (event) => {
            return this._client.sendNotification(this._notificationType, this._createParams(event));
          };
          return this.doSend(filteredEvent, next);
        }
      }
    };
    var CachingNotificationFileOperationFeature = class extends NotificationFileOperationFeature {
      constructor() {
        super(...arguments);
        this._fsPathFileTypes = /* @__PURE__ */ new Map();
      }
      async getFileType(uri) {
        const fsPath = uri.fsPath;
        if (this._fsPathFileTypes.has(fsPath)) {
          return this._fsPathFileTypes.get(fsPath);
        }
        const type = await FileOperationFeature.getFileType(uri);
        if (type) {
          this._fsPathFileTypes.set(fsPath, type);
        }
        return type;
      }
      async cacheFileTypes(event, prop) {
        await this.filter(event, prop);
      }
      clearFileTypeCache() {
        this._fsPathFileTypes.clear();
      }
      unregister(id) {
        super.unregister(id);
        if (this.filterSize() === 0 && this._willListener) {
          this._willListener.dispose();
          this._willListener = void 0;
        }
      }
      clear() {
        super.clear();
        if (this._willListener) {
          this._willListener.dispose();
          this._willListener = void 0;
        }
      }
    };
    var DidCreateFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
    exports2.DidCreateFilesFeature = DidCreateFilesFeature;
    var DidRenameFilesFeature = class extends CachingNotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
      }
      register(data) {
        if (!this._willListener) {
          this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
        }
        super.register(data);
      }
      willRename(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
      }
      doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);
      }
    };
    exports2.DidRenameFilesFeature = DidRenameFilesFeature;
    var DidDeleteFilesFeature = class extends CachingNotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
      }
      register(data) {
        if (!this._willListener) {
          this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
        }
        super.register(data);
      }
      willDelete(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i));
      }
      doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);
      }
    };
    exports2.DidDeleteFilesFeature = DidDeleteFilesFeature;
    var RequestFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
      }
      async waitUntil(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = (event) => {
            return this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit);
          };
          return this.doSend(filteredEvent, next);
        } else {
          return void 0;
        }
      }
    };
    var WillCreateFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
    exports2.WillCreateFilesFeature = WillCreateFilesFeature;
    var WillRenameFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);
      }
    };
    exports2.WillRenameFilesFeature = WillRenameFilesFeature;
    var WillDeleteFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);
      }
    };
    exports2.WillDeleteFilesFeature = WillDeleteFilesFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageclient/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingFeature = void 0;
    var code = require("vscode");
    var proto = require_main3();
    var features_1 = require_features();
    var LinkedEditingFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "linkedEditingRange");
        linkedEditingSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        let [id, options] = this.getRegistration(documentSelector2, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideLinkedEditingRanges: (document, position, token) => {
            const client = this._client;
            const provideLinkedEditing = (document2, position2, token2) => {
              return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asLinkedEditingRanges(result, token2);
              }, (error) => {
                return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing) : provideLinkedEditing(document, position, token);
          }
        };
        return [this.registerProvider(selector, provider), provider];
      }
      registerProvider(selector, provider) {
        return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.LinkedEditingFeature = LinkedEditingFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageclient/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var TypeHierarchyProvider = class {
      constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
      }
      prepareTypeHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareTypeHierarchy = (document2, position2, token2) => {
          const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2);
          return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token2, error, null);
          });
        };
        return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document, position, token);
      }
      provideTypeHierarchySupertypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySupertypes = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token2, error, null);
          });
        };
        return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
      }
      provideTypeHierarchySubtypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySubtypes = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token2).then((result) => {
            if (token2.isCancellationRequested) {
              return null;
            }
            return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token2, error, null);
          });
        };
        return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
      }
    };
    var TypeHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const [id, options] = this.getRegistration(documentSelector2, capabilities.typeHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const client = this._client;
        const provider = new TypeHierarchyProvider(client);
        return [vscode_1.languages.registerTypeHierarchyProvider(client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
      }
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageclient/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var InlineValueFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlineValueRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlineValue").refreshSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlineValues.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector2, capabilities.inlineValueProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
          onDidChangeInlineValues: eventEmitter.event,
          provideInlineValues: (document, viewPort, context, token) => {
            const client = this._client;
            const provideInlineValues = (document2, viewPort2, context2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(viewPort2),
                context: client.code2ProtocolConverter.asInlineValueContext(context2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token2).then((values) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asInlineValues(values, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token2, error, null);
              });
            };
            const middleware = client.middleware;
            return middleware.provideInlineValues ? middleware.provideInlineValues(document, viewPort, context, token, provideInlineValues) : provideInlineValues(document, viewPort, context, token);
          }
        };
        return [this.registerProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageclient/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintsFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var InlayHintsFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlayHintRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlayHint");
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
          properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
        };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlayHint").refreshSupport = true;
      }
      initialize(capabilities, documentSelector2) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlayHints.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector2, capabilities.inlayHintProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
          onDidChangeInlayHints: eventEmitter.event,
          provideInlayHints: (document, viewPort, token) => {
            const client = this._client;
            const provideInlayHints = async (document2, viewPort2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(viewPort2)
              };
              try {
                const values = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token2);
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asInlayHints(values, token2);
              } catch (error) {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token2, error, null);
              }
            };
            const middleware = client.middleware;
            return middleware.provideInlayHints ? middleware.provideInlayHints(document, viewPort, token, provideInlayHints) : provideInlayHints(document, viewPort, token);
          }
        };
        provider.resolveInlayHint = options.resolveProvider === true ? (hint, token) => {
          const client = this._client;
          const resolveInlayHint = async (item, token2) => {
            try {
              const value = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client.code2ProtocolConverter.asInlayHint(item), token2);
              if (token2.isCancellationRequested) {
                return null;
              }
              const result = client.protocol2CodeConverter.asInlayHint(value, token2);
              return token2.isCancellationRequested ? null : result;
            } catch (error) {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token2, error, null);
            }
          };
          const middleware = client.middleware;
          return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
        } : void 0;
        return [this.registerProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
      }
      registerProvider(selector, provider) {
        return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
      }
    };
    exports2.InlayHintsFeature = InlayHintsFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/inlineCompletion.js
var require_inlineCompletion = __commonJS({
  "node_modules/vscode-languageclient/lib/common/inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionItemFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var features_1 = require_features();
    var UUID = require_uuid();
    var InlineCompletionItemFeature = class extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlineCompletionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let inlineCompletion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlineCompletion");
        inlineCompletion.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector2) {
        const options = this.getRegistrationOptions(documentSelector2, capabilities.inlineCompletionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideInlineCompletionItems: (document, position, context, token) => {
            const client = this._client;
            const middleware = this._client.middleware;
            const provideInlineCompletionItems = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, client.code2ProtocolConverter.asInlineCompletionParams(document2, position2, context2), token2).then((result) => {
                if (token2.isCancellationRequested) {
                  return null;
                }
                return client.protocol2CodeConverter.asInlineCompletionResult(result, token2);
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, token2, error, null);
              });
            };
            return middleware.provideInlineCompletionItems ? middleware.provideInlineCompletionItems(document, position, context, token, provideInlineCompletionItems) : provideInlineCompletionItems(document, position, context, token);
          }
        };
        return [vscode_1.languages.registerInlineCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
      }
    };
    exports2.InlineCompletionItemFeature = InlineCompletionItemFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/client.js
var require_client = __commonJS({
  "node_modules/vscode-languageclient/lib/common/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.BaseLanguageClient = exports2.MessageTransports = exports2.SuspendMode = exports2.State = exports2.CloseAction = exports2.ErrorAction = exports2.RevealOutputChannelOn = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main3();
    var c2p = require_codeConverter();
    var p2c = require_protocolConverter();
    var Is = require_is();
    var async_1 = require_async();
    var UUID = require_uuid();
    var progressPart_1 = require_progressPart();
    var features_1 = require_features();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var configuration_1 = require_configuration();
    var textSynchronization_1 = require_textSynchronization();
    var completion_1 = require_completion();
    var hover_1 = require_hover();
    var definition_1 = require_definition();
    var signatureHelp_1 = require_signatureHelp();
    var documentHighlight_1 = require_documentHighlight();
    var documentSymbol_1 = require_documentSymbol();
    var workspaceSymbol_1 = require_workspaceSymbol();
    var reference_1 = require_reference();
    var codeAction_1 = require_codeAction();
    var codeLens_1 = require_codeLens();
    var formatting_1 = require_formatting();
    var rename_1 = require_rename();
    var documentLink_1 = require_documentLink();
    var executeCommand_1 = require_executeCommand();
    var fileSystemWatcher_1 = require_fileSystemWatcher();
    var colorProvider_1 = require_colorProvider();
    var implementation_1 = require_implementation();
    var typeDefinition_1 = require_typeDefinition();
    var workspaceFolder_1 = require_workspaceFolder();
    var foldingRange_1 = require_foldingRange();
    var declaration_1 = require_declaration();
    var selectionRange_1 = require_selectionRange();
    var progress_1 = require_progress();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var inlayHint_1 = require_inlayHint();
    var inlineCompletion_1 = require_inlineCompletion();
    var RevealOutputChannelOn2;
    (function(RevealOutputChannelOn3) {
      RevealOutputChannelOn3[RevealOutputChannelOn3["Debug"] = 0] = "Debug";
      RevealOutputChannelOn3[RevealOutputChannelOn3["Info"] = 1] = "Info";
      RevealOutputChannelOn3[RevealOutputChannelOn3["Warn"] = 2] = "Warn";
      RevealOutputChannelOn3[RevealOutputChannelOn3["Error"] = 3] = "Error";
      RevealOutputChannelOn3[RevealOutputChannelOn3["Never"] = 4] = "Never";
    })(RevealOutputChannelOn2 || (exports2.RevealOutputChannelOn = RevealOutputChannelOn2 = {}));
    var ErrorAction2;
    (function(ErrorAction3) {
      ErrorAction3[ErrorAction3["Continue"] = 1] = "Continue";
      ErrorAction3[ErrorAction3["Shutdown"] = 2] = "Shutdown";
    })(ErrorAction2 || (exports2.ErrorAction = ErrorAction2 = {}));
    var CloseAction2;
    (function(CloseAction3) {
      CloseAction3[CloseAction3["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction3[CloseAction3["Restart"] = 2] = "Restart";
    })(CloseAction2 || (exports2.CloseAction = CloseAction2 = {}));
    var State;
    (function(State2) {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Starting"] = 3] = "Starting";
      State2[State2["Running"] = 2] = "Running";
    })(State || (exports2.State = State = {}));
    var SuspendMode;
    (function(SuspendMode2) {
      SuspendMode2["off"] = "off";
      SuspendMode2["on"] = "on";
    })(SuspendMode || (exports2.SuspendMode = SuspendMode = {}));
    var ResolvedClientOptions;
    (function(ResolvedClientOptions2) {
      function sanitizeIsTrusted(isTrusted) {
        if (isTrusted === void 0 || isTrusted === null) {
          return false;
        }
        if (typeof isTrusted === "boolean" || typeof isTrusted === "object" && isTrusted !== null && Is.stringArray(isTrusted.enabledCommands)) {
          return isTrusted;
        }
        return false;
      }
      ResolvedClientOptions2.sanitizeIsTrusted = sanitizeIsTrusted;
    })(ResolvedClientOptions || (ResolvedClientOptions = {}));
    var DefaultErrorHandler = class {
      constructor(client, maxRestartCount) {
        this.client = client;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return { action: ErrorAction2.Continue };
        }
        return { action: ErrorAction2.Shutdown };
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
          return { action: CloseAction2.Restart };
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            return { action: CloseAction2.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
          } else {
            this.restarts.shift();
            return { action: CloseAction2.Restart };
          }
        }
      }
    };
    var ClientState;
    (function(ClientState2) {
      ClientState2["Initial"] = "initial";
      ClientState2["Starting"] = "starting";
      ClientState2["StartFailed"] = "startFailed";
      ClientState2["Running"] = "running";
      ClientState2["Stopping"] = "stopping";
      ClientState2["Stopped"] = "stopped";
    })(ClientState || (ClientState = {}));
    var MessageTransports;
    (function(MessageTransports2) {
      function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports || (exports2.MessageTransports = MessageTransports = {}));
    var BaseLanguageClient = class _BaseLanguageClient {
      constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._diagnosticQueue = /* @__PURE__ */ new Map();
        this._diagnosticQueueState = { state: "idle" };
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this.workspaceEditLock = new async_1.Semaphore(1);
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown !== void 0) {
          markdown.isTrusted = ResolvedClientOptions.sanitizeIsTrusted(clientOptions.markdown.isTrusted);
          markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        this._clientOptions = {
          documentSelector: clientOptions.documentSelector ?? [],
          synchronize: clientOptions.synchronize ?? {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName ?? this._name,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn2.Error,
          stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: !!clientOptions.progressOnInitialization,
          errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
          middleware: clientOptions.middleware ?? {},
          uriConverters: clientOptions.uriConverters,
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown,
          // suspend: {
          // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
          // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
          // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
          // },
          diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
          notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._ignoredRegistrations = /* @__PURE__ */ new Set();
        this._listeners = [];
        this._notificationHandlers = /* @__PURE__ */ new Map();
        this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
        this._notificationDisposables = /* @__PURE__ */ new Map();
        this._requestHandlers = /* @__PURE__ */ new Map();
        this._pendingRequestHandlers = /* @__PURE__ */ new Map();
        this._requestDisposables = /* @__PURE__ */ new Map();
        this._progressHandlers = /* @__PURE__ */ new Map();
        this._pendingProgressHandlers = /* @__PURE__ */ new Map();
        this._progressDisposables = /* @__PURE__ */ new Map();
        this._connection = void 0;
        this._initializeResult = void 0;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
          this._disposeOutputChannel = false;
        } else {
          this._outputChannel = void 0;
          this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._diagnostics = void 0;
        this._pendingOpenNotifications = /* @__PURE__ */ new Set();
        this._pendingChangeSemaphore = new async_1.Semaphore(1);
        this._pendingChangeDelayer = new async_1.Delayer(250);
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onStop = void 0;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (Is.string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
      }
      get name() {
        return this._name;
      }
      get middleware() {
        return this._clientOptions.middleware ?? /* @__PURE__ */ Object.create(null);
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get protocol2CodeConverter() {
        return this._p2c;
      }
      get code2ProtocolConverter() {
        return this._c2p;
      }
      get onTelemetry() {
        return this._telemetryEmitter.event;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get traceOutputChannel() {
        if (this._traceOutputChannel) {
          return this._traceOutputChannel;
        }
        return this.outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      get state() {
        return this.getPublicState();
      }
      get $state() {
        return this._state;
      }
      set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      getPublicState() {
        switch (this.$state) {
          case ClientState.Starting:
            return State.Starting;
          case ClientState.Running:
            return State.Running;
          default:
            return State.Stopped;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      async sendRequest(type, ...params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        const connection = await this.$start();
        if (this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
          await this.sendPendingFullTextDocumentChanges(connection);
        }
        const _sendRequest = this._clientOptions.middleware?.sendRequest;
        if (_sendRequest !== void 0) {
          let param = void 0;
          let token = void 0;
          if (params.length === 1) {
            if (vscode_languageserver_protocol_1.CancellationToken.is(params[0])) {
              token = params[0];
            } else {
              param = params[0];
            }
          } else if (params.length === 2) {
            param = params[0];
            token = params[1];
          }
          return _sendRequest(type, param, token, (type2, param2, token2) => {
            const params2 = [];
            if (param2 !== void 0) {
              params2.push(param2);
            }
            if (token2 !== void 0) {
              params2.push(token2);
            }
            return connection.sendRequest(type2, ...params2);
          });
        } else {
          return connection.sendRequest(type, ...params);
        }
      }
      onRequest(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._requestDisposables.set(method, connection.onRequest(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingRequestHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingRequestHandlers.delete(method);
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._requestHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      async sendNotification(type, params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        const needsPendingFullTextDocumentSync = this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        let openNotification;
        if (needsPendingFullTextDocumentSync && typeof type !== "string" && type.method === vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method) {
          openNotification = params?.textDocument.uri;
          this._pendingOpenNotifications.add(openNotification);
        }
        const connection = await this.$start();
        if (needsPendingFullTextDocumentSync) {
          await this.sendPendingFullTextDocumentChanges(connection);
        }
        if (openNotification !== void 0) {
          this._pendingOpenNotifications.delete(openNotification);
        }
        const _sendNotification = this._clientOptions.middleware?.sendNotification;
        return _sendNotification ? _sendNotification(type, connection.sendNotification.bind(connection), params) : connection.sendNotification(type, params);
      }
      onNotification(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._notificationDisposables.set(method, connection.onNotification(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingNotificationHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingNotificationHandlers.delete(method);
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._notificationHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      async sendProgress(type, token, value) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
          return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
          const connection = await this.$start();
          return connection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware?.handleWorkDoneProgress;
        const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
          handleWorkDoneProgress(token, params, () => handler(params));
        } : handler;
        if (connection !== void 0) {
          this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
          disposable = {
            dispose: () => {
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        } else {
          this._pendingProgressHandlers.set(token, { type, handler });
          disposable = {
            dispose: () => {
              this._pendingProgressHandlers.delete(token);
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._progressHandlers.delete(token);
            disposable.dispose();
          }
        };
      }
      createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== void 0 && maxRestartCount < 0) {
          throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this, maxRestartCount ?? 4);
      }
      async setTrace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== void 0) {
          await connection.trace(this._trace, this._tracer, {
            sendNotification: false,
            traceFormat: this._traceFormat
          });
        }
      }
      data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (Is.string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (Is.string(data)) {
          return data;
        }
        return data.toString();
      }
      debug(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Debug, RevealOutputChannelOn2.Debug, "Debug", message, data, showNotification);
      }
      info(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Info, RevealOutputChannelOn2.Info, "Info", message, data, showNotification);
      }
      warn(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Warning, RevealOutputChannelOn2.Warn, "Warn", message, data, showNotification);
      }
      error(message, data, showNotification = true) {
        this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Error, RevealOutputChannelOn2.Error, "Error", message, data, showNotification);
      }
      logOutputMessage(type, reveal, name, message, data, showNotification) {
        this.outputChannel.appendLine(`[${name.padEnd(5)} - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= reveal) {
          this.showNotificationMessage(type, message);
        }
      }
      showNotificationMessage(type, message) {
        message = message ?? "A request has failed. See the output for more information.";
        const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error ? vscode_1.window.showErrorMessage : type === vscode_languageserver_protocol_1.MessageType.Warning ? vscode_1.window.showWarningMessage : vscode_1.window.showInformationMessage;
        void messageFunc(message, "Go to output").then((selection) => {
          if (selection !== void 0) {
            this.outputChannel.show(true);
          }
        });
      }
      logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data) {
          this.traceOutputChannel.appendLine(this.data2String(data));
        }
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.traceOutputChannel.append(`[LSP   - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
        } else {
          this.traceOutputChannel.append(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
        }
        if (data) {
          this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      needsStart() {
        return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
      }
      needsStop() {
        return this.$state === ClientState.Starting || this.$state === ClientState.Running;
      }
      activeConnection() {
        return this.$state === ClientState.Running && this._connection !== void 0 ? this._connection : void 0;
      }
      isRunning() {
        return this.$state === ClientState.Running;
      }
      async start() {
        if (this._disposed === "disposing" || this._disposed === "disposed") {
          throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === ClientState.Stopping) {
          throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        if (this._onStart !== void 0) {
          return this._onStart;
        }
        const [promise, resolve3, reject] = this.createOnStartPromise();
        this._onStart = promise;
        if (this._diagnostics === void 0) {
          this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection();
        }
        for (const [method, handler] of this._notificationHandlers) {
          if (!this._pendingNotificationHandlers.has(method)) {
            this._pendingNotificationHandlers.set(method, handler);
          }
        }
        for (const [method, handler] of this._requestHandlers) {
          if (!this._pendingRequestHandlers.has(method)) {
            this._pendingRequestHandlers.set(method, handler);
          }
        }
        for (const [token, data] of this._progressHandlers) {
          if (!this._pendingProgressHandlers.has(token)) {
            this._pendingProgressHandlers.set(token, data);
          }
        }
        this.$state = ClientState.Starting;
        try {
          const connection = await this.createConnection();
          connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                this.error(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                this.warn(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                this.info(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Debug:
                this.debug(message.message, void 0, false);
                break;
              default:
                this.outputChannel.appendLine(message.message);
            }
          });
          connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                void vscode_1.window.showErrorMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                void vscode_1.window.showWarningMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                void vscode_1.window.showInformationMessage(message.message);
                break;
              default:
                void vscode_1.window.showInformationMessage(message.message);
            }
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                messageFunc = vscode_1.window.showErrorMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                messageFunc = vscode_1.window.showWarningMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                messageFunc = vscode_1.window.showInformationMessage;
                break;
              default:
                messageFunc = vscode_1.window.showInformationMessage;
            }
            let actions = params.actions || [];
            return messageFunc(params.message, ...actions);
          });
          connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
            this._telemetryEmitter.fire(data);
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
            const showDocument = async (params2) => {
              const uri = this.protocol2CodeConverter.asUri(params2.uri);
              try {
                if (params2.external === true) {
                  const success = await vscode_1.env.openExternal(uri);
                  return { success };
                } else {
                  const options = {};
                  if (params2.selection !== void 0) {
                    options.selection = this.protocol2CodeConverter.asRange(params2.selection);
                  }
                  if (params2.takeFocus === void 0 || params2.takeFocus === false) {
                    options.preserveFocus = true;
                  } else if (params2.takeFocus === true) {
                    options.preserveFocus = false;
                  }
                  await vscode_1.window.showTextDocument(uri, options);
                  return { success: true };
                }
              } catch (error) {
                return { success: false };
              }
            };
            const middleware = this._clientOptions.middleware.window?.showDocument;
            if (middleware !== void 0) {
              return middleware(params, showDocument);
            } else {
              return showDocument(params);
            }
          });
          connection.listen();
          await this.initialize(connection);
          resolve3();
        } catch (error) {
          this.$state = ClientState.StartFailed;
          this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
          reject(error);
        }
        return this._onStart;
      }
      createOnStartPromise() {
        let resolve3;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
          resolve3 = _resolve;
          reject = _reject;
        });
        return [promise, resolve3, reject];
      }
      async initialize(connection) {
        this.refreshTrace(connection, false);
        const initOption = this._clientOptions.initializationOptions;
        const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== void 0 ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]] : [this._clientGetRootPath(), null];
        const initParams = {
          processId: null,
          clientInfo: {
            name: vscode_1.env.appName,
            version: vscode_1.version
          },
          locale: this.getLocale(),
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: Is.func(initOption) ? initOption() : initOption,
          trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
          workspaceFolders
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
          const token = UUID.generateUuid();
          const part = new progressPart_1.ProgressPart(connection, token);
          initParams.workDoneToken = token;
          try {
            const result = await this.doInitialize(connection, initParams);
            part.done();
            return result;
          } catch (error) {
            part.cancel();
            throw error;
          }
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      async doInitialize(connection, initParams) {
        try {
          const result = await connection.initialize(initParams);
          if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
            throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
          }
          this._initializeResult = result;
          this.$state = ClientState.Running;
          let textDocumentSyncOptions = void 0;
          if (Is.number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
          connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          for (const [method, handler] of this._pendingNotificationHandlers) {
            this._notificationDisposables.set(method, connection.onNotification(method, handler));
          }
          this._pendingNotificationHandlers.clear();
          for (const [method, handler] of this._pendingRequestHandlers) {
            this._requestDisposables.set(method, connection.onRequest(method, handler));
          }
          this._pendingRequestHandlers.clear();
          for (const [token, data] of this._pendingProgressHandlers) {
            this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
          }
          this._pendingProgressHandlers.clear();
          await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
          this.hookFileEvents(connection);
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          return result;
        } catch (error) {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              void this.initialize(connection);
            } else {
              void this.stop();
            }
          } else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
            void vscode_1.window.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              if (item && item.id === "retry") {
                void this.initialize(connection);
              } else {
                void this.stop();
              }
            });
          } else {
            if (error && error.message) {
              void vscode_1.window.showErrorMessage(error.message);
            }
            this.error("Server initialization failed.", error);
            void this.stop();
          }
          throw error;
        }
      }
      _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      stop(timeout = 2e3) {
        return this.shutdown("stop", timeout);
      }
      dispose(timeout = 2e3) {
        try {
          this._disposed = "disposing";
          return this.stop(timeout);
        } finally {
          this._disposed = "disposed";
        }
      }
      async shutdown(mode, timeout) {
        if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
          return;
        }
        if (this.$state === ClientState.Stopping) {
          if (this._onStop !== void 0) {
            return this._onStop;
          } else {
            throw new Error(`Client is stopping but no stop promise available.`);
          }
        }
        const connection = this.activeConnection();
        if (connection === void 0 || this.$state !== ClientState.Running) {
          throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = void 0;
        this.$state = ClientState.Stopping;
        this.cleanUp(mode);
        const tp = new Promise((c) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout);
        });
        const shutdown = (async (connection2) => {
          await connection2.shutdown();
          await connection2.exit();
          return connection2;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection2) => {
          if (connection2 !== void 0) {
            connection2.end();
            connection2.dispose();
          } else {
            this.error(`Stopping server timed out`, void 0, false);
            throw new Error(`Stopping the server timed out`);
          }
        }, (error) => {
          this.error(`Stopping server failed`, error, false);
          throw error;
        }).finally(() => {
          this.$state = ClientState.Stopped;
          mode === "stop" && this.cleanUpChannel();
          this._onStart = void 0;
          this._onStop = void 0;
          this._connection = void 0;
          this._ignoredRegistrations.clear();
        });
      }
      cleanUp(mode) {
        this._fileEvents = [];
        this._fileEventDelayer.cancel();
        const disposables = this._listeners.splice(0, this._listeners.length);
        for (const disposable of disposables) {
          disposable.dispose();
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (const feature of Array.from(this._features.entries()).map((entry) => entry[1]).reverse()) {
          feature.clear();
        }
        if (mode === "stop" && this._diagnostics !== void 0) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
        if (this._idleInterval !== void 0) {
          this._idleInterval.dispose();
          this._idleInterval = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel !== void 0 && this._disposeOutputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      notifyFileEvent(event) {
        const client = this;
        async function didChangeWatchedFile(event2) {
          client._fileEvents.push(event2);
          return client._fileEventDelayer.trigger(async () => {
            await client.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client._fileEvents });
            client._fileEvents = [];
          });
        }
        const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
        (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
          client.error(`Notify file events failed.`, error);
        });
      }
      async sendPendingFullTextDocumentChanges(connection) {
        return this._pendingChangeSemaphore.lock(async () => {
          try {
            const changes = this._didChangeTextDocumentFeature.getPendingDocumentChanges(this._pendingOpenNotifications);
            if (changes.length === 0) {
              return;
            }
            for (const document of changes) {
              const params = this.code2ProtocolConverter.asChangeTextDocumentParams(document);
              await connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              this._didChangeTextDocumentFeature.notificationSent(document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
            }
          } catch (error) {
            this.error(`Sending pending changes failed`, error, false);
            throw error;
          }
        });
      }
      triggerPendingChangeDelivery() {
        this._pendingChangeDelayer.trigger(async () => {
          const connection = this.activeConnection();
          if (connection === void 0) {
            this.triggerPendingChangeDelivery();
            return;
          }
          await this.sendPendingFullTextDocumentChanges(connection);
        }).catch((error) => this.error(`Delivering pending changes failed`, error, false));
      }
      handleDiagnostics(params) {
        if (!this._diagnostics) {
          return;
        }
        const key = params.uri;
        if (this._diagnosticQueueState.state === "busy" && this._diagnosticQueueState.document === key) {
          this._diagnosticQueueState.tokenSource.cancel();
        }
        this._diagnosticQueue.set(params.uri, params.diagnostics);
        this.triggerDiagnosticQueue();
      }
      triggerDiagnosticQueue() {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
          this.workDiagnosticQueue();
        });
      }
      workDiagnosticQueue() {
        if (this._diagnosticQueueState.state === "busy") {
          return;
        }
        const next = this._diagnosticQueue.entries().next();
        if (next.done === true) {
          return;
        }
        const [document, diagnostics] = next.value;
        this._diagnosticQueue.delete(document);
        const tokenSource = new vscode_1.CancellationTokenSource();
        this._diagnosticQueueState = { state: "busy", document, tokenSource };
        this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
          if (!tokenSource.token.isCancellationRequested) {
            const uri = this._p2c.asUri(document);
            const middleware = this.clientOptions.middleware;
            if (middleware.handleDiagnostics) {
              middleware.handleDiagnostics(uri, converted, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
            } else {
              this.setDiagnostics(uri, converted);
            }
          }
        }).finally(() => {
          this._diagnosticQueueState = { state: "idle" };
          this.triggerDiagnosticQueue();
        });
      }
      setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
          return;
        }
        this._diagnostics.set(uri, diagnostics);
      }
      getLocale() {
        return vscode_1.env.language;
      }
      async $start() {
        if (this.$state === ClientState.StartFailed) {
          throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this.start();
        const connection = this.activeConnection();
        if (connection === void 0) {
          throw new Error(`Starting server failed`);
        }
        return connection;
      }
      async createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count).catch((error2) => this.error(`Handling connection error failed`, error2));
        };
        let closeHandler = () => {
          this.handleConnectionClosed().catch((error) => this.error(`Handling connection close failed`, error));
        };
        const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8");
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
      }
      async handleConnectionClosed() {
        if (this.$state === ClientState.Stopped) {
          return;
        }
        try {
          if (this._connection !== void 0) {
            this._connection.dispose();
          }
        } catch (error) {
        }
        let handlerResult = { action: CloseAction2.DoNotRestart };
        if (this.$state !== ClientState.Stopping) {
          try {
            handlerResult = await this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connection = void 0;
        if (handlerResult.action === CloseAction2.DoNotRestart) {
          this.error(handlerResult.message ?? "Connection to server got closed. Server will not be restarted.", void 0, handlerResult.handled === true ? false : "force");
          this.cleanUp("stop");
          if (this.$state === ClientState.Starting) {
            this.$state = ClientState.StartFailed;
          } else {
            this.$state = ClientState.Stopped;
          }
          this._onStop = Promise.resolve();
          this._onStart = void 0;
        } else if (handlerResult.action === CloseAction2.Restart) {
          this.info(handlerResult.message ?? "Connection to server got closed. Server will restart.", !handlerResult.handled);
          this.cleanUp("restart");
          this.$state = ClientState.Initial;
          this._onStop = Promise.resolve();
          this._onStart = void 0;
          this.start().catch((error) => this.error(`Restarting server failed`, error, "force"));
        }
      }
      async handleConnectionError(error, message, count) {
        const handlerResult = await this._clientOptions.errorHandler.error(error, message, count);
        if (handlerResult.action === ErrorAction2.Shutdown) {
          this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring.
${error.message}
Shutting down server.`, void 0, handlerResult.handled === true ? false : "force");
          this.stop().catch((error2) => {
            this.error(`Stopping server failed`, error2, false);
          });
        } else {
          this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring.
${error.message}`, void 0, handlerResult.handled === true ? false : "force");
        }
      }
      hookConfigurationChanged(connection) {
        this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
          this.refreshTrace(connection, true);
        }));
      }
      refreshTrace(connection, sendNotification = false) {
        const config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
          } else {
            trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        }).catch((error) => {
          this.error(`Updating trace failed with error`, error, false);
        });
      }
      hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
          return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
          watchers = fileEvents;
        } else {
          watchers = [fileEvents];
        }
        if (!watchers) {
          return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature);
        }
      }
      registerFeature(feature) {
        this._features.push(feature);
        if (features_1.DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getFeature(request) {
        return this._dynamicFeatures.get(request);
      }
      hasDedicatedTextSynchronizationFeature(textDocument) {
        const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
        if (feature === void 0 || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
          return false;
        }
        return feature.handles(textDocument);
      }
      registerBuiltinFeatures() {
        const pendingFullTextDocumentChanges = /* @__PURE__ */ new Map();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this._didChangeTextDocumentFeature = new textSynchronization_1.DidChangeTextDocumentFeature(this, pendingFullTextDocumentChanges);
        this._didChangeTextDocumentFeature.onPendingChangeAdded(() => {
          this.triggerPendingChangeDelivery();
        });
        this.registerFeature(this._didChangeTextDocumentFeature);
        this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
        this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments, pendingFullTextDocumentChanges));
        this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new completion_1.CompletionItemFeature(this));
        this.registerFeature(new hover_1.HoverFeature(this));
        this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
        this.registerFeature(new definition_1.DefinitionFeature(this));
        this.registerFeature(new reference_1.ReferencesFeature(this));
        this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
        this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
        this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
        this.registerFeature(new codeAction_1.CodeActionFeature(this));
        this.registerFeature(new codeLens_1.CodeLensFeature(this));
        this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new rename_1.RenameFeature(this));
        this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
        this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
        this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        if (this.clientOptions.workspaceFolder === void 0) {
          this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
        }
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
        this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
        this.registerFeature(new inlineValue_1.InlineValueFeature(this));
        this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
        this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
        this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (Is.func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        (0, features_1.ensure)(result, "workspace").applyEdit = true;
        const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: true
        };
        const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = (0, features_1.ensure)(result, "window");
        const showMessage = (0, features_1.ensure)(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = (0, features_1.ensure)(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = (0, features_1.ensure)(result, "general");
        generalCapabilities.staleRequestSupport = {
          cancel: true,
          retryOnContentModified: Array.from(_BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = {
          parser: "marked",
          version: "1.1.0"
        };
        generalCapabilities.positionEncodings = ["utf-16"];
        if (this._clientOptions.markdown.supportHtml) {
          generalCapabilities.markdown.allowedTags = ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"];
        }
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        const documentSelector2 = this._clientOptions.documentSelector;
        for (const feature of this._features) {
          if (Is.func(feature.preInitialize)) {
            feature.preInitialize(this._capabilities, documentSelector2);
          }
        }
        for (const feature of this._features) {
          feature.initialize(this._capabilities, documentSelector2);
        }
      }
      async handleRegistrationRequest(params) {
        const middleware = this.clientOptions.middleware?.handleRegisterCapability;
        if (middleware) {
          return middleware(params, (nextParams) => this.doRegisterCapability(nextParams));
        } else {
          return this.doRegisterCapability(params);
        }
      }
      async doRegisterCapability(params) {
        if (!this.isRunning()) {
          for (const registration of params.registrations) {
            this._ignoredRegistrations.add(registration.id);
          }
          return;
        }
        for (const registration of params.registrations) {
          const feature = this._dynamicFeatures.get(registration.method);
          if (feature === void 0) {
            return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
          }
          const options = registration.registerOptions ?? {};
          options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
          const data = {
            id: registration.id,
            registerOptions: options
          };
          try {
            feature.register(data);
          } catch (err) {
            return Promise.reject(err);
          }
        }
      }
      async handleUnregistrationRequest(params) {
        const middleware = this.clientOptions.middleware?.handleUnregisterCapability;
        if (middleware) {
          return middleware(params, (nextParams) => this.doUnregisterCapability(nextParams));
        } else {
          return this.doUnregisterCapability(params);
        }
      }
      async doUnregisterCapability(params) {
        for (const unregistration of params.unregisterations) {
          if (this._ignoredRegistrations.has(unregistration.id)) {
            continue;
          }
          const feature = this._dynamicFeatures.get(unregistration.method);
          if (!feature) {
            return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
          }
          feature.unregister(unregistration.id);
        }
      }
      async handleApplyWorkspaceEdit(params) {
        const workspaceEdit = params.edit;
        const converted = await this.workspaceEditLock.lock(() => {
          return this._p2c.asWorkspaceEdit(workspaceEdit);
        });
        const openTextDocuments = /* @__PURE__ */ new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              const changeUri = this._p2c.asUri(change.textDocument.uri).toString();
              const textDocument = openTextDocuments.get(changeUri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => {
          return { applied: value };
        }));
      }
      handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
          if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
            return defaultValue;
          }
          if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
            if (token !== void 0 && token.isCancellationRequested) {
              return defaultValue;
            } else {
              if (error.data !== void 0) {
                throw new features_1.LSPCancellationError(error.data);
              } else {
                throw new vscode_1.CancellationError();
              }
            }
          } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
            if (_BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method) || _BaseLanguageClient.CancellableResolveCalls.has(type.method)) {
              throw new vscode_1.CancellationError();
            } else {
              return defaultValue;
            }
          }
        }
        this.error(`Request ${type.method} failed.`, error, showNotification);
        throw error;
      }
    };
    exports2.BaseLanguageClient = BaseLanguageClient;
    BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
      vscode_languageserver_protocol_1.SemanticTokensRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
    ]);
    BaseLanguageClient.CancellableResolveCalls = /* @__PURE__ */ new Set([
      vscode_languageserver_protocol_1.CompletionResolveRequest.method,
      vscode_languageserver_protocol_1.CodeLensResolveRequest.method,
      vscode_languageserver_protocol_1.CodeActionResolveRequest.method,
      vscode_languageserver_protocol_1.InlayHintResolveRequest.method,
      vscode_languageserver_protocol_1.DocumentLinkResolveRequest.method,
      vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.method
    ]);
    var ConsoleLogger = class {
      error(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
      }
      warn(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
      }
      info(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
      }
      log(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
      }
    };
    function createConnection(input, output, errorHandler, closeHandler, options) {
      const logger2 = new ConsoleLogger();
      const connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger2, options);
      connection.onError((data) => {
        errorHandler(data[0], data[1], data[2]);
      });
      connection.onClose(closeHandler);
      const result = {
        listen: () => connection.listen(),
        sendRequest: connection.sendRequest,
        onRequest: connection.onRequest,
        hasPendingResponse: connection.hasPendingResponse,
        sendNotification: connection.sendNotification,
        onNotification: connection.onNotification,
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
          const defaultTraceOptions = {
            sendNotification: false,
            traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
          };
          if (sendNotificationOrTraceOptions === void 0) {
            return connection.trace(value, tracer, defaultTraceOptions);
          } else if (Is.boolean(sendNotificationOrTraceOptions)) {
            return connection.trace(value, tracer, sendNotificationOrTraceOptions);
          } else {
            return connection.trace(value, tracer, sendNotificationOrTraceOptions);
          }
        },
        initialize: (params) => {
          return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
        },
        shutdown: () => {
          return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0);
        },
        exit: () => {
          return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
        },
        end: () => connection.end(),
        dispose: () => connection.dispose()
      };
      return result;
    }
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      function createAll(_client) {
        let result = [
          new inlineCompletion_1.InlineCompletionItemFeature(_client)
        ];
        return result;
      }
      ProposedFeatures2.createAll = createAll;
    })(ProposedFeatures || (exports2.ProposedFeatures = ProposedFeatures = {}));
  }
});

// node_modules/vscode-languageclient/lib/node/processes.js
var require_processes = __commonJS({
  "node_modules/vscode-languageclient/lib/node/processes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.terminate = void 0;
    var cp2 = require("child_process");
    var path_1 = require("path");
    var isWindows2 = process.platform === "win32";
    var isMacintosh = process.platform === "darwin";
    var isLinux2 = process.platform === "linux";
    function terminate(process3, cwd) {
      if (isWindows2) {
        try {
          let options = {
            stdio: ["pipe", "pipe", "ignore"]
          };
          if (cwd) {
            options.cwd = cwd;
          }
          cp2.execFileSync("taskkill", ["/T", "/F", "/PID", process3.pid.toString()], options);
          return true;
        } catch (err) {
          return false;
        }
      } else if (isLinux2 || isMacintosh) {
        try {
          var cmd = (0, path_1.join)(__dirname, "terminateProcess.sh");
          var result = cp2.spawnSync(cmd, [process3.pid.toString()]);
          return result.error ? false : true;
        } catch (err) {
          return false;
        }
      } else {
        process3.kill("SIGKILL");
        return true;
      }
    }
    exports2.terminate = terminate;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug3;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug3 = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug3(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug3 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer3 = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug3("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug3("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug3("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug3("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer3;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer3) {
        return version;
      }
      try {
        return new SemVer3(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var compare = (a, b, loose) => new SemVer3(a, loose).compare(new SemVer3(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug3("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug3("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer3(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug3("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer3(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range5(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range5(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug3 = require_debug();
    var SemVer3 = require_semver();
    var Range5 = require_range();
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range5 = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug3("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug3("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug3("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug3("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug3("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug3("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer3(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range5;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug3 = require_debug();
    var SemVer3 = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug3("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug3("caret", comp);
      comp = replaceTildes(comp, options);
      debug3("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug3("xrange", comp);
      comp = replaceStars(comp, options);
      debug3("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug3("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug3("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug3("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug3("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug3("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug3("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug3("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug3("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug3("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug3("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug3("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug3("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug3("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug3(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range5 = require_range();
    var satisfies2 = (version, range, options) => {
      try {
        range = new Range5(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies2;
  }
});

// node_modules/vscode-languageclient/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageclient/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticPullMode = exports2.vsdiag = void 0;
    __exportStar(require_main3(), exports2);
    __exportStar(require_features(), exports2);
    var diagnostic_1 = require_diagnostic();
    Object.defineProperty(exports2, "vsdiag", { enumerable: true, get: function() {
      return diagnostic_1.vsdiag;
    } });
    Object.defineProperty(exports2, "DiagnosticPullMode", { enumerable: true, get: function() {
      return diagnostic_1.DiagnosticPullMode;
    } });
    __exportStar(require_client(), exports2);
  }
});

// node_modules/vscode-languageclient/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageclient/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingMonitor = exports2.LanguageClient = exports2.TransportKind = void 0;
    var cp2 = require("child_process");
    var fs = require("fs");
    var path11 = require("path");
    var vscode_1 = require("vscode");
    var Is = require_is();
    var client_1 = require_client();
    var processes_1 = require_processes();
    var node_1 = require_node2();
    var semverParse = require_parse();
    var semverSatisfies = require_satisfies();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var REQUIRED_VSCODE_VERSION = "^1.82.0";
    var TransportKind;
    (function(TransportKind2) {
      TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
      TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
      TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
      TransportKind2[TransportKind2["socket"] = 3] = "socket";
    })(TransportKind || (exports2.TransportKind = TransportKind = {}));
    var Transport;
    (function(Transport2) {
      function isSocket(value) {
        const candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
      }
      Transport2.isSocket = isSocket;
    })(Transport || (Transport = {}));
    var Executable;
    (function(Executable2) {
      function is(value) {
        return Is.string(value.command);
      }
      Executable2.is = is;
    })(Executable || (Executable = {}));
    var NodeModule;
    (function(NodeModule2) {
      function is(value) {
        return Is.string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    var StreamInfo;
    (function(StreamInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    var ChildProcessInfo;
    (function(ChildProcessInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    var LanguageClient8 = class extends client_1.BaseLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
          id = arg1;
          name = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id = arg1.toLowerCase();
          name = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        if (forceDebug === void 0) {
          forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this._isInDebugMode = forceDebug;
        try {
          this.checkVersion();
        } catch (error) {
          if (Is.string(error.message)) {
            this.outputChannel.appendLine(error.message);
          }
          throw error;
        }
      }
      checkVersion() {
        const codeVersion = semverParse(vscode_1.version);
        if (!codeVersion) {
          throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
          codeVersion.prerelease = [];
        }
        if (!semverSatisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
          throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
      }
      get isInDebugMode() {
        return this._isInDebugMode;
      }
      async restart() {
        await this.stop();
        if (this.isInDebugMode) {
          await new Promise((resolve3) => setTimeout(resolve3, 1e3));
          await this.start();
        } else {
          await this.start();
        }
      }
      stop(timeout = 2e3) {
        return super.stop(timeout).finally(() => {
          if (this._serverProcess) {
            const toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        });
      }
      checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === void 0) {
          return;
        }
        setTimeout(() => {
          try {
            if (childProcess.pid !== void 0) {
              process.kill(childProcess.pid, 0);
              (0, processes_1.terminate)(childProcess);
            }
          } catch (error) {
          }
        }, 2e3);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        return super.handleConnectionClosed();
      }
      fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
          params.processId = process.pid;
        }
      }
      createMessageTransports(encoding) {
        function getEnvironment(env2, fork) {
          if (!env2 && !fork) {
            return void 0;
          }
          const result = /* @__PURE__ */ Object.create(null);
          Object.keys(process.env).forEach((key) => result[key] = process.env[key]);
          if (fork) {
            result["ELECTRON_RUN_AS_NODE"] = "1";
            result["ELECTRON_NO_ASAR"] = "1";
          }
          if (env2) {
            Object.keys(env2).forEach((key) => result[key] = env2[key]);
          }
          return result;
        }
        const debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="];
        const debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
        function startedInDebugMode() {
          let args = process.execArgv;
          if (args) {
            return args.some((arg) => {
              return debugStartWith.some((value) => arg.startsWith(value)) || debugEquals.some((value) => arg === value);
            });
          }
          return false;
        }
        function assertStdio(process3) {
          if (process3.stdin === null || process3.stdout === null || process3.stderr === null) {
            throw new Error("Process created without stdio streams");
          }
        }
        const server = this._serverOptions;
        if (Is.func(server)) {
          return server().then((result) => {
            if (client_1.MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
            } else {
              let cp3;
              if (ChildProcessInfo.is(result)) {
                cp3 = result.process;
                this._isDetached = result.detached;
              } else {
                cp3 = result;
                this._isDetached = false;
              }
              cp3.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
              return { reader: new node_1.StreamMessageReader(cp3.stdout), writer: new node_1.StreamMessageWriter(cp3.stdin) };
            }
          });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (this._forceDebug || startedInDebugMode()) {
            json = runDebug.debug;
            this._isInDebugMode = true;
          } else {
            json = runDebug.run;
            this._isInDebugMode = false;
          }
        } else {
          json = server;
        }
        return this._getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || TransportKind.stdio;
            if (node.runtime) {
              const args = [];
              const options = node.options ?? /* @__PURE__ */ Object.create(null);
              if (options.execArgv) {
                options.execArgv.forEach((element) => args.push(element));
              }
              args.push(node.module);
              if (node.args) {
                node.args.forEach((element) => args.push(element));
              }
              const execOptions = /* @__PURE__ */ Object.create(null);
              execOptions.cwd = serverWorkingDir;
              execOptions.env = getEnvironment(options.env, false);
              const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
              let pipeName = void 0;
              if (transport === TransportKind.ipc) {
                execOptions.stdio = [null, null, null, "ipc"];
                args.push("--node-ipc");
              } else if (transport === TransportKind.stdio) {
                args.push("--stdio");
              } else if (transport === TransportKind.pipe) {
                pipeName = (0, node_1.generateRandomPipeName)();
                args.push(`--pipe=${pipeName}`);
              } else if (Transport.isSocket(transport)) {
                args.push(`--socket=${transport.port}`);
              }
              args.push(`--clientProcessId=${process.pid.toString()}`);
              if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                const serverProcess = cp2.spawn(runtime, args, execOptions);
                if (!serverProcess || !serverProcess.pid) {
                  return handleChildProcessStartError(serverProcess, `Launching server using runtime ${runtime} failed.`);
                }
                this._serverProcess = serverProcess;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                if (transport === TransportKind.ipc) {
                  serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                } else {
                  return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                }
              } else if (transport === TransportKind.pipe) {
                return (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                  const process3 = cp2.spawn(runtime, args, execOptions);
                  if (!process3 || !process3.pid) {
                    return handleChildProcessStartError(process3, `Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process3;
                  process3.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  process3.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              } else if (Transport.isSocket(transport)) {
                return (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                  const process3 = cp2.spawn(runtime, args, execOptions);
                  if (!process3 || !process3.pid) {
                    return handleChildProcessStartError(process3, `Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process3;
                  process3.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  process3.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              }
            } else {
              let pipeName = void 0;
              return new Promise((resolve3, reject) => {
                const args = (node.args && node.args.slice()) ?? [];
                if (transport === TransportKind.ipc) {
                  args.push("--node-ipc");
                } else if (transport === TransportKind.stdio) {
                  args.push("--stdio");
                } else if (transport === TransportKind.pipe) {
                  pipeName = (0, node_1.generateRandomPipeName)();
                  args.push(`--pipe=${pipeName}`);
                } else if (Transport.isSocket(transport)) {
                  args.push(`--socket=${transport.port}`);
                }
                args.push(`--clientProcessId=${process.pid.toString()}`);
                const options = node.options ?? /* @__PURE__ */ Object.create(null);
                options.env = getEnvironment(options.env, true);
                options.execArgv = options.execArgv || [];
                options.cwd = serverWorkingDir;
                options.silent = true;
                if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                  const sp = cp2.fork(node.module, args || [], options);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  sp.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                  if (transport === TransportKind.ipc) {
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    resolve3({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                  } else {
                    resolve3({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                  }
                } else if (transport === TransportKind.pipe) {
                  (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                    const sp = cp2.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    transport2.onConnected().then((protocol) => {
                      resolve3({ reader: protocol[0], writer: protocol[1] });
                    }, reject);
                  }, reject);
                } else if (Transport.isSocket(transport)) {
                  (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                    const sp = cp2.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    transport2.onConnected().then((protocol) => {
                      resolve3({ reader: protocol[0], writer: protocol[1] });
                    }, reject);
                  }, reject);
                }
              });
            }
          } else if (Executable.is(json) && json.command) {
            const command = json;
            const args = json.args !== void 0 ? json.args.slice(0) : [];
            let pipeName = void 0;
            const transport = json.transport;
            if (transport === TransportKind.stdio) {
              args.push("--stdio");
            } else if (transport === TransportKind.pipe) {
              pipeName = (0, node_1.generateRandomPipeName)();
              args.push(`--pipe=${pipeName}`);
            } else if (Transport.isSocket(transport)) {
              args.push(`--socket=${transport.port}`);
            } else if (transport === TransportKind.ipc) {
              throw new Error(`Transport kind ipc is not support for command executable`);
            }
            const options = Object.assign({}, command.options);
            options.cwd = options.cwd || serverWorkingDir;
            if (transport === void 0 || transport === TransportKind.stdio) {
              const serverProcess = cp2.spawn(command.command, args, options);
              if (!serverProcess || !serverProcess.pid) {
                return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
              }
              serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
              this._serverProcess = serverProcess;
              this._isDetached = !!options.detached;
              return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
            } else if (transport === TransportKind.pipe) {
              return (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                const serverProcess = cp2.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                  return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                }
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                return transport2.onConnected().then((protocol) => {
                  return { reader: protocol[0], writer: protocol[1] };
                });
              });
            } else if (Transport.isSocket(transport)) {
              return (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                const serverProcess = cp2.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                  return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                }
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                return transport2.onConnected().then((protocol) => {
                  return { reader: protocol[0], writer: protocol[1] };
                });
              });
            }
          }
          return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        }).finally(() => {
          if (this._serverProcess !== void 0) {
            this._serverProcess.on("exit", (code, signal) => {
              if (code !== null) {
                this.error(`Server process exited with code ${code}.`, void 0, false);
              }
              if (signal !== null) {
                this.error(`Server process exited with signal ${signal}.`, void 0, false);
              }
            });
          }
        });
      }
      _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path11.isAbsolute(runtime)) {
          return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== void 0) {
          const result = path11.join(mainRootPath, runtime);
          if (fs.existsSync(result)) {
            return result;
          }
        }
        if (serverWorkingDirectory !== void 0) {
          const result = path11.join(serverWorkingDirectory, runtime);
          if (fs.existsSync(result)) {
            return result;
          }
        }
        return runtime;
      }
      _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
          cwd = this.clientOptions.workspaceFolder ? this.clientOptions.workspaceFolder.uri.fsPath : this._mainGetRootPath();
        }
        if (cwd) {
          return new Promise((s) => {
            fs.lstat(cwd, (err, stats) => {
              s(!err && stats.isDirectory() ? cwd : void 0);
            });
          });
        }
        return Promise.resolve(void 0);
      }
    };
    exports2.LanguageClient = LanguageClient8;
    var SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
          if (this._client.needsStop()) {
            void this._client.stop();
          }
        });
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start().catch((error) => this._client.error("Start failed after configuration change", error, "force"));
        } else if (!enabled && this._client.needsStop()) {
          void this._client.stop().catch((error) => this._client.error("Stop failed after configuration change", error, "force"));
        }
      }
    };
    exports2.SettingMonitor = SettingMonitor;
    function handleChildProcessStartError(process3, message) {
      if (process3 === null) {
        return Promise.reject(message);
      }
      return new Promise((_, reject) => {
        process3.on("error", (err) => {
          reject(`${message} ${err}`);
        });
        setImmediate(() => reject(message));
      });
    }
  }
});

// node_modules/vscode-languageclient/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageclient/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/untildify/index.js
var require_untildify = __commonJS({
  "node_modules/untildify/index.js"(exports2, module2) {
    "use strict";
    var os5 = require("os");
    var homeDirectory = os5.homedir();
    module2.exports = (pathWithTilde) => {
      if (typeof pathWithTilde !== "string") {
        throw new TypeError(`Expected a string, got ${typeof pathWithTilde}`);
      }
      return homeDirectory ? pathWithTilde.replace(/^~(?=$|\/|\\)/, homeDirectory) : pathWithTilde;
    };
  }
});

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  PowerShellLanguageId: () => PowerShellLanguageId,
  ShellIntegrationScript: () => ShellIntegrationScript,
  checkIfDirectoryExists: () => checkIfDirectoryExists,
  checkIfFileExists: () => checkIfFileExists,
  escapeSingleQuotes: () => escapeSingleQuotes,
  getPipePath: () => getPipePath,
  getTimestampString: () => getTimestampString,
  isLinux: () => isLinux,
  isMacOS: () => isMacOS,
  isWindows: () => isWindows,
  readDirectory: () => readDirectory,
  sleep: () => sleep,
  stripQuotePair: () => stripQuotePair
});
function escapeSingleQuotes(p) {
  return p.replace(new RegExp("'", "g"), "''");
}
function stripQuotePair(p) {
  if (p === void 0) {
    return p;
  }
  if (p.startsWith("'") && p.endsWith("'") || p.startsWith('"') && p.endsWith('"')) {
    return p.slice(1, -1);
  }
  return p;
}
function getPipePath(pipeName) {
  if (os.platform() === "win32") {
    return "\\\\.\\pipe\\" + pipeName;
  } else {
    return path.join(os.tmpdir(), `CoreFxPipe_${pipeName}`);
  }
}
async function checkIfFileOrDirectoryExists(targetPath, type) {
  if (targetPath === "") {
    return false;
  }
  try {
    const stat = await vscode3.workspace.fs.stat(
      targetPath instanceof vscode3.Uri ? targetPath : vscode3.Uri.file(targetPath)
    );
    return (stat.type & type) !== 0;
  } catch {
    return false;
  }
}
async function checkIfFileExists(filePath) {
  return await checkIfFileOrDirectoryExists(filePath, vscode3.FileType.File);
}
async function checkIfDirectoryExists(directoryPath) {
  return await checkIfFileOrDirectoryExists(
    directoryPath,
    vscode3.FileType.Directory
  );
}
async function readDirectory(directoryPath) {
  const items = await vscode3.workspace.fs.readDirectory(
    directoryPath instanceof vscode3.Uri ? directoryPath : vscode3.Uri.file(directoryPath)
  );
  return items.map(([name, _type]) => name);
}
function getTimestampString() {
  const time = /* @__PURE__ */ new Date();
  return `[${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}]`;
}
function sleep(ms) {
  return new Promise((resolve3) => setTimeout(resolve3, ms));
}
var os, path, vscode3, PowerShellLanguageId, ShellIntegrationScript, isMacOS, isWindows, isLinux;
var init_utils = __esm({
  "src/utils.ts"() {
    "use strict";
    os = require("os");
    path = require("path");
    vscode3 = require("vscode");
    PowerShellLanguageId = "powershell";
    ShellIntegrationScript = path.join(
      vscode3.env.appRoot,
      "out",
      "vs",
      "workbench",
      "contrib",
      "terminal",
      "common",
      "scripts",
      "shellIntegration.ps1"
    );
    isMacOS = process.platform === "darwin";
    isWindows = process.platform === "win32";
    isLinux = !isMacOS && !isWindows;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer3(
          version instanceof SemVer3 ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var major = (a, loose) => new SemVer3(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var minor = (a, loose) => new SemVer3(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var patch = (a, loose) => new SemVer3(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer3(a, loose);
      const versionB = new SemVer3(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer3) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range5 = require_range();
    var toComparators = (range, options) => new Range5(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var Range5 = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range5(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer3(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var Range5 = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range5(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer3(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var Range5 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range5(range, loose);
      let minver = new SemVer3("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer3("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer3(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range5 = require_range();
    var validRange = (range, options) => {
      try {
        return new Range5(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer3 = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range5 = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer3(version, options);
      range = new Range5(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range5 = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range5(r1, options);
      r2 = new Range5(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies2(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range5 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range5(sub, options);
      dom = new Range5(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies2(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies2(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies2(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer3 = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range5 = require_range();
    var satisfies2 = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range: Range5,
      satisfies: satisfies2,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer: SemVer3,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound) x = lowerBound;
          if (x > upperBound) x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path11 = url.path;
      if (path11.length === 0) {
        return;
      }
      if (url.scheme === "file" && path11.length === 1 && isNormalizedWindowsDriveLetter(path11[0])) {
        return;
      }
      path11.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer2) {
      return String(integer2);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib();
    var utils6 = require_utils();
    var Impl = require_URL_impl();
    var impl = utils6.implSymbol;
    function URL(url) {
      if (!this || this[impl] || !(this instanceof URL)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils6.wrapperSymbol] = obj;
      },
      interface: URL,
      expose: {
        Window: { URL },
        Worker: { URL }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body)) ;
      else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve3, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve3(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers2 = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
    Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers2.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers2();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers2(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers2(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers2(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch3(url, opts) {
      if (!fetch3.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch3.Promise;
      return new fetch3.Promise(function(resolve3, reject) {
        const request = new Request2(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s) {
            s.addListener("close", function(hadError) {
              const hasDataListener = s.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch3.isRedirect(res.statusCode)) {
            const location2 = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location2 === null ? null : new URL$1(location2, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve3(fetch3(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve3(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve3(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve3(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response(body, response_options);
                resolve3(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve3(response);
            return;
          }
          response = new Response(body, response_options);
          resolve3(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s) {
        socket = s;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    module2.exports = exports2 = fetch3;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers2;
    exports2.Request = Request2;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(extension_exports);
var import_extension_telemetry = __toESM(require_telemetryReporter());
var import_vscode_languageclient10 = __toESM(require_main4());

// src/features/CodeActions.ts
var vscode = require("vscode");
var CodeActionsFeature = class {
  constructor(log) {
    this.log = log;
    this.command = vscode.commands.registerCommand(
      "PowerShell.ShowCodeActionDocumentation",
      async (ruleName) => {
        await this.showRuleDocumentation(ruleName);
      }
    );
  }
  command;
  dispose() {
    this.command.dispose();
  }
  async showRuleDocumentation(ruleId) {
    const pssaDocBaseURL = "https://docs.microsoft.com/powershell/utility-modules/psscriptanalyzer/rules/";
    if (!ruleId) {
      this.log.writeWarning(
        "Cannot show documentation for code action, no ruleName was supplied."
      );
      return;
    }
    if (ruleId.startsWith("PS")) {
      ruleId = ruleId.substring(2);
    }
    await vscode.commands.executeCommand(
      "vscode.open",
      vscode.Uri.parse(pssaDocBaseURL + ruleId)
    );
  }
};

// src/features/Console.ts
var import_vscode_languageclient = __toESM(require_main4());
var import_node2 = __toESM(require_node3());

// src/controls/checkboxQuickPick.ts
var vscode2 = require("vscode");
var confirmItemLabel = "$(checklist) Confirm";
var checkedPrefix = "[ $(check) ]";
var uncheckedPrefix = "[     ]";
var defaultPlaceHolder = "Select 'Confirm' to confirm or press 'Esc' key to cancel";
var defaultOptions = {
  confirmPlaceHolder: defaultPlaceHolder
};
async function showCheckboxQuickPick(items, options = defaultOptions) {
  const selectedItem = await showInner(items, options);
  return selectedItem !== void 0 ? items : void 0;
}
function getQuickPickItems(items) {
  const quickPickItems = [];
  quickPickItems.push({ label: confirmItemLabel, description: "" });
  for (const item of items) {
    quickPickItems.push({
      label: convertToCheckBox(item),
      description: item.description
    });
  }
  return quickPickItems;
}
async function showInner(items, options) {
  const selection = await vscode2.window.showQuickPick(
    getQuickPickItems(items),
    {
      ignoreFocusOut: true,
      matchOnDescription: true,
      placeHolder: options.confirmPlaceHolder
    }
  );
  if (selection === void 0) {
    return void 0;
  }
  if (selection.label === confirmItemLabel) {
    return selection;
  }
  const index = getItemIndex(items, selection.label);
  if (index >= 0) {
    toggleSelection(items[index]);
  } else {
    console.log(
      `Couldn't find CheckboxQuickPickItem for label '${selection.label}'`
    );
  }
  return showInner(items, options);
}
function getItemIndex(items, itemLabel) {
  const trimmedLabel = itemLabel.substring(itemLabel.indexOf("]") + 2);
  return items.findIndex((item) => item.label === trimmedLabel);
}
function toggleSelection(item) {
  item.isSelected = !item.isSelected;
}
function convertToCheckBox(item) {
  return `${item.isSelected ? checkedPrefix : uncheckedPrefix} ${item.label}`;
}

// src/languageClientConsumer.ts
var import_vscode = require("vscode");
var import_node = __toESM(require_node3());
var LanguageClientConsumer = class _LanguageClientConsumer {
  static languageClientPromise;
  static getLanguageClientResolve;
  // This is called in the session manager when the client is started (so we
  // can wait for that). It's what actually resolves the promise.
  static onLanguageClientStarted(languageClient) {
    this.languageClientPromise ??= Promise.resolve(languageClient);
    this.getLanguageClientResolve?.(languageClient);
  }
  // This is called in the session manager when the client exits so we can
  // make a new promise.
  static onLanguageClientExited() {
    this.languageClientPromise = void 0;
    this.getLanguageClientResolve = void 0;
  }
  // We should have a promise as defined in resetLanguageClient, but if we
  // don't, create it.
  static async getLanguageClient() {
    _LanguageClientConsumer.languageClientPromise?.catch(() => {
      _LanguageClientConsumer.languageClientPromise = void 0;
    });
    _LanguageClientConsumer.languageClientPromise ??= _LanguageClientConsumer.createLanguageClientPromise();
    return _LanguageClientConsumer.languageClientPromise;
  }
  // This waits for the language client to start and shows a cancellable
  // loading message. (It just wrap the static method below.)
  static async createLanguageClientPromise() {
    return import_vscode.window.withProgress(
      {
        location: import_vscode.ProgressLocation.Notification,
        title: "Please wait, starting PowerShell Extension Terminal...",
        cancellable: true
      },
      (_progress, token) => {
        token.onCancellationRequested(() => {
          void import_vscode.window.showErrorMessage(
            "Cancelled PowerShell Extension Terminal start-up."
          );
        });
        return new Promise((resolve3, reject) => {
          _LanguageClientConsumer.getLanguageClientResolve = resolve3;
          token.onCancellationRequested(() => {
            reject(
              new Error(
                "Cancelled PowerShell Extension Terminal start-up."
              )
            );
          });
        });
      }
    );
  }
};

// src/settings.ts
var import_untildify = __toESM(require_untildify());
var vscode4 = require("vscode");
var utils = (init_utils(), __toCommonJS(utils_exports));
var os2 = require("os");
var path2 = require("path");
var PartialSettings = class {
};
var Settings = class extends PartialSettings {
  powerShellAdditionalExePaths = {};
  powerShellDefaultVersion = "";
  promptToUpdatePowerShell = true;
  suppressAdditionalExeNotFoundWarning = false;
  startAsLoginShell = new StartAsLoginShellSettings();
  startAutomatically = true;
  enableProfileLoading = true;
  helpCompletion = "BlockComment" /* BlockComment */;
  scriptAnalysis = new ScriptAnalysisSettings();
  debugging = new DebuggingSettings();
  developer = new DeveloperSettings();
  codeFormatting = new CodeFormattingSettings();
  integratedConsole = new IntegratedConsoleSettings();
  sideBar = new SideBarSettings();
  pester = new PesterSettings();
  buttons = new ButtonSettings();
  cwd = "";
  // NOTE: use validateCwdSetting() instead of this directly!
  enableReferencesCodeLens = true;
  analyzeOpenDocumentsOnly = false;
  // TODO: Add (deprecated) useX86Host (for testing)
};
var CodeFormattingSettings = class extends PartialSettings {
  autoCorrectAliases = false;
  avoidSemicolonsAsLineTerminators = false;
  preset = "Custom" /* Custom */;
  openBraceOnSameLine = true;
  newLineAfterOpenBrace = true;
  newLineAfterCloseBrace = true;
  pipelineIndentationStyle = "NoIndentation" /* NoIndentation */;
  whitespaceBeforeOpenBrace = true;
  whitespaceBeforeOpenParen = true;
  whitespaceAroundOperator = true;
  whitespaceAfterSeparator = true;
  whitespaceBetweenParameters = false;
  whitespaceInsideBrace = true;
  addWhitespaceAroundPipe = true;
  trimWhitespaceAroundPipe = false;
  ignoreOneLineBlock = true;
  alignPropertyValuePairs = true;
  useConstantStrings = false;
  useCorrectCasing = false;
};
var ScriptAnalysisSettings = class extends PartialSettings {
  enable = true;
  settingsPath = "PSScriptAnalyzerSettings.psd1";
};
var DebuggingSettings = class extends PartialSettings {
  createTemporaryIntegratedConsole = false;
  executeMode = "DotSource" /* DotSource */;
};
var DeveloperSettings = class extends PartialSettings {
  featureFlags = [];
  // From `<root>/out/main.js` we go to the directory before <root> and
  // then into the other repo.
  bundledModulesPath = "../../PowerShellEditorServices/module";
  editorServicesWaitForDebugger = false;
  setExecutionPolicy = true;
  waitForSessionFileTimeoutSeconds = 240;
};
var StartAsLoginShellSettings = class extends PartialSettings {
  osx = true;
  linux = false;
};
var IntegratedConsoleSettings = class extends PartialSettings {
  showOnStartup = true;
  startInBackground = false;
  focusConsoleOnExecute = true;
  useLegacyReadLine = false;
  forceClearScrollbackBuffer = false;
  suppressStartupBanner = false;
  startLocation = "Panel" /* Panel */;
};
var SideBarSettings = class extends PartialSettings {
  CommandExplorerVisibility = false;
  CommandExplorerExcludeFilter = [];
};
var PesterSettings = class extends PartialSettings {
  useLegacyCodeLens = true;
  outputVerbosity = "FromPreference";
  debugOutputVerbosity = "Diagnostic";
};
var ButtonSettings = class extends PartialSettings {
  showRunButtons = true;
  showPanelMovementButtons = false;
};
function getSetting(key, value, configuration) {
  if (key !== void 0 && !(value instanceof PartialSettings)) {
    return configuration.get(key, value);
  }
  for (const property in value) {
    const subKey = key !== void 0 ? `${key}.${property}` : property;
    value[property] = getSetting(subKey, value[property], configuration);
  }
  return value;
}
function getSettings() {
  const configuration = vscode4.workspace.getConfiguration(utils.PowerShellLanguageId);
  return getSetting(void 0, new Settings(), configuration);
}
function getEffectiveConfigurationTarget(settingName) {
  const configuration = vscode4.workspace.getConfiguration(
    utils.PowerShellLanguageId
  );
  const detail = configuration.inspect(settingName);
  if (detail === void 0) {
    return void 0;
  } else if (typeof detail.workspaceFolderValue !== "undefined") {
    return vscode4.ConfigurationTarget.WorkspaceFolder;
  } else if (typeof detail.workspaceValue !== "undefined") {
    return vscode4.ConfigurationTarget.Workspace;
  } else if (typeof detail.globalValue !== "undefined") {
    return vscode4.ConfigurationTarget.Global;
  }
  return void 0;
}
async function changeSetting(settingName, newValue, configurationTarget, logger2) {
  logger2?.writeDebug(
    `Changing '${settingName}' at scope '${configurationTarget}' to '${newValue}'.`
  );
  try {
    const configuration = vscode4.workspace.getConfiguration(
      utils.PowerShellLanguageId
    );
    await configuration.update(settingName, newValue, configurationTarget);
  } catch (err) {
    logger2?.writeError(`Failed to change setting: ${err}`);
  }
}
var hasChosen = false;
var chosenWorkspace = void 0;
async function getChosenWorkspace(logger2) {
  if (hasChosen) {
    return chosenWorkspace;
  }
  if (vscode4.workspace.workspaceFolders === void 0 || vscode4.workspace.workspaceFolders.length === 0) {
    chosenWorkspace = void 0;
  } else if (vscode4.workspace.workspaceFolders.length === 1) {
    chosenWorkspace = vscode4.workspace.workspaceFolders[0];
  } else if (vscode4.workspace.workspaceFolders.length > 1) {
    const options = {
      placeHolder: "Select a workspace folder to use for the PowerShell Extension."
    };
    chosenWorkspace = await vscode4.window.showWorkspaceFolderPick(options);
    logger2?.writeDebug(
      `User selected workspace: '${chosenWorkspace?.name}'`
    );
    if (chosenWorkspace === void 0) {
      chosenWorkspace = vscode4.workspace.workspaceFolders[0];
    } else {
      const response = await vscode4.window.showInformationMessage(
        `Would you like to save this choice by setting this workspace's 'powershell.cwd' value to '${chosenWorkspace.name}'?`,
        "Yes",
        "No"
      );
      if (response === "Yes") {
        await changeSetting(
          "cwd",
          chosenWorkspace.name,
          vscode4.ConfigurationTarget.Workspace,
          logger2
        );
      }
    }
  }
  hasChosen = true;
  return chosenWorkspace;
}
async function validateCwdSetting(logger2) {
  let cwd = utils.stripQuotePair(
    vscode4.workspace.getConfiguration(utils.PowerShellLanguageId).get("cwd")
  ) ?? "";
  cwd = (0, import_untildify.default)(cwd);
  if (path2.isAbsolute(cwd) && await utils.checkIfDirectoryExists(cwd)) {
    return cwd;
  }
  if (vscode4.workspace.workspaceFolders) {
    for (const workspaceFolder of vscode4.workspace.workspaceFolders) {
      if (cwd === workspaceFolder.name) {
        hasChosen = true;
        chosenWorkspace = workspaceFolder;
        cwd = "";
      }
    }
  }
  const workspace5 = await getChosenWorkspace(logger2);
  if (workspace5 === void 0) {
    logger2?.writeDebug("Workspace was undefined, using homedir!");
    return os2.homedir();
  }
  const workspacePath = workspace5.uri.fsPath;
  const relativePath = path2.join(workspacePath, cwd);
  if (await utils.checkIfDirectoryExists(relativePath)) {
    return relativePath;
  }
  if (await utils.checkIfDirectoryExists(workspacePath)) {
    return workspacePath;
  }
  return os2.homedir();
}

// src/features/Console.ts
var vscode5 = require("vscode");
var EvaluateRequestType = new import_vscode_languageclient.RequestType("evaluate");
var OutputNotificationType = new import_vscode_languageclient.NotificationType("output");
var ShowChoicePromptRequestType = new import_vscode_languageclient.RequestType("powerShell/showChoicePrompt");
var ShowInputPromptRequestType = new import_vscode_languageclient.RequestType("powerShell/showInputPrompt");
function showChoicePrompt(promptDetails) {
  let resultThenable;
  if (!promptDetails.isMultiChoice) {
    let quickPickItems = promptDetails.choices.map(
      (choice) => {
        return {
          label: choice.label,
          description: choice.helpMessage
        };
      }
    );
    if (promptDetails.defaultChoices.length > 0) {
      const defaultChoice = promptDetails.defaultChoices[0];
      if (defaultChoice > -1 && defaultChoice < promptDetails.choices.length) {
        const defaultChoiceItem = quickPickItems[defaultChoice];
        quickPickItems.splice(defaultChoice, 1);
        quickPickItems = [defaultChoiceItem].concat(quickPickItems);
      }
    }
    resultThenable = vscode5.window.showQuickPick(quickPickItems, {
      placeHolder: promptDetails.message
    }).then(onItemSelected);
  } else {
    const checkboxQuickPickItems = promptDetails.choices.map((choice) => {
      return {
        label: choice.label,
        description: choice.helpMessage,
        isSelected: false
      };
    });
    for (const choice of promptDetails.defaultChoices) {
      checkboxQuickPickItems[choice].isSelected = true;
    }
    resultThenable = showCheckboxQuickPick(checkboxQuickPickItems, {
      confirmPlaceHolder: promptDetails.message
    }).then(onItemsSelected);
  }
  return resultThenable;
}
async function showInputPrompt(promptDetails) {
  const responseText = await vscode5.window.showInputBox({
    placeHolder: promptDetails.name + ": "
  });
  return onInputEntered(responseText);
}
function onItemsSelected(chosenItems) {
  if (chosenItems !== void 0) {
    return {
      promptCancelled: false,
      responseText: chosenItems.filter((item) => item.isSelected).map((item) => item.label).join(", ")
    };
  } else {
    return {
      promptCancelled: true,
      responseText: void 0
    };
  }
}
function onItemSelected(chosenItem) {
  if (chosenItem !== void 0) {
    return {
      promptCancelled: false,
      responseText: chosenItem.label
    };
  } else {
    return {
      promptCancelled: true,
      responseText: void 0
    };
  }
}
function onInputEntered(responseText) {
  if (responseText !== void 0) {
    return {
      promptCancelled: false,
      responseText
    };
  } else {
    return {
      promptCancelled: true,
      responseText: void 0
    };
  }
}
var ConsoleFeature = class extends LanguageClientConsumer {
  constructor(logger2) {
    super();
    this.logger = logger2;
    this.commands = [
      vscode5.commands.registerCommand(
        "PowerShell.RunSelection",
        async () => {
          if (vscode5.window.activeTerminal && vscode5.window.activeTerminal.name !== "PowerShell Extension") {
            this.logger.write(
              "PowerShell Extension Terminal is not active! Running in current terminal using 'runSelectedText'."
            );
            await vscode5.commands.executeCommand(
              "workbench.action.terminal.runSelectedText"
            );
            vscode5.window.activeTerminal.show(
              !getSettings().integratedConsole.focusConsoleOnExecute
            );
            await vscode5.commands.executeCommand(
              "workbench.action.terminal.scrollToBottom"
            );
            return;
          }
          const editor = vscode5.window.activeTextEditor;
          if (editor === void 0) {
            return;
          }
          let selectionRange;
          if (!editor.selection.isEmpty) {
            selectionRange = new vscode5.Range(
              editor.selection.start,
              editor.selection.end
            );
          } else {
            selectionRange = editor.document.lineAt(
              editor.selection.start.line
            ).range;
          }
          const client = await LanguageClientConsumer.getLanguageClient();
          await client.sendRequest(EvaluateRequestType, {
            expression: editor.document.getText(selectionRange)
          });
          await vscode5.commands.executeCommand(
            "PowerShell.ShowSessionConsole",
            true
          );
          await vscode5.commands.executeCommand(
            "workbench.action.terminal.scrollToBottom"
          );
        }
      )
    ];
  }
  commands;
  handlers = [];
  dispose() {
    for (const command of this.commands) {
      command.dispose();
    }
    for (const handler of this.handlers) {
      handler.dispose();
    }
  }
  onLanguageClientSet(languageClient) {
    this.handlers = [
      languageClient.onRequest(
        ShowChoicePromptRequestType,
        (promptDetails) => showChoicePrompt(promptDetails)
      ),
      languageClient.onRequest(
        ShowInputPromptRequestType,
        (promptDetails) => showInputPrompt(promptDetails)
      )
    ];
  }
};

// src/features/DebugSession.ts
var import_path = __toESM(require("path"));
var import_vscode3 = require("vscode");
var import_vscode_languageclient3 = __toESM(require_main4());
var import_node4 = __toESM(require_node3());

// src/platform.ts
var os3 = __toESM(require("os"));
var path3 = __toESM(require("path"));
var process2 = __toESM(require("process"));
var import_untildify2 = __toESM(require_untildify());
var import_vscode_languageserver_protocol = __toESM(require_main3());
init_utils();
var vscode6 = require("vscode");
var WindowsPowerShell64BitLabel = "Windows PowerShell (x64)";
var WindowsPowerShell32BitLabel = "Windows PowerShell (x86)";
var LinuxExePath = "/usr/bin/pwsh";
var LinuxPreviewExePath = "/usr/bin/pwsh-preview";
var SnapExePath = "/snap/bin/pwsh";
var SnapPreviewExePath = "/snap/bin/pwsh-preview";
var MacOSExePath = "/usr/local/bin/pwsh";
var MacOSPreviewExePath = "/usr/local/bin/pwsh-preview";
var MacOSHomebrewExePath = "/opt/homebrew/bin/pwsh";
var MacOSHomebrewLTSExePath = "/opt/homebrew/bin/pwsh-lts";
var MacOSHomebrewPreviewExePath = "/opt/homebrew/bin/pwsh-preview";
var OperatingSystem = /* @__PURE__ */ ((OperatingSystem2) => {
  OperatingSystem2[OperatingSystem2["Unknown"] = 0] = "Unknown";
  OperatingSystem2[OperatingSystem2["Windows"] = 1] = "Windows";
  OperatingSystem2[OperatingSystem2["MacOS"] = 2] = "MacOS";
  OperatingSystem2[OperatingSystem2["Linux"] = 3] = "Linux";
  return OperatingSystem2;
})(OperatingSystem || {});
function getPlatformDetails() {
  let operatingSystem = 0 /* Unknown */;
  if (process2.platform === "win32") {
    operatingSystem = 1 /* Windows */;
  } else if (process2.platform === "darwin") {
    operatingSystem = 2 /* MacOS */;
  } else if (process2.platform === "linux") {
    operatingSystem = 3 /* Linux */;
  }
  const isProcess64Bit = process2.arch === "x64" || process2.arch === "arm64";
  return {
    operatingSystem,
    isOS64Bit: isProcess64Bit || process2.env.PROCESSOR_ARCHITEW6432 !== void 0,
    isProcess64Bit
  };
}
var PowerShellExeFinder = class _PowerShellExeFinder {
  /**
   * Create a new PowerShellFinder object to discover PowerShell installations.
   * @param platformDetails Information about the machine we are running on.
   * @param additionalPowerShellExes Additional PowerShell installations as configured in the settings.
   */
  constructor(platformDetails, additionalPowerShellExes, logger2) {
    this.platformDetails = platformDetails;
    this.additionalPowerShellExes = additionalPowerShellExes;
    this.logger = logger2;
  }
  // This is required, since parseInt("7-preview") will return 7.
  static IntRegex = /^\d+$/;
  static PwshMsixRegex = /^Microsoft.PowerShell_.*/;
  static PwshPreviewMsixRegex = /^Microsoft.PowerShellPreview_.*/;
  winPS;
  alternateBitnessWinPS;
  /**
   * Returns the first available PowerShell executable found in the search order.
   */
  async getFirstAvailablePowerShellInstallation() {
    for await (const pwsh of this.enumeratePowerShellInstallations()) {
      return pwsh;
    }
    return void 0;
  }
  /**
   * Get an array of all PowerShell executables found when searching for PowerShell installations.
   */
  async getAllAvailablePowerShellInstallations() {
    const array = [];
    for await (const pwsh of this.enumeratePowerShellInstallations()) {
      array.push(pwsh);
    }
    return array;
  }
  /**
   * Fixes PowerShell paths when Windows PowerShell is set to the non-native bitness.
   * @param configuredPowerShellPath the PowerShell path configured by the user.
   */
  fixWindowsPowerShellPath(configuredPowerShellPath) {
    const altWinPS = this.findWinPS({ useAlternateBitness: true });
    if (!altWinPS) {
      return configuredPowerShellPath;
    }
    const lowerAltWinPSPath = altWinPS.exePath.toLocaleLowerCase();
    const lowerConfiguredPath = configuredPowerShellPath.toLocaleLowerCase();
    if (lowerConfiguredPath === lowerAltWinPSPath) {
      return this.findWinPS()?.exePath;
    }
    return configuredPowerShellPath;
  }
  /**
   * Iterates through PowerShell installations on the machine according
   * to configuration passed in through the constructor.
   * PowerShell items returned by this object are verified
   * to exist on the filesystem.
   */
  async *enumeratePowerShellInstallations() {
    for await (const defaultPwsh of this.enumerateDefaultPowerShellInstallations()) {
      if (defaultPwsh && await defaultPwsh.exists()) {
        yield defaultPwsh;
      }
    }
    for await (const additionalPwsh of this.enumerateAdditionalPowerShellInstallations()) {
      if (await additionalPwsh.exists()) {
        yield additionalPwsh;
      } else if (!additionalPwsh.suppressWarning) {
        const message = `Additional PowerShell '${additionalPwsh.displayName}' not found at '${additionalPwsh.exePath}'!`;
        this.logger?.writeWarning(message);
        if (!getSettings().suppressAdditionalExeNotFoundWarning) {
          const selection = await vscode6.window.showWarningMessage(
            message,
            "Don't Show Again"
          );
          if (selection !== void 0) {
            await changeSetting(
              "suppressAdditionalExeNotFoundWarning",
              true,
              true,
              this.logger
            );
          }
        }
      }
    }
  }
  /**
   * Iterates through all the possible well-known PowerShell installations on a machine.
   * Returned values may not exist, but come with an .exists property
   * which will check whether the executable exists.
   * TODO: We really need to define the order in which we search for stable/LTS/preview/daily
   */
  async *enumerateDefaultPowerShellInstallations() {
    yield this.findPSCoreStable();
    switch (this.platformDetails.operatingSystem) {
      case 3 /* Linux */:
        yield this.findPSCoreStableSnap();
        break;
      case 1 /* Windows */:
        yield this.findPSCoreWindowsInstallation({
          useAlternateBitness: true
        });
        yield await this.findPSCoreMsix();
        break;
      case 2 /* MacOS */:
        yield this.findPSCoreHomebrewStable();
        yield this.findPSCoreHomebrewLTS();
        break;
    }
    yield this.findPSCoreDotnetGlobalTool();
    yield this.findPSCorePreview();
    switch (this.platformDetails.operatingSystem) {
      // On Linux, there might be a preview snap
      case 3 /* Linux */:
        yield this.findPSCorePreviewSnap();
        break;
      case 1 /* Windows */:
        yield this.findPSCoreMsix({ findPreview: true });
        yield this.findPSCoreWindowsInstallation({
          useAlternateBitness: true,
          findPreview: true
        });
        yield this.findWinPS();
        yield this.findWinPS({ useAlternateBitness: true });
        break;
      case 2 /* MacOS */:
        yield this.findPSCoreHomebrewPreview();
        break;
    }
    yield this.findPSCoreDaily();
  }
  /**
   * Iterates through the configured additional PowerShell executable locations,
   * without checking for their existence.
   */
  async *enumerateAdditionalPowerShellInstallations() {
    for (const versionName in this.additionalPowerShellExes) {
      if (Object.prototype.hasOwnProperty.call(
        this.additionalPowerShellExes,
        versionName
      )) {
        let exePath = stripQuotePair(
          this.additionalPowerShellExes[versionName]
        );
        if (!exePath) {
          continue;
        }
        exePath = (0, import_untildify2.default)(exePath);
        const args = (
          // Must be a tuple type and is suppressing the warning
          [versionName, void 0, true, true]
        );
        let pwsh = new PossiblePowerShellExe(exePath, ...args);
        if (await pwsh.exists()) {
          yield pwsh;
          continue;
        }
        if (this.platformDetails.operatingSystem === 1 /* Windows */) {
          if (!exePath.endsWith("pwsh.exe") && !exePath.endsWith("powershell.exe")) {
            if (exePath.endsWith("pwsh") || exePath.endsWith("powershell")) {
              pwsh = new PossiblePowerShellExe(
                exePath + ".exe",
                ...args
              );
              if (await pwsh.exists()) {
                yield pwsh;
                continue;
              }
            }
            pwsh = new PossiblePowerShellExe(
              path3.join(exePath, "pwsh.exe"),
              ...args
            );
            if (await pwsh.exists()) {
              yield pwsh;
              continue;
            }
            pwsh = new PossiblePowerShellExe(
              path3.join(exePath, "powershell.exe"),
              ...args
            );
            if (await pwsh.exists()) {
              yield pwsh;
              continue;
            }
          }
        } else if (!exePath.endsWith("pwsh")) {
          pwsh = new PossiblePowerShellExe(
            path3.join(exePath, "pwsh"),
            ...args
          );
          if (await pwsh.exists()) {
            yield pwsh;
            continue;
          }
        }
        yield new PossiblePowerShellExe(
          exePath,
          versionName,
          false,
          void 0,
          false
        );
      }
    }
  }
  async findPSCoreStable() {
    switch (this.platformDetails.operatingSystem) {
      case 3 /* Linux */:
        return new PossiblePowerShellExe(LinuxExePath, "PowerShell");
      case 2 /* MacOS */:
        return new PossiblePowerShellExe(MacOSExePath, "PowerShell");
      case 1 /* Windows */:
        return await this.findPSCoreWindowsInstallation();
      case 0 /* Unknown */:
        return void 0;
    }
  }
  async findPSCorePreview() {
    switch (this.platformDetails.operatingSystem) {
      case 3 /* Linux */:
        return new PossiblePowerShellExe(
          LinuxPreviewExePath,
          "PowerShell Preview"
        );
      case 2 /* MacOS */:
        return new PossiblePowerShellExe(
          MacOSPreviewExePath,
          "PowerShell Preview"
        );
      case 1 /* Windows */:
        return await this.findPSCoreWindowsInstallation({
          findPreview: true
        });
      case 0 /* Unknown */:
        return void 0;
    }
  }
  /**
   * If the daily was installed via 'https://aka.ms/install-powershell.ps1', then
   * this is the default installation location:
   *
   * if ($IsWinEnv) {
   *     $Destination = "$env:LOCALAPPDATA\Microsoft\powershell"
   * } else {
   *     $Destination = "~/.powershell"
   * }
   *
   * if ($Daily) {
   *     $Destination = "${Destination}-daily"
   * }
   *
   * TODO: Remove this after the daily is officially no longer supported.
   */
  findPSCoreDaily() {
    switch (this.platformDetails.operatingSystem) {
      case 3 /* Linux */:
      case 2 /* MacOS */: {
        const exePath = path3.join(
          os3.homedir(),
          ".powershell-daily",
          "pwsh"
        );
        return new PossiblePowerShellExe(exePath, "PowerShell Daily");
      }
      case 1 /* Windows */: {
        if (!process2.env.LOCALAPPDATA) {
          return void 0;
        }
        const exePath = path3.join(
          process2.env.LOCALAPPDATA,
          "Microsoft",
          "powershell-daily",
          "pwsh.exe"
        );
        return new PossiblePowerShellExe(exePath, "PowerShell Daily");
      }
      case 0 /* Unknown */:
        return void 0;
    }
  }
  // The Homebrew installations of PowerShell on Apple Silicon are no longer in the default PATH.
  findPSCoreHomebrewStable() {
    return new PossiblePowerShellExe(
      MacOSHomebrewExePath,
      "PowerShell (Homebrew)"
    );
  }
  findPSCoreHomebrewLTS() {
    return new PossiblePowerShellExe(
      MacOSHomebrewLTSExePath,
      "PowerShell LTS (Homebrew)"
    );
  }
  findPSCoreHomebrewPreview() {
    return new PossiblePowerShellExe(
      MacOSHomebrewPreviewExePath,
      "PowerShell Preview (Homebrew)"
    );
  }
  findPSCoreDotnetGlobalTool() {
    const exeName = this.platformDetails.operatingSystem === 1 /* Windows */ ? "pwsh.exe" : "pwsh";
    const dotnetGlobalToolExePath = path3.join(
      os3.homedir(),
      ".dotnet",
      "tools",
      exeName
    );
    return new PossiblePowerShellExe(
      dotnetGlobalToolExePath,
      ".NET Core PowerShell Global Tool",
      void 0,
      false
    );
  }
  async findPSCoreMsix({
    findPreview
  } = {}) {
    if (!process2.env.LOCALAPPDATA) {
      return void 0;
    }
    const msixAppDir = path3.join(
      process2.env.LOCALAPPDATA,
      "Microsoft",
      "WindowsApps"
    );
    if (!await checkIfDirectoryExists(msixAppDir)) {
      return void 0;
    }
    const { pwshMsixDirRegex, pwshMsixName } = findPreview ? {
      pwshMsixDirRegex: _PowerShellExeFinder.PwshPreviewMsixRegex,
      pwshMsixName: "PowerShell Preview (Store)"
    } : {
      pwshMsixDirRegex: _PowerShellExeFinder.PwshMsixRegex,
      pwshMsixName: "PowerShell (Store)"
    };
    for (const name of await readDirectory(msixAppDir)) {
      if (pwshMsixDirRegex.test(name)) {
        return new PossiblePowerShellExe(
          path3.join(msixAppDir, name, "pwsh.exe"),
          pwshMsixName
        );
      }
    }
    return void 0;
  }
  // TODO: Are snaps still a thing?
  findPSCoreStableSnap() {
    return new PossiblePowerShellExe(SnapExePath, "PowerShell Snap");
  }
  findPSCorePreviewSnap() {
    return new PossiblePowerShellExe(
      SnapPreviewExePath,
      "PowerShell Preview Snap"
    );
  }
  async findPSCoreWindowsInstallation({
    useAlternateBitness = false,
    findPreview = false
  } = {}) {
    const programFilesPath = this.getProgramFilesPath({
      useAlternateBitness
    });
    if (!programFilesPath) {
      return void 0;
    }
    const powerShellInstallBaseDir = path3.join(
      programFilesPath,
      "PowerShell"
    );
    if (!await checkIfDirectoryExists(powerShellInstallBaseDir)) {
      return void 0;
    }
    let highestSeenVersion = -1;
    let pwshExePath;
    for (const item of await readDirectory(
      powerShellInstallBaseDir
    )) {
      let currentVersion = -1;
      if (findPreview) {
        const dashIndex = item.indexOf("-");
        if (dashIndex < 0) {
          continue;
        }
        const intPart = item.substring(0, dashIndex);
        if (!_PowerShellExeFinder.IntRegex.test(intPart)) {
          continue;
        }
        if (item.substring(dashIndex + 1) !== "preview") {
          continue;
        }
        currentVersion = parseInt(intPart, 10);
      } else {
        if (!_PowerShellExeFinder.IntRegex.test(item)) {
          continue;
        }
        currentVersion = parseInt(item, 10);
      }
      if (currentVersion <= highestSeenVersion) {
        continue;
      }
      const exePath = path3.join(
        powerShellInstallBaseDir,
        item,
        "pwsh.exe"
      );
      if (!await checkIfFileExists(exePath)) {
        continue;
      }
      pwshExePath = exePath;
      highestSeenVersion = currentVersion;
    }
    if (!pwshExePath) {
      return void 0;
    }
    const bitness = programFilesPath.includes("x86") ? "(x86)" : "(x64)";
    const preview = findPreview ? " Preview" : "";
    return new PossiblePowerShellExe(
      pwshExePath,
      `PowerShell${preview} ${bitness}`
    );
  }
  findWinPS({
    useAlternateBitness = false
  } = {}) {
    if (!this.platformDetails.isOS64Bit && useAlternateBitness) {
      return void 0;
    }
    let winPS = useAlternateBitness ? this.alternateBitnessWinPS : this.winPS;
    if (winPS === void 0) {
      const systemFolderPath = this.getSystem32Path({
        useAlternateBitness
      });
      if (!systemFolderPath) {
        return void 0;
      }
      const winPSPath = path3.join(
        systemFolderPath,
        "WindowsPowerShell",
        "v1.0",
        "powershell.exe"
      );
      let displayName;
      if (this.platformDetails.isProcess64Bit) {
        displayName = useAlternateBitness ? WindowsPowerShell32BitLabel : WindowsPowerShell64BitLabel;
      } else if (this.platformDetails.isOS64Bit) {
        displayName = useAlternateBitness ? WindowsPowerShell64BitLabel : WindowsPowerShell32BitLabel;
      } else {
        displayName = WindowsPowerShell32BitLabel;
      }
      winPS = new PossiblePowerShellExe(winPSPath, displayName, true);
      if (useAlternateBitness) {
        this.alternateBitnessWinPS = winPS;
      } else {
        this.winPS = winPS;
      }
    }
    return winPS;
  }
  getProgramFilesPath({
    useAlternateBitness = false
  } = {}) {
    if (!useAlternateBitness) {
      return process2.env.ProgramFiles;
    }
    if (this.platformDetails.isProcess64Bit) {
      return process2.env["ProgramFiles(x86)"];
    }
    if (this.platformDetails.isOS64Bit) {
      return process2.env.ProgramW6432;
    }
    return void 0;
  }
  getSystem32Path({
    useAlternateBitness = false
  } = {}) {
    const windir = process2.env.windir;
    if (!windir) {
      return void 0;
    }
    if (!useAlternateBitness) {
      return path3.join(windir, "System32");
    }
    if (this.platformDetails.isProcess64Bit) {
      return path3.join(windir, "SysWOW64");
    }
    if (this.platformDetails.isOS64Bit) {
      return path3.join(windir, "Sysnative");
    }
    return void 0;
  }
};
var PossiblePowerShellExe = class {
  constructor(exePath, displayName, knownToExist, supportsProperArguments = true, suppressWarning = false) {
    this.exePath = exePath;
    this.displayName = displayName;
    this.knownToExist = knownToExist;
    this.supportsProperArguments = supportsProperArguments;
    this.suppressWarning = suppressWarning;
  }
  async exists() {
    this.knownToExist ??= await checkIfFileExists(this.exePath);
    return this.knownToExist ?? false;
  }
};

// src/process.ts
var import_util = require("util");
var cp = require("child_process");
var path4 = require("path");
var vscode7 = require("vscode");
var utils2 = (init_utils(), __toCommonJS(utils_exports));
var PowerShellProcess = class _PowerShellProcess {
  constructor(exePath, bundledModulesPath, isTemp, shellIntegrationEnabled, logger2, logDirectoryPath, startPsesArgs, sessionFilePath, sessionSettings, devMode = false) {
    this.exePath = exePath;
    this.bundledModulesPath = bundledModulesPath;
    this.isTemp = isTemp;
    this.shellIntegrationEnabled = shellIntegrationEnabled;
    this.logger = logger2;
    this.logDirectoryPath = logDirectoryPath;
    this.startPsesArgs = startPsesArgs;
    this.sessionFilePath = sessionFilePath;
    this.sessionSettings = sessionSettings;
    this.devMode = devMode;
    this.onExitedEmitter = new vscode7.EventEmitter();
    this.onExited = this.onExitedEmitter.event;
    this.pidUpdateEmitter = new vscode7.EventEmitter();
  }
  static title = "PowerShell Extension";
  onExited;
  onExitedEmitter;
  consoleTerminal;
  consoleCloseSubscription;
  pid;
  pidUpdateEmitter;
  async start(cancellationToken) {
    const psesModulePath = path4.resolve(
      __dirname,
      this.bundledModulesPath,
      "PowerShellEditorServices/PowerShellEditorServices.psd1"
    );
    const featureFlags = this.sessionSettings.developer.featureFlags.length > 0 ? this.sessionSettings.developer.featureFlags.map((f) => `'${f}'`).join(", ") : "";
    this.startPsesArgs += `-LogPath '${utils2.escapeSingleQuotes(this.logDirectoryPath.fsPath)}' -SessionDetailsPath '${utils2.escapeSingleQuotes(this.sessionFilePath.fsPath)}' -FeatureFlags @(${featureFlags}) `;
    if (this.sessionSettings.integratedConsole.useLegacyReadLine) {
      this.startPsesArgs += "-UseLegacyReadLine";
    }
    const powerShellArgs = [];
    const useLoginShell = utils2.isMacOS && this.sessionSettings.startAsLoginShell.osx || utils2.isLinux && this.sessionSettings.startAsLoginShell.linux;
    if (useLoginShell && this.isLoginShell(this.exePath)) {
      powerShellArgs.push("-Login");
    }
    powerShellArgs.push("-NoProfile");
    if (utils2.isWindows && this.sessionSettings.developer.setExecutionPolicy) {
      powerShellArgs.push("-ExecutionPolicy", "Bypass");
    }
    const startEditorServices = "Import-Module '" + utils2.escapeSingleQuotes(psesModulePath) + "'; Start-EditorServices " + this.startPsesArgs;
    if (utils2.isWindows) {
      powerShellArgs.push("-Command", startEditorServices);
    } else {
      this.logger.writeDebug(
        "Using Base64 -EncodedCommand but logging as -Command equivalent."
      );
      powerShellArgs.push(
        "-EncodedCommand",
        Buffer.from(startEditorServices, "utf16le").toString("base64")
      );
    }
    this.logger.writeDebug(
      `Starting process: ${this.exePath} ${powerShellArgs.slice(0, -2).join(" ")} -Command ${startEditorServices}`
    );
    await this.deleteSessionFile(this.sessionFilePath);
    let envMixin = {};
    if (this.shellIntegrationEnabled) {
      envMixin = {
        VSCODE_INJECTION: "1",
        // There is no great way to check if we are running stable VS
        // Code. Since this is used to disable experimental features, we
        // default to stable unless we're definitely running Insiders.
        VSCODE_STABLE: vscode7.env.appName.includes("Insiders") ? "0" : "1"
        // Maybe one day we can set VSCODE_NONCE...
      };
    }
    if (this.devMode) {
      envMixin.COMPLUS_FORCEENC = "1";
    }
    const terminalOptions = {
      name: this.isTemp ? `${_PowerShellProcess.title} (TEMP)` : _PowerShellProcess.title,
      shellPath: this.exePath,
      shellArgs: powerShellArgs,
      cwd: await validateCwdSetting(this.logger),
      env: envMixin,
      iconPath: new vscode7.ThemeIcon("terminal-powershell"),
      isTransient: true,
      hideFromUser: this.sessionSettings.integratedConsole.startInBackground,
      location: vscode7.TerminalLocation[this.sessionSettings.integratedConsole.startLocation]
    };
    this.consoleCloseSubscription = vscode7.window.onDidCloseTerminal(
      (terminal) => {
        this.onTerminalClose(terminal);
      }
    );
    this.consoleTerminal = vscode7.window.createTerminal(terminalOptions);
    this.pid = await this.getPid();
    this.logger.write(`PowerShell process started with PID: ${this.pid}`);
    this.pidUpdateEmitter?.fire(this.pid);
    if (this.sessionSettings.integratedConsole.showOnStartup && !this.sessionSettings.integratedConsole.startInBackground) {
      this.consoleTerminal.show(true);
    }
    return await this.waitForSessionFile(cancellationToken);
  }
  // This function is used to clean-up stale PowerShell Extension terminals,
  // which can happen with `restartExtensionHost` is called because we are
  // unable to finish diposing before we're gone.
  static cleanUpTerminals() {
    for (const terminal of vscode7.window.terminals) {
      if (terminal.name.startsWith(_PowerShellProcess.title)) {
        terminal.dispose();
      }
    }
  }
  // This function should only be used after a failure has occurred because it is slow!
  async getVersionCli() {
    const exec = (0, import_util.promisify)(cp.execFile);
    const { stdout } = await exec(this.exePath, [
      "-NoProfile",
      "-NoLogo",
      "-Command",
      "$PSVersionTable.PSVersion.ToString()"
    ]);
    return stdout.trim();
  }
  // Returns the process Id of the consoleTerminal
  async getPid() {
    return await this.consoleTerminal?.processId;
  }
  showTerminal(preserveFocus) {
    this.consoleTerminal?.show(preserveFocus);
  }
  dispose() {
    this.logger.writeDebug(
      `Disposing PowerShell process with PID: ${this.pid}`
    );
    void this.deleteSessionFile(this.sessionFilePath);
    this.onExitedEmitter?.fire();
    this.onExitedEmitter = void 0;
    this.consoleTerminal?.dispose();
    this.consoleTerminal = void 0;
    this.consoleCloseSubscription?.dispose();
    this.consoleCloseSubscription = void 0;
    this.pidUpdateEmitter?.dispose();
    this.pidUpdateEmitter = void 0;
  }
  sendKeyPress() {
    this.consoleTerminal?.sendText("p", false);
  }
  isLoginShell(pwshPath) {
    try {
      cp.execFileSync(pwshPath, [
        "-Login",
        "-NoProfile",
        "-NoLogo",
        "-Command",
        "exit 0"
      ]);
    } catch {
      return false;
    }
    return true;
  }
  async readSessionFile(sessionFilePath) {
    const fileContents = await vscode7.workspace.fs.readFile(sessionFilePath);
    return JSON.parse(fileContents.toString());
  }
  async deleteSessionFile(sessionFilePath) {
    try {
      await vscode7.workspace.fs.delete(sessionFilePath);
    } catch {
    }
  }
  async waitForSessionFile(cancellationToken) {
    const numOfTries = (
      // We sleep for 1/5 of a second each try
      5 * this.sessionSettings.developer.waitForSessionFileTimeoutSeconds
    );
    const warnAt = numOfTries - 5 * 30;
    this.logger.writeDebug(
      `Waiting for session file: ${this.sessionFilePath}`
    );
    for (let i = numOfTries; i > 0; i--) {
      if (cancellationToken.isCancellationRequested) {
        this.logger.writeWarning(
          "Canceled while waiting for session file."
        );
        return void 0;
      }
      if (this.consoleTerminal === void 0) {
        this.logger.writeError("Extension Terminal is undefined.");
        return void 0;
      }
      if (await utils2.checkIfFileExists(this.sessionFilePath)) {
        this.logger.writeDebug("Session file found.");
        return await this.readSessionFile(this.sessionFilePath);
      }
      if (warnAt === i) {
        void this.logger.writeAndShowWarning(
          "Loading the PowerShell extension is taking longer than expected. If you're using privilege enforcement software, this can affect start up performance."
        );
      }
      await utils2.sleep(200);
    }
    this.logger.writeError("Timed out waiting for session file!");
    return void 0;
  }
  onTerminalClose(terminal) {
    if (terminal !== this.consoleTerminal) {
      return;
    }
    this.logger.writeWarning(
      `PowerShell process terminated or Extension Terminal was closed, PID: ${this.pid}`
    );
    this.dispose();
  }
};

// src/session.ts
var import_vscode_jsonrpc = __toESM(require_main());

// src/logging.ts
var import_vscode2 = require("vscode");
var Logger = class {
  // Log output channel handles all the verbosity management so we don't have to.
  logChannel;
  get logLevel() {
    return this.logChannel.logLevel;
  }
  constructor(logChannel) {
    this.logChannel = logChannel ?? import_vscode2.window.createOutputChannel("PowerShell", { log: true });
  }
  dispose() {
    this.logChannel.dispose();
  }
  writeAtLevel(logLevel, message, ...additionalMessages) {
    if (logLevel >= this.logLevel) {
      void this.writeLine(message, logLevel);
      for (const additionalMessage of additionalMessages) {
        void this.writeLine(additionalMessage, logLevel);
      }
    }
  }
  write(message, ...additionalMessages) {
    this.writeAtLevel(import_vscode2.LogLevel.Info, message, ...additionalMessages);
  }
  async writeAndShowInformation(message, ...additionalMessages) {
    this.write(message, ...additionalMessages);
    const selection = await import_vscode2.window.showInformationMessage(
      message,
      "Show Logs",
      "Okay"
    );
    if (selection === "Show Logs") {
      this.showLogPanel();
    }
  }
  writeTrace(message, ...additionalMessages) {
    this.writeAtLevel(import_vscode2.LogLevel.Trace, message, ...additionalMessages);
  }
  writeDebug(message, ...additionalMessages) {
    this.writeAtLevel(import_vscode2.LogLevel.Debug, message, ...additionalMessages);
  }
  writeWarning(message, ...additionalMessages) {
    this.writeAtLevel(import_vscode2.LogLevel.Warning, message, ...additionalMessages);
  }
  async writeAndShowWarning(message, ...additionalMessages) {
    this.writeWarning(message, ...additionalMessages);
    const selection = await import_vscode2.window.showWarningMessage(message, "Show Logs");
    if (selection !== void 0) {
      this.showLogPanel();
    }
  }
  writeError(message, ...additionalMessages) {
    this.writeAtLevel(import_vscode2.LogLevel.Error, message, ...additionalMessages);
  }
  async writeAndShowError(message, ...additionalMessages) {
    this.writeError(message, ...additionalMessages);
    const choice = await import_vscode2.window.showErrorMessage(message, "Show Logs");
    if (choice !== void 0) {
      this.showLogPanel();
    }
  }
  async writeAndShowErrorWithActions(message, actions) {
    this.writeError(message);
    const fullActions = [
      ...actions,
      {
        prompt: "Show Logs",
        action: () => {
          this.showLogPanel();
        }
      }
    ];
    const actionKeys = fullActions.map((action) => action.prompt);
    const choice = await import_vscode2.window.showErrorMessage(message, ...actionKeys);
    if (choice) {
      for (const action of fullActions) {
        if (choice === action.prompt && action.action !== void 0) {
          await action.action();
          return;
        }
      }
    }
  }
  showLogPanel() {
    this.logChannel.show();
  }
  async writeLine(message, level = import_vscode2.LogLevel.Info) {
    return new Promise((resolve3) => {
      switch (level) {
        case import_vscode2.LogLevel.Off:
          break;
        case import_vscode2.LogLevel.Trace:
          this.logChannel.trace(message);
          break;
        case import_vscode2.LogLevel.Debug:
          this.logChannel.debug(message);
          break;
        case import_vscode2.LogLevel.Info:
          this.logChannel.info(message);
          break;
        case import_vscode2.LogLevel.Warning:
          this.logChannel.warn(message);
          break;
        case import_vscode2.LogLevel.Error:
          this.logChannel.error(message);
          break;
        default:
          this.logChannel.appendLine(message);
          break;
      }
      resolve3();
    });
  }
};
var LanguageClientOutputChannelAdapter = class _LanguageClientOutputChannelAdapter {
  /**
   * Creates an instance of the logging class.
   *
   * @param channelName - The name of the output channel.
   * @param parser - A function that parses a log message and returns a tuple containing the parsed message and its log level, or undefined if the log should be filtered.
   */
  constructor(channelName, parser = _LanguageClientOutputChannelAdapter.omnisharpLspParser.bind(
    this
  )) {
    this.channelName = channelName;
    this.parser = parser;
  }
  _channel;
  get channel() {
    this._channel ??= import_vscode2.window.createOutputChannel(this.channelName, {
      log: true
    });
    return this._channel;
  }
  appendLine(message) {
    this.append(message);
  }
  append(message) {
    const parseResult = this.parser(message);
    if (parseResult !== void 0) {
      this.sendLogMessage(...parseResult);
    }
  }
  /** Converts from Omnisharp logs since middleware for LogMessage does not currently exist **/
  static omnisharpLspParser(message) {
    const logLevelMatch = /^\[(?<level>Trace|Debug|Info|Warn|Error) +- \d+:\d+:\d+ [AP]M\] (?<message>.+)/.exec(
      message
    );
    const logLevel = logLevelMatch?.groups?.level ? import_vscode2.LogLevel[logLevelMatch.groups.level] : import_vscode2.LogLevel.Info;
    const logMessage = logLevelMatch?.groups?.message ?? message;
    return [logMessage, logLevel];
  }
  sendLogMessage(message, level) {
    switch (level) {
      case import_vscode2.LogLevel.Trace:
        this.channel.trace(message);
        break;
      case import_vscode2.LogLevel.Debug:
        this.channel.debug(message);
        break;
      case import_vscode2.LogLevel.Info:
        this.channel.info(message);
        break;
      case import_vscode2.LogLevel.Warning:
        this.channel.warn(message);
        break;
      case import_vscode2.LogLevel.Error:
        this.channel.error(message);
        break;
      default:
        this.channel.error("!UNKNOWN LOG LEVEL!: " + message);
        break;
    }
  }
  // #region Passthru Implementation
  get name() {
    return this.channelName;
  }
  get logLevel() {
    return this.channel.logLevel;
  }
  replace(value) {
    this.channel.replace(value);
  }
  show(_column, preserveFocus) {
    this.channel.show(preserveFocus);
  }
  get onDidChangeLogLevel() {
    return this.channel.onDidChangeLogLevel;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  trace(message, ...args) {
    this.channel.trace(message, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debug(message, ...args) {
    this.channel.debug(message, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  info(message, ...args) {
    this.channel.info(message, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  warn(message, ...args) {
    this.channel.warn(message, ...args);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  error(message, ...args) {
    this.channel.error(message, ...args);
  }
  clear() {
    this.channel.clear();
  }
  hide() {
    this.channel.hide();
  }
  dispose() {
    this.channel.dispose();
  }
  // #endregion
};
function PsesParser(message) {
  const logLevelMatch = /^<(?<level>Trace|Debug|Info|Warning|Error)>(?<message>.+)/.exec(
    message
  );
  const logLevel = logLevelMatch?.groups?.level ? import_vscode2.LogLevel[logLevelMatch.groups.level] : import_vscode2.LogLevel.Info;
  const logMessage = logLevelMatch?.groups?.message ?? message;
  return ["[PSES] " + logMessage, logLevel];
}
function LspTraceParser(message) {
  let [parsedMessage, level] = LanguageClientOutputChannelAdapter.omnisharpLspParser(message);
  if (parsedMessage.startsWith("Sending ")) {
    parsedMessage = parsedMessage.replace("Sending", "\u27A1\uFE0F");
    level = import_vscode2.LogLevel.Debug;
  }
  if (parsedMessage.startsWith("Received ")) {
    parsedMessage = parsedMessage.replace("Received", "\u2B05\uFE0F");
    level = import_vscode2.LogLevel.Debug;
  }
  if (parsedMessage.startsWith("Params:") || parsedMessage.startsWith("Result:")) {
    level = import_vscode2.LogLevel.Trace;
  }
  if (parsedMessage.startsWith("\u2B05\uFE0F notification 'window/logMessage'")) {
    level = import_vscode2.LogLevel.Trace;
  }
  return [parsedMessage.trimEnd(), level];
}

// src/session.ts
var import_vscode_languageclient2 = __toESM(require_main4());
var import_node3 = __toESM(require_node3());
var import_semver2 = __toESM(require_semver2());

// src/features/UpdatePowerShell.ts
var import_node_fetch = __toESM(require_lib2());
var import_semver = __toESM(require_semver2());
var vscode8 = require("vscode");
var UpdatePowerShell = class _UpdatePowerShell {
  constructor(sessionSettings, logger2, versionDetails) {
    this.sessionSettings = sessionSettings;
    this.logger = logger2;
    this.localVersion = new import_semver.SemVer(versionDetails.commit);
  }
  static LTSBuildInfoURL = "https://aka.ms/pwsh-buildinfo-lts";
  static StableBuildInfoURL = "https://aka.ms/pwsh-buildinfo-stable";
  static PreviewBuildInfoURL = "https://aka.ms/pwsh-buildinfo-preview";
  static GitHubWebReleaseURL = "https://github.com/PowerShell/PowerShell/releases/tag/";
  static promptOptions = [
    {
      id: 0,
      title: "Yes"
    },
    {
      id: 1,
      title: "Not Now"
    },
    {
      id: 2,
      title: "Don't Show Again"
    }
  ];
  localVersion;
  shouldCheckForUpdate() {
    if (!this.sessionSettings.promptToUpdatePowerShell) {
      this.logger.writeDebug(
        "Setting 'promptToUpdatePowerShell' was false."
      );
      return false;
    }
    if (process.env.POWERSHELL_UPDATECHECK?.toLowerCase() === "off") {
      this.logger.writeDebug(
        "Environment variable 'POWERSHELL_UPDATECHECK' was 'Off'."
      );
      return false;
    }
    if (this.localVersion.compare("6.0.0") === -1) {
      this.logger.writeDebug(
        "Not prompting to update Windows PowerShell."
      );
      return false;
    }
    if (this.localVersion.prerelease.length > 1) {
      const daily = this.localVersion.prerelease[0].toString();
      const commit = this.localVersion.prerelease[1].toString();
      if (commit.length >= 40) {
        this.logger.writeDebug(
          "Not prompting to update development build."
        );
        return false;
      }
      if (daily.toLowerCase().startsWith("daily")) {
        this.logger.writeDebug("Not prompting to update daily build.");
        return false;
      }
    }
    return true;
  }
  async getRemoteVersion(url) {
    const response = await (0, import_node_fetch.default)(url);
    if (!response.ok) {
      return void 0;
    }
    const data = await response.json();
    this.logger.writeDebug(
      `Received from '${url}':
${JSON.stringify(data, void 0, 2)}`
    );
    return data.ReleaseTag;
  }
  async maybeGetNewRelease() {
    if (!this.shouldCheckForUpdate()) {
      return void 0;
    }
    this.logger.writeDebug("Checking for PowerShell update...");
    const tags = [];
    if (process.env.POWERSHELL_UPDATECHECK?.toLowerCase() === "lts") {
      this.logger.writeDebug("Checking for LTS update...");
      const tag = await this.getRemoteVersion(
        _UpdatePowerShell.LTSBuildInfoURL
      );
      if (tag != void 0) {
        tags.push(tag);
      }
    } else {
      this.logger.writeDebug("Checking for stable update...");
      const tag = await this.getRemoteVersion(
        _UpdatePowerShell.StableBuildInfoURL
      );
      if (tag != void 0) {
        tags.push(tag);
      }
      if (this.localVersion.prerelease.length > 0) {
        this.logger.writeDebug("Checking for preview update...");
        const tag2 = await this.getRemoteVersion(
          _UpdatePowerShell.PreviewBuildInfoURL
        );
        if (tag2 != void 0) {
          tags.push(tag2);
        }
      }
    }
    for (const tag of tags) {
      if (this.localVersion.compare(tag) === -1) {
        return tag;
      }
    }
    this.logger.write("PowerShell is up-to-date.");
    return void 0;
  }
  async checkForUpdate() {
    try {
      const tag = await this.maybeGetNewRelease();
      if (tag) {
        await this.promptToUpdate(tag);
        return;
      }
    } catch (err) {
      this.logger.writeWarning(
        err instanceof Error ? err.message : "unknown"
      );
    }
  }
  async openReleaseInBrowser(tag) {
    const url = vscode8.Uri.parse(
      _UpdatePowerShell.GitHubWebReleaseURL + tag
    );
    await vscode8.env.openExternal(url);
  }
  async promptToUpdate(tag) {
    const releaseVersion = new import_semver.SemVer(tag);
    this.logger.write(
      `Prompting to update PowerShell v${this.localVersion.version} to v${releaseVersion.version}.`
    );
    const result = await vscode8.window.showInformationMessage(
      `PowerShell v${this.localVersion.version} is out-of-date.
             The latest version is v${releaseVersion.version}.
             Would you like to open the GitHub release in your browser?`,
      ..._UpdatePowerShell.promptOptions
    );
    if (!result) {
      this.logger.writeDebug("User canceled PowerShell update prompt.");
      return;
    }
    this.logger.writeDebug(
      `User said '${_UpdatePowerShell.promptOptions[result.id].title}'.`
    );
    switch (result.id) {
      // Yes
      case 0:
        await this.openReleaseInBrowser(tag);
        break;
      // Not Now
      case 1:
        break;
      // Don't Show Again
      case 2:
        await changeSetting(
          "promptToUpdatePowerShell",
          false,
          true,
          this.logger
        );
        break;
      default:
        break;
    }
  }
};

// src/session.ts
var net = require("net");
var path5 = require("path");
var vscode9 = require("vscode");
var utils3 = (init_utils(), __toCommonJS(utils_exports));
var SendKeyPressNotificationType = new import_vscode_languageclient2.NotificationType(
  "powerShell/sendKeyPress"
);
var ExecutionBusyStatusNotificationType = new import_vscode_languageclient2.NotificationType("powerShell/executionBusyStatus");
var PowerShellVersionRequestType = new import_vscode_languageclient2.RequestType0("powerShell/getVersion");
var SessionManager = class {
  constructor(extensionContext, sessionSettings, logger2, documentSelector2, hostName, displayName, hostVersion, publisher, telemetryReporter2) {
    this.extensionContext = extensionContext;
    this.sessionSettings = sessionSettings;
    this.logger = logger2;
    this.documentSelector = documentSelector2;
    this.telemetryReporter = telemetryReporter2;
    this.languageStatusItem = this.createStatusBarItem();
    this.sessionsFolder = vscode9.Uri.joinPath(
      extensionContext.globalStorageUri.with({ scheme: "file" }),
      "sessions"
    );
    this.platformDetails = getPlatformDetails();
    this.HostName = hostName;
    this.DisplayName = displayName;
    this.HostVersion = hostVersion;
    this.Publisher = publisher;
    const osBitness = this.platformDetails.isOS64Bit ? "64-bit" : "32-bit";
    const procBitness = this.platformDetails.isProcess64Bit ? "64-bit" : "32-bit";
    this.logger.write(
      `Visual Studio Code: v${vscode9.version} ${procBitness} on ${OperatingSystem[this.platformDetails.operatingSystem]} ${osBitness}`,
      `${this.DisplayName} Extension: v${this.HostVersion}`
    );
    this.HostVersion = this.HostVersion.split("-")[0];
    this.registerCommands();
  }
  HostName;
  DisplayName;
  HostVersion;
  Publisher;
  PowerShellExeDetails;
  ShowSessionMenuCommandName = "PowerShell.ShowSessionMenu";
  debugEventHandler;
  debugSessionProcess;
  languageClient;
  languageClientConsumers = [];
  languageServerProcess;
  languageStatusItem;
  platformDetails;
  registeredCommands = [];
  registeredHandlers = [];
  sessionDetails;
  sessionsFolder;
  sessionStatus = "Not Started" /* NotStarted */;
  shellIntegrationEnabled = false;
  startCancellationTokenSource;
  suppressRestartPrompt = false;
  versionDetails;
  traceLogLevelHandler;
  async dispose() {
    await this.stop();
    this.languageStatusItem.dispose();
    for (const handler of this.registeredHandlers) {
      handler.dispose();
    }
    for (const command of this.registeredCommands) {
      command.dispose();
    }
  }
  // The `exeNameOverride` is used by `restartSession` to override ANY other setting.
  // We've made this function idempotent, so it can used to ensure the session has started.
  async start() {
    switch (this.sessionStatus) {
      case "Not Started" /* NotStarted */:
        break;
      case "Starting" /* Starting */:
        this.logger.writeWarning("Re-entered 'start' so waiting...");
        await this.waitWhileStarting();
        return;
      case "Running" /* Running */:
        this.logger.writeDebug("Already started.");
        return;
      case "Busy" /* Busy */:
        this.logger.write(
          "The Extension Terminal is currently busy, please wait for your task to finish!"
        );
        return;
      case "Stopping" /* Stopping */:
        this.logger.writeDebug("Still stopping.");
        await this.waitWhileStopping();
        break;
      case "Failed" /* Failed */:
        this.logger.writeDebug("Previously failed, starting again.");
        break;
    }
    this.setSessionStatus("Starting...", "Starting" /* Starting */);
    this.startCancellationTokenSource = new vscode9.CancellationTokenSource();
    const cancellationToken = this.startCancellationTokenSource.token;
    await vscode9.workspace.fs.createDirectory(this.sessionsFolder);
    await this.migrateWhitespaceAroundPipeSetting();
    this.shellIntegrationEnabled = vscode9.workspace.getConfiguration("terminal.integrated.shellIntegration").get("enabled") ?? false;
    this.PowerShellExeDetails = await this.findPowerShell();
    if (this.PowerShellExeDetails === void 0) {
      const message = "Unable to find PowerShell! Do you have it installed? You can also configure custom installations with the 'powershell.powerShellAdditionalExePaths' setting.";
      void this.setSessionFailedGetPowerShell(message);
      return;
    }
    this.refreshSessionStatus();
    this.logger.write(
      `Starting '${this.PowerShellExeDetails.displayName}' at: ${this.PowerShellExeDetails.exePath}`
    );
    this.languageServerProcess = await this.startLanguageServerProcess(
      this.PowerShellExeDetails,
      cancellationToken
    );
    if (this.sessionDetails === void 0 || !this.sessionStarted(this.sessionDetails)) {
      if (!cancellationToken.isCancellationRequested) {
        await this.handleFailedProcess(this.languageServerProcess);
      }
      this.languageServerProcess.dispose();
      this.languageServerProcess = void 0;
      return;
    }
    this.languageClient = await this.startLanguageClient(
      this.sessionDetails
    );
    if (this.languageClient.isRunning()) {
      this.versionDetails = await this.getVersionDetails();
      if (this.versionDetails === void 0) {
        void this.setSessionFailedOpenBug(
          "Unable to get version details!"
        );
        return;
      }
      this.logger.write(
        `Started PowerShell v${this.versionDetails.version}.`
      );
      this.setSessionRunningStatus();
      await this.writePidIfInDevMode(this.languageServerProcess);
      const updater = new UpdatePowerShell(
        this.sessionSettings,
        this.logger,
        this.versionDetails
      );
      void updater.checkForUpdate();
    } else {
      void this.setSessionFailedOpenBug("Never finished startup!");
    }
  }
  async stop() {
    this.setSessionStatus("Stopping...", "Stopping" /* Stopping */);
    this.startCancellationTokenSource?.cancel();
    try {
      await this.languageClient?.stop(2e3);
      await this.languageClient?.dispose();
    } catch (err) {
      this.logger.writeError(
        `Error occurred while stopping language client:
${err}`
      );
    }
    this.languageClient = void 0;
    this.debugSessionProcess?.dispose();
    this.debugSessionProcess = void 0;
    this.debugEventHandler?.dispose();
    this.debugEventHandler = void 0;
    this.languageServerProcess?.dispose();
    this.languageServerProcess = void 0;
    this.startCancellationTokenSource?.dispose();
    this.startCancellationTokenSource = void 0;
    this.sessionDetails = void 0;
    this.traceLogLevelHandler?.dispose();
    this.traceLogLevelHandler = void 0;
    this.setSessionStatus("Not Started", "Not Started" /* NotStarted */);
  }
  async restartSession(exeNameOverride) {
    this.logger.write("Restarting session...");
    await this.stop();
    this.sessionSettings = getSettings();
    if (exeNameOverride) {
      this.logger.writeDebug(
        `Starting with executable overriden to: ${exeNameOverride}`
      );
      this.sessionSettings.powerShellDefaultVersion = exeNameOverride;
      this.versionDetails = void 0;
      this.PowerShellExeDetails = void 0;
    }
    await this.start();
  }
  /** In Development mode, write the PID to a file where the parent session can find it, to attach the dotnet debugger. */
  async writePidIfInDevMode(pwshProcess) {
    if (this.extensionContext.extensionMode !== vscode9.ExtensionMode.Development) {
      return;
    }
    const parentSessionId = process.env.VSCODE_PARENT_SESSION_ID;
    const pidFilePath = vscode9.Uri.joinPath(
      this.sessionsFolder,
      `PSES-${parentSessionId}.pid`
    );
    if (parentSessionId === void 0) {
      return;
    }
    const fs = vscode9.workspace.fs;
    const pid = (await pwshProcess.getPid()).toString();
    await fs.writeFile(pidFilePath, Buffer.from(pid));
    const deletePidOnExit = pwshProcess.onExited(() => {
      deletePidOnExit.dispose();
      fs.delete(pidFilePath, { useTrash: false });
      console.log(`Deleted PID file: ${pidFilePath}`);
    });
    this.registeredCommands.push(deletePidOnExit);
    this.extensionContext.subscriptions.push(deletePidOnExit);
  }
  getSessionDetails() {
    if (this.sessionDetails === void 0) {
      void this.logger.writeAndShowError(
        "PowerShell session unavailable for debugging!"
      );
    }
    return this.sessionDetails;
  }
  async getLanguageServerPid() {
    if (this.languageServerProcess === void 0) {
      void this.logger.writeAndShowError(
        "PowerShell Extension Terminal unavailable!"
      );
    }
    return this.languageServerProcess?.getPid();
  }
  getPowerShellVersionDetails() {
    return this.versionDetails;
  }
  getNewSessionFilePath() {
    const uniqueId = Math.floor(1e5 + Math.random() * 9e5);
    return vscode9.Uri.joinPath(
      this.sessionsFolder,
      `PSES-VSCode-${process.env.VSCODE_PID}-${uniqueId}.json`
    );
  }
  setLanguageClientConsumers(languageClientConsumers2) {
    this.languageClientConsumers = languageClientConsumers2;
  }
  async createDebugSessionProcess(settings, powershellExeName) {
    this.debugSessionProcess?.dispose();
    this.debugEventHandler?.dispose();
    if (this.PowerShellExeDetails === void 0) {
      return Promise.reject(
        new Error("Required PowerShellExeDetails undefined!")
      );
    }
    const debugPowerShellExeDetails = powershellExeName === void 0 ? this.PowerShellExeDetails : await this.findPowerShell(powershellExeName) ?? this.PowerShellExeDetails;
    this.sessionSettings = settings;
    const bundledModulesPath = await this.getBundledModulesPath();
    this.debugSessionProcess = new PowerShellProcess(
      debugPowerShellExeDetails.exePath,
      bundledModulesPath,
      true,
      false,
      this.logger,
      this.extensionContext.logUri,
      this.getEditorServicesArgs(
        bundledModulesPath,
        this.PowerShellExeDetails
      ) + "-DebugServiceOnly ",
      this.getNewSessionFilePath(),
      this.sessionSettings
    );
    this.debugEventHandler = vscode9.debug.onDidReceiveDebugSessionCustomEvent((e) => {
      if (e.event === "powerShell/sendKeyPress") {
        this.debugSessionProcess?.sendKeyPress();
      }
    });
    return this.debugSessionProcess;
  }
  async waitUntilStarted() {
    while (this.sessionStatus !== "Running" /* Running */) {
      await utils3.sleep(200);
    }
  }
  // TODO: Is this used by the magic of "Middleware" in the client library?
  resolveCodeLens(codeLens, token, next) {
    const resolvedCodeLens = next(codeLens, token);
    const resolveFunc = (codeLensToFix) => {
      if (codeLensToFix.command?.command === "editor.action.showReferences") {
        const oldArgs = codeLensToFix.command.arguments;
        if (oldArgs === void 0 || oldArgs.length < 3) {
          this.logger.writeError(
            "Code Lens arguments were malformed!"
          );
          return codeLensToFix;
        }
        codeLensToFix.command.arguments = [
          vscode9.Uri.parse(oldArgs[0]),
          new vscode9.Position(oldArgs[1].line, oldArgs[1].character),
          oldArgs[2].map(
            (position) => {
              return new vscode9.Location(
                vscode9.Uri.parse(position.uri),
                new vscode9.Range(
                  position.range.start.line,
                  position.range.start.character,
                  position.range.end.line,
                  position.range.end.character
                )
              );
            }
          )
        ];
      }
      return codeLensToFix;
    };
    if (resolvedCodeLens.then) {
      return resolvedCodeLens.then(
        resolveFunc
      );
    } else if (resolvedCodeLens) {
      return resolveFunc(resolvedCodeLens);
    }
    return resolvedCodeLens;
  }
  // TODO: Remove this migration code. Move old setting
  // codeFormatting.whitespaceAroundPipe to new setting
  // codeFormatting.addWhitespaceAroundPipe.
  async migrateWhitespaceAroundPipeSetting() {
    const configuration = vscode9.workspace.getConfiguration(
      utils3.PowerShellLanguageId
    );
    const deprecatedSetting = "codeFormatting.whitespaceAroundPipe";
    const newSetting = "codeFormatting.addWhitespaceAroundPipe";
    const configurationTargetOfNewSetting = getEffectiveConfigurationTarget(newSetting);
    const configurationTargetOfOldSetting = getEffectiveConfigurationTarget(deprecatedSetting);
    if (configurationTargetOfOldSetting !== void 0 && configurationTargetOfNewSetting === void 0) {
      this.logger.writeWarning(
        "Deprecated setting: whitespaceAroundPipe"
      );
      const value = configuration.get(
        deprecatedSetting,
        configurationTargetOfOldSetting
      );
      await changeSetting(
        newSetting,
        value,
        configurationTargetOfOldSetting,
        this.logger
      );
      await changeSetting(
        deprecatedSetting,
        void 0,
        configurationTargetOfOldSetting,
        this.logger
      );
    }
  }
  /** There are some changes we cannot "hot" set, so these require a restart of the session */
  async restartOnCriticalConfigChange(changeEvent) {
    if (this.suppressRestartPrompt) {
      return;
    }
    if (this.sessionStatus !== "Running" /* Running */) {
      return;
    }
    const settings = getSettings();
    if (changeEvent.affectsConfiguration(
      "terminal.integrated.shellIntegration.enabled"
    )) {
      const shellIntegrationEnabled = vscode9.workspace.getConfiguration("terminal.integrated.shellIntegration").get("enabled") ?? false;
      if (shellIntegrationEnabled && !settings.integratedConsole.startInBackground) {
        return this.restartWithPrompt();
      }
    }
    if (!changeEvent.affectsConfiguration("powershell")) {
      return;
    }
    const coldRestartSettingNames = [
      "developer.traceLsp",
      "developer.traceDap",
      "developer.editorServicesLogLevel"
    ];
    for (const settingName of coldRestartSettingNames) {
      if (changeEvent.affectsConfiguration(
        "powershell." + settingName
      )) {
        return this.restartWithPrompt();
      }
    }
    if (settings.cwd !== this.sessionSettings.cwd || settings.powerShellDefaultVersion !== this.sessionSettings.powerShellDefaultVersion || settings.developer.bundledModulesPath !== this.sessionSettings.developer.bundledModulesPath || settings.developer.editorServicesWaitForDebugger !== this.sessionSettings.developer.editorServicesWaitForDebugger || settings.developer.setExecutionPolicy !== this.sessionSettings.developer.setExecutionPolicy || settings.integratedConsole.useLegacyReadLine !== this.sessionSettings.integratedConsole.useLegacyReadLine || settings.integratedConsole.startInBackground !== this.sessionSettings.integratedConsole.startInBackground || settings.integratedConsole.startLocation !== this.sessionSettings.integratedConsole.startLocation) {
      return this.restartWithPrompt();
    }
  }
  async restartWithPrompt() {
    this.logger.writeDebug("Settings changed, prompting to restart...");
    const response = await vscode9.window.showInformationMessage(
      "The PowerShell runtime configuration has changed, would you like to start a new session?",
      "Yes",
      "No"
    );
    if (response === "Yes") {
      await this.restartSession();
    }
  }
  registerCommands() {
    this.registeredCommands = [
      vscode9.commands.registerCommand(
        "PowerShell.RestartSession",
        async () => {
          await this.restartSession();
        }
      ),
      vscode9.commands.registerCommand(
        this.ShowSessionMenuCommandName,
        async () => {
          await this.showSessionMenu();
        }
      ),
      vscode9.workspace.onDidChangeConfiguration(
        (e) => this.restartOnCriticalConfigChange(e)
      ),
      vscode9.commands.registerCommand(
        "PowerShell.ShowSessionConsole",
        (isExecute) => {
          this.showSessionTerminal(isExecute);
        }
      )
    ];
  }
  async findPowerShell(wantedName) {
    this.logger.writeDebug("Finding PowerShell...");
    const powershellExeFinder = new PowerShellExeFinder(
      this.platformDetails,
      this.sessionSettings.powerShellAdditionalExePaths,
      this.logger
    );
    let foundPowerShell;
    try {
      let defaultPowerShell;
      wantedName ??= this.sessionSettings.powerShellDefaultVersion;
      if (wantedName !== "") {
        for await (const details of powershellExeFinder.enumeratePowerShellInstallations()) {
          if (wantedName.localeCompare(
            details.displayName,
            void 0,
            { sensitivity: "accent" }
          ) === 0) {
            defaultPowerShell = details;
            break;
          }
        }
      }
      foundPowerShell = defaultPowerShell ?? await powershellExeFinder.getFirstAvailablePowerShellInstallation();
      if (wantedName !== "" && defaultPowerShell === void 0 && foundPowerShell !== void 0) {
        void this.logger.writeAndShowWarning(
          `The 'powerShellDefaultVersion' setting was '${wantedName}' but this was not found! Instead using first available installation '${foundPowerShell.displayName}' at '${foundPowerShell.exePath}'!`
        );
      }
    } catch (err) {
      this.logger.writeError(
        `Error occurred while searching for a PowerShell executable:
${err}`
      );
    }
    return foundPowerShell;
  }
  async startLanguageServerProcess(powerShellExeDetails, cancellationToken) {
    const bundledModulesPath = await this.getBundledModulesPath();
    PowerShellProcess.cleanUpTerminals();
    const languageServerProcess = new PowerShellProcess(
      powerShellExeDetails.exePath,
      bundledModulesPath,
      false,
      this.shellIntegrationEnabled,
      this.logger,
      this.extensionContext.logUri,
      this.getEditorServicesArgs(
        bundledModulesPath,
        powerShellExeDetails
      ),
      this.getNewSessionFilePath(),
      this.sessionSettings,
      this.extensionContext.extensionMode == vscode9.ExtensionMode.Development
    );
    languageServerProcess.onExited(() => {
      LanguageClientConsumer.onLanguageClientExited();
      if (this.sessionStatus === "Running" /* Running */ || this.sessionStatus === "Busy" /* Busy */) {
        this.setSessionStatus("Session Exited!", "Failed" /* Failed */);
        void this.promptForRestart();
      }
    });
    this.sessionDetails = await languageServerProcess.start(cancellationToken);
    return languageServerProcess;
  }
  // The process failed to start, so check for common user errors (generally
  // out-of-support versions of PowerShell).
  async handleFailedProcess(powerShellProcess) {
    const version = await powerShellProcess.getVersionCli();
    let shouldUpdate = true;
    if ((0, import_semver2.satisfies)(version, "<5.1.0")) {
      void this.setSessionFailedGetPowerShell(
        `PowerShell v${version} is not supported, please update!`
      );
    } else if ((0, import_semver2.satisfies)(version, ">=5.1.0 <6.0.0")) {
      void this.setSessionFailedGetPowerShell(
        "It looks like you're trying to use Windows PowerShell, which is supported on a best-effort basis. Can you try PowerShell 7?"
      );
    } else if ((0, import_semver2.satisfies)(version, ">=6.0.0 <7.4.0")) {
      void this.setSessionFailedGetPowerShell(
        `PowerShell v${version} has reached end-of-support, please update!`
      );
    } else {
      shouldUpdate = false;
      void this.setSessionFailedOpenBug(
        "PowerShell Language Server process didn't start!"
      );
    }
    if (shouldUpdate) {
      const versionDetails = {
        version,
        edition: "",
        // Unused by UpdatePowerShell
        commit: version,
        // Actually used by UpdatePowerShell
        architecture: process.arch
        // Best guess based off Code's architecture
      };
      const updater = new UpdatePowerShell(
        this.sessionSettings,
        this.logger,
        versionDetails
      );
      void updater.checkForUpdate();
    }
  }
  sessionStarted(sessionDetails) {
    this.logger.writeDebug(
      `Session details: ${JSON.stringify(sessionDetails, void 0, 2)}`
    );
    if (sessionDetails.status === "started") {
      return true;
    }
    if (sessionDetails.status === "failed") {
      if (sessionDetails.reason === "powerShellVersion") {
        void this.setSessionFailedGetPowerShell(
          `PowerShell ${sessionDetails.powerShellVersion} is not supported, please update!`
        );
      } else if (sessionDetails.reason === "dotNetVersion") {
        void this.setSessionFailedGetDotNet(
          ".NET Framework is out-of-date, please install at least 4.8!"
        );
      } else {
        void this.setSessionFailedOpenBug(
          `PowerShell could not be started for an unknown reason: ${sessionDetails.reason}`
        );
      }
    } else {
      void this.setSessionFailedOpenBug(
        `PowerShell could not be started with an unknown status: ${sessionDetails.status}, and reason: ${sessionDetails.reason}`
      );
    }
    return false;
  }
  async startLanguageClient(sessionDetails) {
    this.logger.writeDebug("Connecting to language service...");
    const connectFunc = () => {
      return new Promise((resolve3, _reject) => {
        const socket = net.connect(
          sessionDetails.languageServicePipeName
        );
        socket.on("connect", () => {
          this.logger.writeDebug("Language service connected.");
          resolve3({ writer: socket, reader: socket });
        });
      });
    };
    const clientOptions = {
      documentSelector: this.documentSelector,
      synchronize: {
        // TODO: This is deprecated and they should be pulled by the server.
        // backend uses "files" and "search" to ignore references.
        configurationSection: [
          utils3.PowerShellLanguageId,
          "files",
          "search"
        ]
        // TODO: fileEvents: vscode.workspace.createFileSystemWatcher('**/.eslintrc')
      },
      // NOTE: Some settings are only applicable on startup, so we send them during initialization.
      // When Terminal Shell Integration is enabled, we pass the path to the script that the server should execute.
      // Passing an empty string implies integration is disabled.
      initializationOptions: {
        enableProfileLoading: this.sessionSettings.enableProfileLoading,
        initialWorkingDirectory: await validateCwdSetting(this.logger),
        shellIntegrationScript: this.shellIntegrationEnabled ? utils3.ShellIntegrationScript : ""
      },
      errorHandler: {
        // Override the default error handler to prevent it from
        // closing the LanguageClient incorrectly when the socket
        // hangs up (ECONNRESET errors).
        error: (_error, _message, _count) => {
          this.logger.writeError(
            `${_error.name}: ${_error.message} ${_error.cause}`
          );
          return { action: import_vscode_languageclient2.ErrorAction.Continue };
        },
        closed: () => {
          this.logger.write("Language service connection closed.");
          return {
            action: import_vscode_languageclient2.CloseAction.DoNotRestart,
            message: "Connection to PowerShell Editor Services (the Extension Terminal) was closed. See below prompt to restart!"
          };
        }
      },
      middleware: this,
      traceOutputChannel: new LanguageClientOutputChannelAdapter(
        "PowerShell: Trace LSP",
        LspTraceParser
      ),
      // This is named the same as the Client log to merge the logs, but will be handled and disposed separately.
      outputChannel: new LanguageClientOutputChannelAdapter(
        "PowerShell",
        PsesParser
      ),
      revealOutputChannelOn: import_vscode_languageclient2.RevealOutputChannelOn.Never
    };
    const languageClient = new import_node3.LanguageClient(
      "powershell",
      "PowerShell Editor Services Client",
      connectFunc,
      clientOptions
    );
    languageClient.registerProposedFeatures();
    languageClient.onTelemetry((event) => {
      const eventName = event.eventName ?? "PSESEvent";
      const data = event.data ?? event;
      this.sendTelemetryEvent(eventName, data);
    });
    for (const consumer of this.languageClientConsumers) {
      consumer.onLanguageClientSet(languageClient);
    }
    this.registeredHandlers = [
      // NOTE: This fixes a quirk where PSES has a thread stuck on
      // Console.ReadKey, since it's not cancellable. On
      // "cancellation" the server asks us to send pretend to
      // press a key, thus mitigating all the quirk.
      languageClient.onNotification(SendKeyPressNotificationType, () => {
        this.languageServerProcess?.sendKeyPress();
      }),
      languageClient.onNotification(
        ExecutionBusyStatusNotificationType,
        (isBusy) => {
          if (isBusy) {
            this.setSessionBusyStatus();
          } else {
            this.setSessionRunningStatus();
          }
        }
      )
    ];
    try {
      await languageClient.start();
      LanguageClientConsumer.onLanguageClientStarted(languageClient);
    } catch (err) {
      void this.setSessionFailedOpenBug(
        "Language client failed to start: " + (err instanceof Error ? err.message : "unknown")
      );
    }
    return languageClient;
  }
  async getBundledModulesPath() {
    let bundledModulesPath = path5.resolve(__dirname, "../modules");
    if (this.extensionContext.extensionMode === vscode9.ExtensionMode.Development) {
      const devBundledModulesPath = path5.resolve(
        __dirname,
        this.sessionSettings.developer.bundledModulesPath
      );
      if (await utils3.checkIfDirectoryExists(devBundledModulesPath)) {
        bundledModulesPath = devBundledModulesPath;
      } else {
        void this.logger.writeAndShowWarning(
          `In development mode but PowerShellEditorServices dev module path cannot be found (or has not been built yet): ${devBundledModulesPath}
`
        );
      }
    }
    return bundledModulesPath;
  }
  getEditorServicesArgs(bundledModulesPath, powerShellExeDetails) {
    let editorServicesArgs = `-HostName 'Visual Studio Code Host' -HostProfileId 'Microsoft.VSCode' -HostVersion '${this.HostVersion}' -BundledModulesPath '${utils3.escapeSingleQuotes(bundledModulesPath)}' -EnableConsoleRepl `;
    if (this.sessionSettings.integratedConsole.suppressStartupBanner) {
      editorServicesArgs += "-StartupBanner '' ";
    } else if (utils3.isWindows && !powerShellExeDetails.supportsProperArguments) {
      editorServicesArgs += `-StartupBanner '${this.DisplayName} Extension v${this.HostVersion}' `;
    } else {
      const startupBanner = `${this.DisplayName} Extension v${this.HostVersion}
Copyright (c) Microsoft Corporation.

https://aka.ms/vscode-powershell
Type 'help' to get help.
`;
      editorServicesArgs += `-StartupBanner "${startupBanner}" `;
    }
    if (this.sessionSettings.developer.editorServicesWaitForDebugger && this.extensionContext.extensionMode === vscode9.ExtensionMode.Development) {
      editorServicesArgs += "-WaitForDebugger ";
    }
    const logLevel = vscode9.workspace.getConfiguration("powershell.developer").get("editorServicesLogLevel");
    editorServicesArgs += `-LogLevel '${logLevel}' `;
    return editorServicesArgs;
  }
  async getVersionDetails() {
    const timeout = new vscode9.CancellationTokenSource();
    setTimeout(() => {
      timeout.cancel();
    }, 60 * 1e3);
    const versionDetails = await this.languageClient?.sendRequest(
      PowerShellVersionRequestType,
      timeout.token
    );
    this.sendTelemetryEvent("powershellVersionCheck", {
      powershellVersion: versionDetails?.version ?? "unknown"
    });
    return versionDetails;
  }
  async promptForRestart() {
    await this.logger.writeAndShowErrorWithActions(
      "The PowerShell Extension Terminal has stopped, would you like to restart it? IntelliSense and other features will not work without it!",
      [
        {
          prompt: "Yes",
          action: async () => {
            await this.restartSession();
          }
        },
        {
          prompt: "No",
          action: void 0
        }
      ]
    );
  }
  sendTelemetryEvent(eventName, properties, measures) {
    if (this.extensionContext.extensionMode === vscode9.ExtensionMode.Production) {
      this.telemetryReporter.sendTelemetryEvent(
        eventName,
        properties,
        measures
      );
    }
  }
  createStatusBarItem() {
    const statusTitle = "Show PowerShell Session Menu";
    const languageStatusItem = vscode9.languages.createLanguageStatusItem(
      "powershell",
      this.documentSelector
    );
    languageStatusItem.command = {
      title: statusTitle,
      command: this.ShowSessionMenuCommandName
    };
    languageStatusItem.text = "$(terminal-powershell)";
    languageStatusItem.detail = "PowerShell";
    return languageStatusItem;
  }
  async waitWhileStarting() {
    while (this.sessionStatus === "Starting" /* Starting */) {
      if (this.startCancellationTokenSource?.token.isCancellationRequested) {
        return;
      }
      await utils3.sleep(200);
    }
  }
  async waitWhileStopping() {
    while (this.sessionStatus === "Stopping" /* Stopping */) {
      await utils3.sleep(200);
    }
  }
  setSessionStatus(detail, status) {
    this.logger.writeDebug(
      `Session status changing from '${this.sessionStatus}' to '${status}'.`
    );
    this.sessionStatus = status;
    this.languageStatusItem.text = "$(terminal-powershell)";
    this.languageStatusItem.detail = "PowerShell";
    if (this.versionDetails !== void 0) {
      const semver = new import_semver2.SemVer(this.versionDetails.version);
      this.languageStatusItem.text += ` ${semver.major}.${semver.minor}`;
      this.languageStatusItem.detail += ` ${this.versionDetails.commit} (${this.versionDetails.architecture.toLowerCase()})`;
    } else if (this.PowerShellExeDetails?.displayName) {
      this.languageStatusItem.text += ` ${this.PowerShellExeDetails.displayName}`;
      this.languageStatusItem.detail += ` at '${this.PowerShellExeDetails.exePath}'`;
    } else if (this.sessionSettings.powerShellDefaultVersion) {
      this.languageStatusItem.text += ` ${this.sessionSettings.powerShellDefaultVersion}`;
      this.languageStatusItem.detail = `Looking for '${this.sessionSettings.powerShellDefaultVersion}'...`;
    }
    if (detail) {
      this.languageStatusItem.detail += ": " + detail;
    }
    switch (status) {
      case "Running" /* Running */:
      case "Not Started" /* NotStarted */:
        this.languageStatusItem.busy = false;
        this.languageStatusItem.severity = vscode9.LanguageStatusSeverity.Information;
        break;
      case "Busy" /* Busy */:
        this.languageStatusItem.busy = true;
        this.languageStatusItem.severity = vscode9.LanguageStatusSeverity.Information;
        break;
      case "Starting" /* Starting */:
      case "Stopping" /* Stopping */:
        this.languageStatusItem.busy = true;
        this.languageStatusItem.severity = vscode9.LanguageStatusSeverity.Warning;
        break;
      case "Failed" /* Failed */:
        this.languageStatusItem.busy = false;
        this.languageStatusItem.severity = vscode9.LanguageStatusSeverity.Error;
        break;
    }
  }
  // Refreshes the Language Status Item details with ehe same status.
  refreshSessionStatus() {
    this.setSessionStatus("", this.sessionStatus);
  }
  setSessionRunningStatus() {
    this.setSessionStatus("", "Running" /* Running */);
  }
  setSessionBusyStatus() {
    this.setSessionStatus("Executing...", "Busy" /* Busy */);
  }
  async setSessionFailedOpenBug(message) {
    this.setSessionStatus("Startup Error!", "Failed" /* Failed */);
    await this.logger.writeAndShowErrorWithActions(message, [
      {
        prompt: "Open an Issue",
        action: async () => {
          await vscode9.commands.executeCommand(
            "PowerShell.GenerateBugReport"
          );
        }
      }
    ]);
  }
  async setSessionFailedGetPowerShell(message) {
    this.setSessionStatus("Startup Error!", "Failed" /* Failed */);
    await this.logger.writeAndShowErrorWithActions(message, [
      {
        prompt: "Open PowerShell Install Documentation",
        action: async () => {
          await vscode9.env.openExternal(
            vscode9.Uri.parse(
              "https://aka.ms/get-powershell-vscode"
            )
          );
        }
      }
    ]);
  }
  async setSessionFailedGetDotNet(message) {
    this.setSessionStatus("Startup Error!", "Failed" /* Failed */);
    await this.logger.writeAndShowErrorWithActions(message, [
      {
        prompt: "Open .NET Framework Documentation",
        action: async () => {
          await vscode9.env.openExternal(
            vscode9.Uri.parse(
              "https://dotnet.microsoft.com/en-us/download/dotnet-framework"
            )
          );
        }
      }
    ]);
  }
  async changePowerShellDefaultVersion(exePath) {
    this.suppressRestartPrompt = true;
    try {
      await changeSetting(
        "powerShellDefaultVersion",
        exePath.displayName,
        true,
        this.logger
      );
    } finally {
      this.suppressRestartPrompt = false;
    }
    await this.restartSession(exePath.displayName);
  }
  // Shows the temp debug terminal if it exists, otherwise the session terminal.
  showDebugTerminal(isExecute) {
    if (this.debugSessionProcess) {
      this.debugSessionProcess.showTerminal(
        isExecute && !this.sessionSettings.integratedConsole.focusConsoleOnExecute
      );
    } else {
      this.languageServerProcess?.showTerminal(
        isExecute && !this.sessionSettings.integratedConsole.focusConsoleOnExecute
      );
    }
  }
  // Always shows the session terminal.
  showSessionTerminal(isExecute) {
    this.languageServerProcess?.showTerminal(
      isExecute && !this.sessionSettings.integratedConsole.focusConsoleOnExecute
    );
  }
  async showSessionMenu() {
    const powershellExeFinder = new PowerShellExeFinder(
      this.platformDetails,
      // We don't pull from session settings because we want them fresh!
      getSettings().powerShellAdditionalExePaths,
      this.logger
    );
    const availablePowerShellExes = await powershellExeFinder.getAllAvailablePowerShellInstallations();
    const powerShellItems = availablePowerShellExes.filter(
      (item) => item.displayName !== this.PowerShellExeDetails?.displayName
    ).map((item) => {
      return new SessionMenuItem(
        `Switch to: ${item.displayName}`,
        async () => {
          await this.changePowerShellDefaultVersion(item);
        }
      );
    });
    const menuItems = [
      new SessionMenuItem(
        `Current session: ${this.PowerShellExeDetails?.displayName ?? "Unknown"} (click to show logs)`,
        async () => {
          await vscode9.commands.executeCommand("PowerShell.ShowLogs");
        }
      ),
      // Add all of the different PowerShell options
      ...powerShellItems,
      new SessionMenuItem("Restart current session", async () => {
        if (this.PowerShellExeDetails) {
          await this.restartSession(
            this.PowerShellExeDetails.displayName
          );
        } else {
          await this.restartSession();
        }
      }),
      new SessionMenuItem("Open session logs folder", async () => {
        await vscode9.commands.executeCommand(
          "PowerShell.OpenLogFolder"
        );
      }),
      new SessionMenuItem(
        "Modify list of additional PowerShell locations",
        async () => {
          await vscode9.commands.executeCommand(
            "workbench.action.openSettings",
            "powerShellAdditionalExePaths"
          );
        }
      )
    ];
    const selectedItem = await vscode9.window.showQuickPick(menuItems);
    await selectedItem?.callback();
  }
};
var SessionMenuItem = class {
  constructor(label, callback = async () => {
  }) {
    this.label = label;
    this.callback = callback;
  }
  description;
};

// src/features/DebugSession.ts
init_utils();
var StartDebuggerNotificationType = new import_vscode_languageclient3.NotificationType(
  "powerShell/startDebugger"
);
var StopDebuggerNotificationType = new import_vscode_languageclient3.NotificationType(
  "powerShell/stopDebugger"
);
var PREVENT_DEBUG_START = void 0;
var PREVENT_DEBUG_START_AND_OPEN_DEBUGCONFIG = null;
var DebugConfigurations = {
  [0 /* LaunchCurrentFile */]: {
    name: "PowerShell: Launch Current File",
    type: "PowerShell",
    request: "launch",
    script: "${file}",
    args: []
  },
  [1 /* LaunchScript */]: {
    name: "PowerShell: Launch Script",
    type: "PowerShell",
    request: "launch",
    script: 'Enter path or command to execute, for example: "${workspaceFolder}/src/foo.ps1" or "Invoke-Pester"',
    args: []
  },
  [2 /* InteractiveSession */]: {
    name: "PowerShell: Interactive Session",
    type: "PowerShell",
    request: "launch"
  },
  [3 /* AttachHostProcess */]: {
    name: "PowerShell: Attach to PowerShell Host Process",
    type: "PowerShell",
    request: "attach"
  },
  [4 /* RunPester */]: {
    name: "PowerShell: Run Pester Tests",
    type: "PowerShell",
    request: "launch",
    script: "Invoke-Pester",
    createTemporaryIntegratedConsole: true,
    attachDotnetDebugger: true
  },
  [5 /* ModuleInteractiveSession */]: {
    name: "PowerShell: Module Interactive Session",
    type: "PowerShell",
    request: "launch",
    script: 'Enter command to import your binary module, for example: "Import-Module -Force ${workspaceFolder}/path/to/module.psd1|dll"'
  },
  [6 /* BinaryModule */]: {
    name: "PowerShell: Binary Module Interactive",
    type: "PowerShell",
    request: "launch",
    script: 'Enter command to import your binary module, for example: "Import-Module -Force ${workspaceFolder}/path/to/module.psd1|dll"',
    createTemporaryIntegratedConsole: true,
    attachDotnetDebugger: true
  },
  [7 /* BinaryModulePester */]: {
    name: "PowerShell: Binary Module Pester Tests",
    type: "PowerShell",
    request: "launch",
    script: "Invoke-Pester",
    createTemporaryIntegratedConsole: true,
    attachDotnetDebugger: true
  },
  [8 /* WindowsPowerShell */]: {
    name: "PowerShell: Windows PowerShell",
    type: "PowerShell",
    request: "launch",
    sessionName: "Windows PowerShell (x64)"
  }
};
var DebugSessionFeature = class extends LanguageClientConsumer {
  constructor(context, sessionManager2, logger2) {
    super();
    this.sessionManager = sessionManager2;
    this.logger = logger2;
    this.activateDebugAdaptor(context);
    this.commands = [
      import_vscode3.commands.registerCommand(
        "PowerShell.PickPSHostProcess",
        async () => {
          const processId = await this.pickPSHostProcess();
          return processId?.toString();
        }
      ),
      import_vscode3.commands.registerCommand(
        "PowerShell.PickRunspace",
        async (processId) => {
          const runspace = await this.pickRunspace(processId);
          return runspace?.toString();
        },
        this
      )
    ];
  }
  tempDebugProcess;
  tempSessionDetails;
  commands = [];
  handlers = [];
  adapterName = "PowerShell";
  dispose() {
    for (const command of this.commands) {
      command.dispose();
    }
    for (const handler of this.handlers) {
      handler.dispose();
    }
  }
  // This "activates" the debug adapter. You can only do this once.
  activateDebugAdaptor(context) {
    const triggers = [
      import_vscode3.DebugConfigurationProviderTriggerKind.Initial,
      import_vscode3.DebugConfigurationProviderTriggerKind.Dynamic
    ];
    for (const triggerKind of triggers) {
      context.subscriptions.push(
        import_vscode3.debug.registerDebugConfigurationProvider(
          this.adapterName,
          this,
          triggerKind
        )
      );
    }
    context.subscriptions.push(
      import_vscode3.debug.registerDebugAdapterTrackerFactory(
        this.adapterName,
        new PowerShellDebugAdapterTrackerFactory(this.adapterName)
      ),
      import_vscode3.debug.registerDebugAdapterDescriptorFactory(this.adapterName, this)
    );
  }
  onLanguageClientSet(languageClient) {
    this.handlers = [
      languageClient.onNotification(
        StartDebuggerNotificationType,
        () => void import_vscode3.debug.startDebugging(
          void 0,
          DebugConfigurations[2 /* InteractiveSession */]
        )
      ),
      languageClient.onNotification(
        StopDebuggerNotificationType,
        () => void import_vscode3.debug.stopDebugging(void 0)
      )
    ];
  }
  async provideDebugConfigurations(_folder, _token) {
    const debugConfigPickItems = [
      {
        id: 0 /* LaunchCurrentFile */,
        label: "Launch Current File",
        description: "Launch and debug the file in the currently active editor window"
      },
      {
        id: 1 /* LaunchScript */,
        label: "Launch Script",
        description: "Launch and debug the specified file or command"
      },
      {
        id: 2 /* InteractiveSession */,
        label: "Interactive Session",
        description: "Debug commands executed from the PowerShell Extension Terminal"
      },
      {
        id: 3 /* AttachHostProcess */,
        label: "Attach",
        description: "Attach the debugger to a running PowerShell Host Process"
      },
      {
        id: 4 /* RunPester */,
        label: "Run Pester Tests",
        description: "Debug Pester Tests detected in your current directory (runs Invoke-Pester)"
      },
      {
        id: 5 /* ModuleInteractiveSession */,
        label: "Interactive Session (Module)",
        description: "Debug commands executed from the PowerShell Extension Terminal after auto-loading your module"
      },
      {
        id: 6 /* BinaryModule */,
        label: "Interactive Session (Binary Module)",
        description: "Debug a .NET binary or hybrid module loaded into a PowerShell session. Breakpoints you set in your .NET (C#/F#/VB/etc.) code will be hit upon command execution. You may want to add a compile or watch action as a pre-launch task to this configuration."
      },
      {
        id: 7 /* BinaryModulePester */,
        label: "Run Pester Tests (Binary Module)",
        description: "Debug a .NET binary or hybrid module by running Pester tests. Breakpoints you set in your .NET (C#/F#/VB/etc.) code will be hit upon command execution. You may want to add a compile or watch action as a pre-launch task to this configuration."
      }
    ];
    const platformDetails = getPlatformDetails();
    if (platformDetails.operatingSystem === 1 /* Windows */) {
      debugConfigPickItems.push({
        id: 8 /* WindowsPowerShell */,
        label: "Windows PowerShell",
        description: "Launch Windows PowerShell in a temporary integrated console for debugging"
      });
    }
    const launchSelection = await import_vscode3.window.showQuickPick(
      debugConfigPickItems,
      { placeHolder: "Select a PowerShell debug configuration" }
    );
    if (launchSelection) {
      return [DebugConfigurations[launchSelection.id]];
    }
    return [DebugConfigurations[0 /* LaunchCurrentFile */]];
  }
  // We don't use await here but we are returning a promise and the return syntax is easier in an async function
  // eslint-disable-next-line @typescript-eslint/require-await
  async resolveDebugConfiguration(_folder, config, _token) {
    if (!config.request) {
      const LaunchCurrentFileConfig = DebugConfigurations[0 /* LaunchCurrentFile */];
      config = { ...config, ...LaunchCurrentFileConfig };
      config.current_document = true;
    }
    if (config.script === "${file}" || config.script === "${relativeFile}") {
      if (import_vscode3.window.activeTextEditor === void 0) {
        void this.logger.writeAndShowError(
          "To debug the 'Current File', you must first open a PowerShell script file in the editor."
        );
        return PREVENT_DEBUG_START;
      }
      config.current_document = true;
      const currentDocument = import_vscode3.window.activeTextEditor.document;
      if (currentDocument.isUntitled) {
        config.untitled_document = true;
        config.script = currentDocument.uri.toString();
      }
    }
    return config;
  }
  async resolveDebugConfigurationWithSubstitutedVariables(_folder, config, _token) {
    let resolvedConfig;
    config.internalConsoleOptions = "neverOpen";
    const settings = getSettings();
    config.createTemporaryIntegratedConsole ??= settings.debugging.createTemporaryIntegratedConsole;
    config.executeMode ??= settings.debugging.executeMode;
    if (config.request === "attach") {
      resolvedConfig = await this.resolveAttachDebugConfiguration(config);
    } else if (config.request === "launch") {
      resolvedConfig = await this.resolveLaunchDebugConfiguration(config);
    } else {
      void this.logger.writeAndShowError(
        `PowerShell debug configuration's request type was invalid: '${config.request}'.`
      );
      return PREVENT_DEBUG_START_AND_OPEN_DEBUGCONFIG;
    }
    return resolvedConfig;
  }
  // This is our factory entrypoint hook to when a debug session starts, and
  // where we will lazy initialize everything needed to do the debugging such
  // as a temporary console if required.
  //
  // NOTE: A Promise meets the shape of a ProviderResult, which allows us to
  // make this method async.
  async createDebugAdapterDescriptor(session, _executable) {
    await this.sessionManager.start();
    const sessionDetails = session.configuration.createTemporaryIntegratedConsole ? await this.createTemporaryIntegratedConsole(session) : this.sessionManager.getSessionDetails();
    if (sessionDetails === void 0) {
      return void 0;
    }
    this.sessionManager.showDebugTerminal(true);
    this.logger.writeDebug(
      `Connecting to pipe: ${sessionDetails.debugServicePipeName}`
    );
    this.logger.writeDebug(
      `Debug configuration: ${JSON.stringify(session.configuration, void 0, 2)}`
    );
    return new import_vscode3.DebugAdapterNamedPipeServer(
      sessionDetails.debugServicePipeName
    );
  }
  async resolveLaunchDebugConfiguration(config) {
    if (config.current_document) {
      const currentDocument = import_vscode3.window.activeTextEditor?.document;
      if (currentDocument?.languageId !== "powershell") {
        void this.logger.writeAndShowError(
          `PowerShell does not support debugging this language mode: '${currentDocument?.languageId}'.`
        );
        return PREVENT_DEBUG_START_AND_OPEN_DEBUGCONFIG;
      }
      if (await checkIfFileExists(config.script)) {
        const ext = import_path.default.extname(config.script).toLowerCase();
        if (!(ext === ".ps1" || ext === ".psm1")) {
          void this.logger.writeAndShowError(
            `PowerShell does not support debugging this file type: '${import_path.default.basename(config.script)}'.`
          );
          return PREVENT_DEBUG_START_AND_OPEN_DEBUGCONFIG;
        }
      }
    }
    if (config.untitled_document && config.createTemporaryIntegratedConsole) {
      void this.logger.writeAndShowError(
        "PowerShell does not support debugging untitled files in a temporary console."
      );
      return PREVENT_DEBUG_START;
    }
    if (!config.createTemporaryIntegratedConsole && config.attachDotnetDebugger) {
      void this.logger.writeAndShowError(
        "dotnet debugging without using a temporary console is currently not supported. Please updated your launch config to include createTemporaryIntegratedConsole: true."
      );
      return PREVENT_DEBUG_START_AND_OPEN_DEBUGCONFIG;
    }
    if (config.sessionName) {
      config.createTemporaryIntegratedConsole = true;
    }
    if (config.attachDotnetDebugger) {
      return this.resolveAttachDotnetDebugConfiguration(config);
    }
    return config;
  }
  resolveAttachDotnetDebugConfiguration(config) {
    if (!import_vscode3.extensions.getExtension("ms-dotnettools.csharp")) {
      void this.logger.writeAndShowError(
        "You specified attachDotnetDebugger in your PowerShell Launch configuration but the C# extension is not installed. Please install the C# extension and try again."
      );
      return PREVENT_DEBUG_START;
    }
    const dotnetDebuggerConfig = this.getDotnetNamedConfigOrDefault(
      config.dotnetDebuggerConfigName
    );
    if (dotnetDebuggerConfig === void 0) {
      void this.logger.writeAndShowError(
        `You specified dotnetDebuggerConfigName in your PowerShell Launch configuration but a matching launch config was not found. Please ensure you have a coreclr attach config with the name ${config.dotnetDebuggerConfigName} in your launch.json file or remove dotnetDebuggerConfigName from your PowerShell Launch configuration to use the defaults`
      );
      return PREVENT_DEBUG_START_AND_OPEN_DEBUGCONFIG;
    }
    config.dotnetAttachConfig = dotnetDebuggerConfig;
    return config;
  }
  async createTemporaryIntegratedConsole(session) {
    const settings = getSettings();
    this.tempDebugProcess = await this.sessionManager.createDebugSessionProcess(
      settings,
      session.configuration.sessionName
    );
    const cancellationTokenSource = new import_vscode3.CancellationTokenSource();
    this.tempSessionDetails = await this.tempDebugProcess.start(
      cancellationTokenSource.token
    );
    if (session.configuration.attachDotnetDebugger) {
      const dotnetAttachConfig = session.configuration.dotnetAttachConfig;
      const pid = await this.tempDebugProcess.getPid();
      if (pid === void 0) {
        void this.logger.writeAndShowError(
          "Attach Dotnet Debugger was specified but the PowerShell temporary debug session failed to start. This is probably a bug."
        );
        return PREVENT_DEBUG_START;
      }
      dotnetAttachConfig.processId = pid;
      let tempConsoleDotnetAttachSession;
      const startDebugEvent = import_vscode3.debug.onDidStartDebugSession(
        (dotnetAttachSession) => {
          if (dotnetAttachSession.configuration.name != dotnetAttachConfig.name) {
            return;
          }
          startDebugEvent.dispose();
          this.logger.writeDebug(
            `Debugger session detected: ${dotnetAttachSession.name} (${dotnetAttachSession.id})`
          );
          tempConsoleDotnetAttachSession = dotnetAttachSession;
          const stopDebugEvent = import_vscode3.debug.onDidTerminateDebugSession(
            async (tempConsoleSession) => {
              if (tempConsoleDotnetAttachSession.parentSession?.id !== tempConsoleSession.id) {
                return;
              }
              stopDebugEvent.dispose();
              this.logger.writeDebug(
                `Debugger session terminated: ${tempConsoleSession.name} (${tempConsoleSession.id})`
              );
              const disconnectRequest = {
                command: "disconnect",
                seq: 0,
                type: "request",
                arguments: {
                  restart: false,
                  terminateDebuggee: false,
                  suspendDebuggee: false
                }
              };
              try {
                await dotnetAttachSession.customRequest(
                  disconnectRequest.command,
                  disconnectRequest.arguments
                );
              } catch (err) {
                this.logger.writeWarning(
                  `Disconnect request to dotnet debugger failed: ${err}`
                );
              }
            }
          );
        }
      );
      await import_vscode3.debug.startDebugging(void 0, dotnetAttachConfig, session);
      this.logger.writeDebug(
        `Dotnet attach debug configuration: ${JSON.stringify(dotnetAttachConfig, void 0, 2)}`
      );
      this.logger.writeDebug(
        `Attached dotnet debugger to process: ${pid}`
      );
    }
    return this.tempSessionDetails;
  }
  getDotnetNamedConfigOrDefault(configName) {
    if (configName) {
      const debugConfigs = this.getLaunchConfigurations();
      return debugConfigs.find(
        ({ type, request, name }) => type === "coreclr" && request === "attach" && name === configName
      );
    }
    return {
      name: "Dotnet Debugger: Temporary Extension Terminal",
      type: "coreclr",
      request: "attach",
      processId: void 0,
      logging: {
        moduleLoad: false
      }
    };
  }
  /** Fetches all available vscode launch configurations. This is abstracted out for easier testing. */
  getLaunchConfigurations() {
    return import_vscode3.workspace.getConfiguration("launch").get("configurations") ?? [];
  }
  async resolveAttachDebugConfiguration(config) {
    const platformDetails = getPlatformDetails();
    const versionDetails = this.sessionManager.getPowerShellVersionDetails();
    if (versionDetails === void 0) {
      void this.logger.writeAndShowError(
        `PowerShell session version details were not found for '${config.name}'.`
      );
      return PREVENT_DEBUG_START;
    }
    if (versionDetails.version < "7.0.0" && platformDetails.operatingSystem !== 1 /* Windows */) {
      void this.logger.writeAndShowError(
        `Attaching to a PowerShell Host Process on ${OperatingSystem[platformDetails.operatingSystem]} requires PowerShell 7.0 or higher (Current Version: ${versionDetails.version}).`
      );
      return PREVENT_DEBUG_START;
    }
    if (!config.customPipeName && !config.processId) {
      config.processId = await this.pickPSHostProcess();
      if (!config.processId) {
        return PREVENT_DEBUG_START;
      }
    }
    if (typeof config.processId === "string" && config.processId != "current") {
      config.processId = parseInt(config.processId);
    }
    if (config.processId === "current" || config.processId === await this.sessionManager.getLanguageServerPid()) {
      void this.logger.writeAndShowError(
        "Attaching to the PowerShell Extension terminal is not supported. Please use the 'PowerShell: Interactive Session' debug configuration instead."
      );
      return PREVENT_DEBUG_START_AND_OPEN_DEBUGCONFIG;
    }
    if (!config.runspaceId && !config.runspaceName) {
      config.runspaceId = await this.pickRunspace(config.processId);
      if (!config.runspaceId) {
        return PREVENT_DEBUG_START;
      }
    }
    return config;
  }
  async pickPSHostProcess() {
    const client = await LanguageClientConsumer.getLanguageClient();
    const response = await client.sendRequest(
      GetPSHostProcessesRequestType,
      {}
    );
    const items = [];
    for (const process3 of response) {
      let windowTitle = "";
      if (process3.mainWindowTitle) {
        windowTitle = `, ${process3.mainWindowTitle}`;
      }
      items.push({
        label: process3.processName,
        description: `PID: ${process3.processId.toString()}${windowTitle}`,
        processId: process3.processId
      });
    }
    if (items.length === 0) {
      return Promise.reject(
        new Error("There are no PowerShell host processes to attach.")
      );
    }
    const options = {
      placeHolder: "Select a PowerShell host process to attach.",
      matchOnDescription: true,
      matchOnDetail: true
    };
    const item = await import_vscode3.window.showQuickPick(items, options);
    return item?.processId ?? void 0;
  }
  async pickRunspace(processId) {
    const client = await LanguageClientConsumer.getLanguageClient();
    const response = await client.sendRequest(GetRunspaceRequestType, {
      processId
    });
    const items = [];
    for (const runspace of response) {
      items.push({
        label: runspace.name,
        description: `ID: ${runspace.id} - ${runspace.availability}`,
        id: runspace.id
      });
    }
    const options = {
      placeHolder: "Select PowerShell runspace to debug",
      matchOnDescription: true,
      matchOnDetail: true
    };
    const item = await import_vscode3.window.showQuickPick(items, options);
    return item?.id ?? void 0;
  }
};
var PowerShellDebugAdapterTrackerFactory = class {
  constructor(adapterName = "PowerShell") {
    this.adapterName = adapterName;
  }
  disposables = [];
  _log;
  /** Lazily creates a {@link LogOutputChannel} for debug tracing, and presents it only when DAP logging is enabled.
   *
   * We want to use a shared output log for separate debug sessions as usually only one is running at a time and we
   * dont need an output window for every debug session. We also want to leave it active so user can copy and paste
   * even on run end. When user changes the setting and disables it getter will return undefined, which will result
   * in a noop for the logging activities, effectively pausing logging but not disposing the output channel. If the
   * user re-enables, then logging resumes.
   */
  get log() {
    if (import_vscode3.workspace.getConfiguration("powershell.developer").get("traceDap") && this._log === void 0) {
      this._log = import_vscode3.window.createOutputChannel(
        `${this.adapterName}: Trace DAP`,
        { log: true }
      );
      this.disposables.push(this._log);
    }
    return this._log;
  }
  // This tracker effectively implements the logging for the debug adapter to a LogOutputChannel
  createDebugAdapterTracker(session) {
    const sessionInfo = `${this.adapterName} Debug Session: ${session.name} [${session.id}]`;
    return {
      onWillStartSession: () => this.log?.info(
        `Starting ${sessionInfo}. Set log level to trace to see DAP messages beyond errors`
      ),
      onWillStopSession: () => this.log?.info(`Stopping ${sessionInfo}`),
      onExit: (code) => this.log?.info(`${sessionInfo} exited with code ${code}`),
      onWillReceiveMessage: (m) => {
        this.log?.debug(`\u27A1\uFE0F${m.seq} ${m.type}: ${m.command}`);
        if (m.arguments && (Array.isArray(m.arguments) ? m.arguments.length > 0 : Object.keys(m.arguments).length > 0)) {
          this.log?.trace(
            `${m.seq}: ` + JSON.stringify(m.arguments, void 0, 2)
          );
        }
      },
      onDidSendMessage: (m) => {
        const responseSummary = m.request_seq !== void 0 ? `${m.success ? "\u2705" : "\u274C"}${m.request_seq} ${m.type}(${m.seq}): ${m.command}` : `\u2B05\uFE0F${m.seq} ${m.type}: ${m.event ?? m.command}`;
        this.log?.debug(responseSummary);
        if (m.body && (Array.isArray(m.body) ? m.body.length > 0 : Object.keys(m.body).length > 0)) {
          this.log?.trace(
            `${m.seq}: ` + JSON.stringify(m.body, void 0, 2)
          );
        }
      },
      onError: (e) => this.log?.error(e)
    };
  }
  dispose() {
    this.disposables.forEach((d) => d.dispose());
  }
};
var SpecifyScriptArgsFeature = class {
  command;
  context;
  constructor(context) {
    this.context = context;
    this.command = import_vscode3.commands.registerCommand(
      "PowerShell.SpecifyScriptArgs",
      () => {
        return this.specifyScriptArguments();
      }
    );
  }
  dispose() {
    this.command.dispose();
  }
  async specifyScriptArguments() {
    const powerShellDbgScriptArgsKey = "powerShellDebugScriptArgs";
    const options = {
      ignoreFocusOut: true,
      placeHolder: "Enter script arguments or leave empty to pass no args"
    };
    const prevArgs = this.context.workspaceState.get(
      powerShellDbgScriptArgsKey,
      ""
    );
    if (prevArgs.length > 0) {
      options.value = prevArgs;
    }
    const text = await import_vscode3.window.showInputBox(options);
    if (text !== void 0) {
      await this.context.workspaceState.update(
        powerShellDbgScriptArgsKey,
        text
      );
    }
    return text;
  }
};
var GetPSHostProcessesRequestType = new import_vscode_languageclient3.RequestType("powerShell/getPSHostProcesses");
var GetRunspaceRequestType = new import_vscode_languageclient3.RequestType("powerShell/getRunspace");

// src/features/Examples.ts
var path7 = require("path");
var utils4 = (init_utils(), __toCommonJS(utils_exports));
var vscode10 = require("vscode");
var ExamplesFeature = class {
  command;
  examplesPath;
  constructor() {
    this.examplesPath = vscode10.Uri.file(
      path7.resolve(__dirname, "../examples")
    );
    this.command = vscode10.commands.registerCommand(
      "PowerShell.OpenExamplesFolder",
      async () => {
        await vscode10.commands.executeCommand(
          "vscode.openFolder",
          this.examplesPath,
          true
        );
        return utils4.checkIfFileExists(this.examplesPath);
      }
    );
  }
  dispose() {
    this.command.dispose();
  }
};

// src/features/ExpandAlias.ts
var import_vscode_languageclient4 = __toESM(require_main4());
var vscode11 = require("vscode");
var ExpandAliasRequestType = new import_vscode_languageclient4.RequestType("powerShell/expandAlias");
var ExpandAliasFeature = class extends LanguageClientConsumer {
  command;
  constructor() {
    super();
    this.command = vscode11.commands.registerCommand(
      "PowerShell.ExpandAlias",
      async () => {
        const editor = vscode11.window.activeTextEditor;
        if (editor === void 0) {
          return;
        }
        const document = editor.document;
        const selection = editor.selection;
        const sls = selection.start;
        const sle = selection.end;
        let text;
        let range;
        if (sls.character === sle.character && sls.line === sle.line) {
          text = document.getText();
          range = new vscode11.Range(
            0,
            0,
            document.lineCount,
            text.length
          );
        } else {
          text = document.getText(selection);
          range = new vscode11.Range(
            sls.line,
            sls.character,
            sle.line,
            sle.character
          );
        }
        const client = await LanguageClientConsumer.getLanguageClient();
        const result = await client.sendRequest(
          ExpandAliasRequestType,
          { text }
        );
        await editor.edit((editBuilder) => {
          editBuilder.replace(range, result.text);
        });
      }
    );
  }
  onLanguageClientSet(_languageClient) {
  }
  dispose() {
    this.command.dispose();
  }
};

// src/features/ExtensionCommands.ts
var path8 = __toESM(require("path"));
var vscode12 = __toESM(require("vscode"));
var import_vscode_languageclient5 = __toESM(require_main4());
var import_node5 = __toESM(require_node3());
var InvokeExtensionCommandRequestType = new import_vscode_languageclient5.RequestType("powerShell/invokeExtensionCommand");
var ExtensionCommandAddedNotificationType = new import_vscode_languageclient5.NotificationType(
  "powerShell/extensionCommandAdded"
);
function asRange(value) {
  return { start: asPosition(value.start), end: asPosition(value.end) };
}
function asPosition(value) {
  return { line: value.line, character: value.character };
}
function asCodePosition(value) {
  return new vscode12.Position(value.line, value.character);
}
var GetEditorContextRequestType = new import_vscode_languageclient5.RequestType("editor/getEditorContext");
var InsertTextRequestType = new import_vscode_languageclient5.RequestType("editor/insertText");
var SetSelectionRequestType = new import_vscode_languageclient5.RequestType("editor/setSelection");
var OpenFileRequestType = new import_vscode_languageclient5.RequestType("editor/openFile");
var NewFileRequestType = new import_vscode_languageclient5.RequestType("editor/newFile");
var CloseFileRequestType = new import_vscode_languageclient5.RequestType("editor/closeFile");
var SaveFileRequestType = new import_vscode_languageclient5.RequestType("editor/saveFile");
var ShowErrorMessageRequestType = new import_vscode_languageclient5.RequestType("editor/showErrorMessage");
var ShowWarningMessageRequestType = new import_vscode_languageclient5.RequestType("editor/showWarningMessage");
var ShowInformationMessageRequestType = new import_vscode_languageclient5.RequestType("editor/showInformationMessage");
var SetStatusBarMessageRequestType = new import_vscode_languageclient5.RequestType("editor/setStatusBarMessage");
var ClearTerminalNotificationType = new import_vscode_languageclient5.NotificationType0(
  "editor/clearTerminal"
);
var ExtensionCommandsFeature = class _ExtensionCommandsFeature extends LanguageClientConsumer {
  constructor(logger2) {
    super();
    this.logger = logger2;
    this.commands = [
      vscode12.commands.registerCommand(
        "PowerShell.ShowAdditionalCommands",
        async () => {
          await this.showExtensionCommands();
        }
      ),
      vscode12.commands.registerCommand(
        "PowerShell.InvokeRegisteredEditorCommand",
        async (param) => {
          const commandToExecute = this.extensionCommands.find(
            (x) => x.name === param.commandName
          );
          if (commandToExecute) {
            const client = await LanguageClientConsumer.getLanguageClient();
            await client.sendRequest(
              InvokeExtensionCommandRequestType,
              {
                name: commandToExecute.name,
                context: this.getEditorContext()
              }
            );
          }
        }
      ),
      vscode12.commands.registerCommand(
        "PowerShell.ClosePanel",
        async () => {
          await vscode12.commands.executeCommand(
            "workbench.action.togglePanel"
          );
        }
      ),
      vscode12.commands.registerCommand(
        "PowerShell.PositionPanelLeft",
        async () => {
          await vscode12.commands.executeCommand(
            "workbench.action.positionPanelLeft"
          );
        }
      ),
      vscode12.commands.registerCommand(
        "PowerShell.PositionPanelBottom",
        async () => {
          await vscode12.commands.executeCommand(
            "workbench.action.positionPanelBottom"
          );
        }
      ),
      vscode12.commands.registerCommand(
        "PowerShell.Debug.Start",
        async () => {
          await vscode12.debug.startDebugging(
            void 0,
            DebugConfigurations[0 /* LaunchCurrentFile */]
          );
        }
      )
    ];
  }
  commands;
  handlers = [];
  statusBarMessages = [];
  extensionCommands = [];
  onLanguageClientSet(languageClient) {
    this.extensionCommands = [];
    this.handlers = [
      languageClient.onNotification(
        ExtensionCommandAddedNotificationType,
        (command) => {
          this.addExtensionCommand(command);
        }
      ),
      languageClient.onRequest(
        GetEditorContextRequestType,
        (_details) => this.getEditorContext()
      ),
      languageClient.onRequest(
        InsertTextRequestType,
        (details) => this.insertText(details)
      ),
      languageClient.onRequest(
        SetSelectionRequestType,
        (details) => this.setSelection(details)
      ),
      languageClient.onRequest(
        NewFileRequestType,
        (_content) => this.newFile(_content)
      ),
      languageClient.onRequest(
        OpenFileRequestType,
        (filePath) => this.openFile(filePath)
      ),
      languageClient.onRequest(
        CloseFileRequestType,
        (filePath) => this.closeFile(filePath)
      ),
      languageClient.onRequest(
        SaveFileRequestType,
        (saveFileDetails) => this.saveFile(saveFileDetails)
      ),
      languageClient.onRequest(
        ShowInformationMessageRequestType,
        (message) => this.showInformationMessage(message)
      ),
      languageClient.onRequest(
        ShowErrorMessageRequestType,
        (message) => this.showErrorMessage(message)
      ),
      languageClient.onRequest(
        ShowWarningMessageRequestType,
        (message) => this.showWarningMessage(message)
      ),
      languageClient.onRequest(
        SetStatusBarMessageRequestType,
        (messageDetails) => this.setStatusBarMessage(messageDetails)
      ),
      languageClient.onNotification(ClearTerminalNotificationType, () => {
        if (getSettings().integratedConsole.forceClearScrollbackBuffer) {
          void vscode12.commands.executeCommand(
            "workbench.action.terminal.clear"
          );
        }
      })
    ];
  }
  dispose() {
    for (const command of this.commands) {
      command.dispose();
    }
    for (const handler of this.handlers) {
      handler.dispose();
    }
    for (const statusBarMessage of this.statusBarMessages) {
      statusBarMessage.dispose();
    }
  }
  addExtensionCommand(command) {
    this.extensionCommands.push({
      name: command.name,
      displayName: command.displayName
    });
    this.extensionCommands.sort(
      (a, b) => a.name.localeCompare(b.name)
    );
  }
  async showExtensionCommands() {
    if (this.extensionCommands.length === 0) {
      void this.logger.writeAndShowInformation(
        "No extension commands have been loaded into the current session."
      );
      return;
    }
    const quickPickItems = this.extensionCommands.map(
      (command) => {
        return {
          label: command.displayName,
          description: command.name,
          command
        };
      }
    );
    const selectedCommand = await vscode12.window.showQuickPick(
      quickPickItems,
      { placeHolder: "Select a command..." }
    );
    return this.onCommandSelected(selectedCommand);
  }
  async onCommandSelected(chosenItem) {
    if (chosenItem !== void 0) {
      const client = await LanguageClientConsumer.getLanguageClient();
      await client.sendRequest(InvokeExtensionCommandRequestType, {
        name: chosenItem.command.name,
        context: this.getEditorContext()
      });
    }
  }
  async insertText(details) {
    const edit = new vscode12.WorkspaceEdit();
    edit.set(vscode12.Uri.parse(details.filePath), [
      new vscode12.TextEdit(
        new vscode12.Range(
          details.insertRange.start.line,
          details.insertRange.start.character,
          details.insertRange.end.line,
          details.insertRange.end.character
        ),
        details.insertText
      )
    ]);
    await vscode12.workspace.applyEdit(edit);
    return 0 /* Completed */;
  }
  getEditorContext() {
    if (vscode12.window.activeTextEditor === void 0) {
      return void 0;
    }
    return {
      currentFileContent: vscode12.window.activeTextEditor.document.getText(),
      currentFileLanguage: vscode12.window.activeTextEditor.document.languageId,
      currentFilePath: vscode12.window.activeTextEditor.document.uri.toString(),
      cursorPosition: asPosition(
        vscode12.window.activeTextEditor.selection.active
      ),
      selectionRange: asRange(
        new vscode12.Range(
          vscode12.window.activeTextEditor.selection.start,
          vscode12.window.activeTextEditor.selection.end
        )
      )
    };
  }
  async newFile(content) {
    const doc = await vscode12.workspace.openTextDocument({
      language: "powershell",
      content
    });
    await vscode12.window.showTextDocument(doc);
    return 0 /* Completed */;
  }
  async openFile(openFileDetails) {
    const filePath = await this.resolveFilePathWithCwd(
      openFileDetails.filePath
    );
    try {
      const doc = await vscode12.workspace.openTextDocument(filePath);
      await vscode12.window.showTextDocument(doc, {
        preview: openFileDetails.preview
      });
    } catch {
      void this.logger.writeAndShowWarning(
        `File to open not found: ${filePath}`
      );
      return 1 /* Failed */;
    }
    return 0 /* Completed */;
  }
  async closeFile(filePath) {
    filePath = await this.resolveFilePathWithCwd(filePath);
    const doc = vscode12.workspace.textDocuments.find(
      (x) => x.uri.fsPath === filePath
    );
    if (doc != void 0 && !doc.isClosed) {
      await vscode12.window.showTextDocument(doc);
      await vscode12.commands.executeCommand(
        "workbench.action.closeActiveEditor"
      );
      return 0 /* Completed */;
    }
    void this.logger.writeAndShowWarning(
      `File to close not found or already closed: ${filePath}`
    );
    return 1 /* Failed */;
  }
  /**
   * Save a file, possibly to a new path. If the save is not possible, return a completed response
   * @param saveFileDetails the object detailing the path of the file to save and optionally its new path to save to
   */
  async saveFile(saveFileDetails) {
    let currentFileUri;
    if (saveFileDetails.filePath.startsWith("untitled") || saveFileDetails.filePath.startsWith("file")) {
      currentFileUri = vscode12.Uri.parse(saveFileDetails.filePath);
    } else {
      const filePath = await this.resolveFilePathWithCwd(
        saveFileDetails.filePath
      );
      currentFileUri = vscode12.Uri.file(filePath);
    }
    const doc = vscode12.workspace.textDocuments.find(
      (x) => x.uri.fsPath === currentFileUri.fsPath
    );
    if (doc === void 0) {
      void this.logger.writeAndShowWarning(
        `File to save not found: ${currentFileUri.fsPath}`
      );
      return 1 /* Failed */;
    }
    let newFilePath = saveFileDetails.newPath ?? void 0;
    if (currentFileUri.scheme === "file") {
      if (newFilePath === void 0) {
        if (doc.isDirty) {
          await doc.save();
        }
        return 0 /* Completed */;
      }
      if (!path8.isAbsolute(newFilePath)) {
        newFilePath = path8.join(
          path8.dirname(currentFileUri.fsPath),
          newFilePath
        );
      }
    } else if (currentFileUri.scheme === "untitled") {
      if (newFilePath === void 0) {
        void this.logger.writeAndShowWarning(
          'Cannot save untitled file! Try SaveAs("path/to/file.ps1") instead.'
        );
        return 1 /* Failed */;
      }
      newFilePath = await this.resolveFilePathWithCwd(newFilePath);
    } else {
      const msg = JSON.stringify(saveFileDetails, void 0, 2);
      void this.logger.writeAndShowWarning(
        `<${_ExtensionCommandsFeature.name}>: Saving a document with scheme '${currentFileUri.scheme}' is currently unsupported. Message: '${msg}'`
      );
      return 1 /* Failed */;
    }
    return await this.saveFileAs(doc, newFilePath);
  }
  /**
   * Take a document available to vscode at the given URI and save it to the given absolute path
   * @param documentUri the URI of the vscode document to save
   * @param filePath the absolute path to save the document contents to
   */
  async saveFileAs(doc, filePath) {
    const newFileUri = vscode12.Uri.file(filePath);
    try {
      await vscode12.workspace.fs.writeFile(
        newFileUri,
        Buffer.from(doc.getText())
      );
    } catch (err) {
      void this.logger.writeAndShowWarning(
        `<${_ExtensionCommandsFeature.name}>: Unable to save file to path '${filePath}': ${err}`
      );
      return 1 /* Failed */;
    }
    const newFile = await vscode12.workspace.openTextDocument(newFileUri);
    await vscode12.window.showTextDocument(newFile, { preview: true });
    return 0 /* Completed */;
  }
  // Resolve file path against user's CWD setting
  async resolveFilePathWithCwd(filePath) {
    if (!path8.isAbsolute(filePath)) {
      const cwd = await validateCwdSetting(this.logger);
      return path8.resolve(cwd, filePath);
    }
    return filePath;
  }
  setSelection(details) {
    if (vscode12.window.activeTextEditor !== void 0) {
      vscode12.window.activeTextEditor.selections = [
        new vscode12.Selection(
          asCodePosition(details.selectionRange.start),
          asCodePosition(details.selectionRange.end)
        )
      ];
      return 0 /* Completed */;
    }
    return 1 /* Failed */;
  }
  showInformationMessage(message) {
    void this.logger.writeAndShowInformation(message);
    return 0 /* Completed */;
  }
  showErrorMessage(message) {
    void this.logger.writeAndShowError(message);
    return 0 /* Completed */;
  }
  showWarningMessage(message) {
    void this.logger.writeAndShowWarning(message);
    return 0 /* Completed */;
  }
  setStatusBarMessage(messageDetails) {
    if (messageDetails.timeout) {
      this.statusBarMessages.push(
        vscode12.window.setStatusBarMessage(
          messageDetails.message,
          messageDetails.timeout
        )
      );
    } else {
      this.statusBarMessages.push(
        vscode12.window.setStatusBarMessage(messageDetails.message)
      );
    }
    return 0 /* Completed */;
  }
};

// node_modules/uuid/dist/esm-node/rng.js
var import_crypto = __toESM(require("crypto"));
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-node/native.js
var import_crypto2 = __toESM(require("crypto"));
var native_default = {
  randomUUID: import_crypto2.default.randomUUID
};

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/features/ExternalApi.ts
var vscode13 = __toESM(require("vscode"));
var ExternalApiFeature = class _ExternalApiFeature {
  constructor(extensionContext, sessionManager2, logger2) {
    this.extensionContext = extensionContext;
    this.sessionManager = sessionManager2;
    this.logger = logger2;
  }
  static registeredExternalExtension = /* @__PURE__ */ new Map();
  /*
      DESCRIPTION:
          Registers your extension to allow usage of the external API. The returns
          a session UUID that will need to be passed in to subsequent API calls.
  
      USAGE:
          powerShellExtensionClient.registerExternalExtension(
              "ms-vscode.PesterTestExplorer" // the name of the extension using us
              "v1"); // API Version.
  
      RETURNS:
          string session uuid
      */
  registerExternalExtension(id, apiVersion = "v1") {
    this.logger.writeDebug(
      `Registering extension '${id}' for use with API version '${apiVersion}'.`
    );
    for (const [
      _name,
      externalExtension
    ] of _ExternalApiFeature.registeredExternalExtension) {
      if (externalExtension.id === id) {
        const message = `The extension '${id}' is already registered.`;
        this.logger.writeWarning(message);
        throw new Error(message);
      }
    }
    if (!vscode13.extensions.all.some((ext) => ext.id === id)) {
      throw new Error(
        `No extension installed with id '${id}'. You must use a valid extension id.`
      );
    }
    if (id === "ms-vscode.powershell" && !(this.extensionContext.extensionMode === vscode13.ExtensionMode.Test)) {
      throw new Error(
        "You can't use the PowerShell extension's id in this registration."
      );
    }
    const uuid = v4_default();
    _ExternalApiFeature.registeredExternalExtension.set(uuid, {
      id,
      apiVersion
    });
    return uuid;
  }
  /*
      DESCRIPTION:
          Unregisters a session that an extension has. This returns
          true if it succeeds or throws if it fails.
  
      USAGE:
          powerShellExtensionClient.unregisterExternalExtension(
              "uuid"); // the uuid from above for tracking purposes
  
      RETURNS:
          true if it worked, otherwise throws an error.
      */
  unregisterExternalExtension(uuid = "") {
    this.logger.writeDebug(
      `Unregistering extension with session UUID: ${uuid}`
    );
    if (!_ExternalApiFeature.registeredExternalExtension.delete(uuid)) {
      throw new Error(
        `No extension registered with session UUID: ${uuid}`
      );
    }
    return true;
  }
  getRegisteredExtension(uuid = "") {
    if (!_ExternalApiFeature.registeredExternalExtension.has(uuid)) {
      throw new Error(
        "UUID provided was invalid, make sure you ran the 'powershellExtensionClient.registerExternalExtension(extensionId)' method and pass in the UUID that it returns to subsequent methods."
      );
    }
    return _ExternalApiFeature.registeredExternalExtension.get(uuid);
  }
  /*
      DESCRIPTION:
          This will fetch the version details of the PowerShell used to start
          PowerShell Editor Services in the PowerShell extension.
  
      USAGE:
          powerShellExtensionClient.getPowerShellVersionDetails(
              "uuid"); // the uuid from above for tracking purposes
  
      RETURNS:
          An IPowerShellVersionDetails which consists of:
          {
              version: string;
              displayVersion: string;
              edition: string;
              architecture: string;
          }
      */
  async getPowerShellVersionDetails(uuid = "") {
    const extension = this.getRegisteredExtension(uuid);
    this.logger.writeDebug(
      `Extension '${extension.id}' called 'getPowerShellVersionDetails'.`
    );
    await this.sessionManager.waitUntilStarted();
    const versionDetails = this.sessionManager.getPowerShellVersionDetails();
    return {
      exePath: this.sessionManager.PowerShellExeDetails?.exePath ?? "unknown",
      version: versionDetails?.version ?? "unknown",
      displayName: this.sessionManager.PowerShellExeDetails?.displayName ?? "unknown",
      // comes from the Session Menu
      architecture: versionDetails?.architecture ?? "unknown"
    };
  }
  /*
      DESCRIPTION:
          This will wait until the extension's PowerShell session is started.
  
      USAGE:
          powerShellExtensionClient.waitUntilStarted(
              "uuid"); // the uuid from above for tracking purposes
  
      RETURNS:
          A void promise that resolves only once the extension is started.
  
          If the extension is not started by some mechanism
          then this will wait indefinitely.
      */
  async waitUntilStarted(uuid = "") {
    const extension = this.getRegisteredExtension(uuid);
    this.logger.writeDebug(
      `Extension '${extension.id}' called 'waitUntilStarted'.`
    );
    await this.sessionManager.waitUntilStarted();
  }
  getStorageUri() {
    return this.extensionContext.globalStorageUri.with({ scheme: "file" });
  }
  getLogUri() {
    return this.extensionContext.logUri.with({ scheme: "file" });
  }
  dispose() {
  }
};

// src/features/GenerateBugReport.ts
var vscode14 = require("vscode");
var child_process = require("child_process");
var issuesUrl = "https://github.com/PowerShell/vscode-powershell/issues/new?";
var GenerateBugReportFeature = class {
  constructor(sessionManager2) {
    this.sessionManager = sessionManager2;
    this.command = vscode14.commands.registerCommand(
      "PowerShell.GenerateBugReport",
      async () => {
        const params = [
          "labels=Issue-Bug",
          "template=bug-report.yml",
          "powershell-version=" + this.getRuntimeInfo(),
          "vscode-version=" + vscode14.version + "\n" + process.arch,
          "extension-version=" + sessionManager2.Publisher + "." + sessionManager2.HostName + "@" + sessionManager2.HostVersion
        ];
        const url = vscode14.Uri.parse(
          issuesUrl + encodeURIComponent(params.join("&"))
        );
        await vscode14.env.openExternal(url);
      }
    );
  }
  command;
  dispose() {
    this.command.dispose();
  }
  getRuntimeInfo() {
    if (this.sessionManager.PowerShellExeDetails === void 0) {
      return "Session's PowerShell details are unknown!";
    }
    const child = child_process.spawnSync(
      this.sessionManager.PowerShellExeDetails.exePath,
      [
        "-NoProfile",
        "-NoLogo",
        "-Command",
        "$PSVersionTable | Out-String"
      ]
    );
    return child.stdout.toString().trim().replace(";", ",");
  }
};

// src/features/GetCommands.ts
var vscode15 = __toESM(require("vscode"));
var import_vscode_languageclient6 = __toESM(require_main4());
var import_node6 = __toESM(require_node3());
var GetCommandRequestType = new import_vscode_languageclient6.RequestType0(
  "powerShell/getCommand"
);
var GetCommandsFeature = class extends LanguageClientConsumer {
  commands;
  commandsExplorerProvider;
  commandsExplorerTreeView;
  constructor() {
    super();
    this.commands = [
      vscode15.commands.registerCommand(
        "PowerShell.RefreshCommandsExplorer",
        async () => {
          await this.CommandExplorerRefresh();
        }
      ),
      vscode15.commands.registerCommand(
        "PowerShell.InsertCommand",
        async (item) => {
          await this.InsertCommand(item);
        }
      )
    ];
    this.commandsExplorerProvider = new CommandsExplorerProvider();
    this.commandsExplorerTreeView = vscode15.window.createTreeView(
      "PowerShellCommands",
      { treeDataProvider: this.commandsExplorerProvider }
    );
    this.commandsExplorerTreeView.onDidChangeVisibility(async (e) => {
      if (e.visible) {
        await this.CommandExplorerRefresh();
      }
    });
  }
  dispose() {
    for (const command of this.commands) {
      command.dispose();
    }
  }
  onLanguageClientSet(_languageClient) {
    if (this.commandsExplorerTreeView.visible) {
      void vscode15.commands.executeCommand(
        "PowerShell.RefreshCommandsExplorer"
      );
    }
  }
  async CommandExplorerRefresh() {
    const client = await LanguageClientConsumer.getLanguageClient();
    const result = await client.sendRequest(GetCommandRequestType);
    const exclusions = getSettings().sideBar.CommandExplorerExcludeFilter;
    const excludeFilter = exclusions.map(
      (filter) => filter.toLowerCase()
    );
    const filteredResult = result.filter(
      (command) => !excludeFilter.includes(command.moduleName.toLowerCase())
    );
    this.commandsExplorerProvider.powerShellCommands = filteredResult.map(toCommand);
    this.commandsExplorerProvider.refresh();
  }
  async InsertCommand(item) {
    const editor = vscode15.window.activeTextEditor;
    if (editor === void 0) {
      return;
    }
    const sls = editor.selection.start;
    const sle = editor.selection.end;
    const range = new vscode15.Range(
      sls.line,
      sls.character,
      sle.line,
      sle.character
    );
    await editor.edit((editBuilder) => {
      editBuilder.replace(range, item.Name);
    });
  }
};
var CommandsExplorerProvider = class {
  onDidChangeTreeData;
  powerShellCommands = [];
  didChangeTreeData = new vscode15.EventEmitter();
  constructor() {
    this.onDidChangeTreeData = this.didChangeTreeData.event;
  }
  refresh() {
    this.didChangeTreeData.fire(void 0);
  }
  getTreeItem(element) {
    return element;
  }
  getChildren(_element) {
    return Promise.resolve(this.powerShellCommands);
  }
};
function toCommand(command) {
  return new Command(
    command.name,
    command.moduleName,
    command.defaultParameterSet,
    command.parameterSets,
    command.parameters
  );
}
var Command = class extends vscode15.TreeItem {
  constructor(Name, ModuleName, defaultParameterSet, ParameterSets, Parameters, collapsibleState = vscode15.TreeItemCollapsibleState.None) {
    super(Name, collapsibleState);
    this.Name = Name;
    this.ModuleName = ModuleName;
    this.defaultParameterSet = defaultParameterSet;
    this.ParameterSets = ParameterSets;
    this.Parameters = Parameters;
    this.collapsibleState = collapsibleState;
  }
  getTreeItem() {
    return {
      label: this.label,
      collapsibleState: this.collapsibleState
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/require-await
  async getChildren(_element) {
    return [];
  }
};

// src/features/HelpCompletion.ts
var import_vscode4 = require("vscode");
var import_vscode_languageclient7 = __toESM(require_main4());
var import_node7 = __toESM(require_node3());
var CommentHelpRequestType = new import_vscode_languageclient7.RequestType("powerShell/getCommentHelp");
var HelpCompletionFeature = class extends LanguageClientConsumer {
  helpCompletionProvider;
  disposable;
  settings;
  constructor() {
    super();
    this.settings = getSettings();
    if (this.settings.helpCompletion !== "Disabled" /* Disabled */) {
      this.helpCompletionProvider = new HelpCompletionProvider();
      this.disposable = import_vscode4.workspace.onDidChangeTextDocument(async (e) => {
        await this.onEvent(e);
      });
    }
  }
  dispose() {
    this.disposable?.dispose();
  }
  onLanguageClientSet(languageClient) {
    this.helpCompletionProvider?.onLanguageClientSet(languageClient);
  }
  async onEvent(changeEvent) {
    if (changeEvent.document.languageId !== "powershell") {
      return;
    }
    if (changeEvent.contentChanges.length > 0) {
      this.helpCompletionProvider?.updateState(
        changeEvent.document,
        changeEvent.contentChanges[0].text,
        changeEvent.contentChanges[0].range
      );
      if (this.helpCompletionProvider?.triggerFound) {
        await this.helpCompletionProvider.complete();
        this.helpCompletionProvider.reset();
      }
    }
  }
};
var TriggerFinder = class {
  constructor(triggerCharacters) {
    this.triggerCharacters = triggerCharacters;
    this.state = 0 /* Searching */;
    this.count = 0;
  }
  state;
  document;
  count;
  get found() {
    return this.state === 2 /* Found */;
  }
  updateState(document, changeText) {
    switch (this.state) {
      case 0 /* Searching */:
        if (changeText.length === 1 && // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        changeText[0] === this.triggerCharacters[this.count]) {
          this.state = 1 /* Locked */;
          this.document = document;
          this.count++;
        }
        break;
      case 1 /* Locked */:
        if (document === this.document && changeText.length === 1 && // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        changeText[0] === this.triggerCharacters[this.count]) {
          this.count++;
          if (this.count === this.triggerCharacters.length) {
            this.state = 2 /* Found */;
          }
        } else {
          this.reset();
        }
        break;
      default:
        this.reset();
        break;
    }
  }
  reset() {
    this.state = 0 /* Searching */;
    this.count = 0;
  }
};
var HelpCompletionProvider = class extends LanguageClientConsumer {
  triggerFinderHelpComment;
  lastChangeRange;
  lastDocument;
  settings;
  constructor() {
    super();
    this.triggerFinderHelpComment = new TriggerFinder("##");
    this.settings = getSettings();
  }
  get triggerFound() {
    return this.triggerFinderHelpComment.found;
  }
  onLanguageClientSet(_languageClient) {
  }
  updateState(document, changeText, changeRange) {
    this.lastDocument = document;
    this.lastChangeRange = changeRange;
    this.triggerFinderHelpComment.updateState(document, changeText);
  }
  reset() {
    this.triggerFinderHelpComment.reset();
  }
  async complete() {
    if (this.lastChangeRange === void 0 || this.lastDocument === void 0) {
      return;
    }
    const triggerStartPos = this.lastChangeRange.start;
    const doc = this.lastDocument;
    const client = await LanguageClientConsumer.getLanguageClient();
    const result = await client.sendRequest(CommentHelpRequestType, {
      documentUri: doc.uri.toString(),
      triggerPosition: triggerStartPos,
      blockComment: this.settings.helpCompletion === "BlockComment" /* BlockComment */
    });
    if (result.content.length === 0) {
      return;
    }
    const replaceRange = new import_vscode4.Range(
      triggerStartPos.translate(0, -1),
      triggerStartPos.translate(0, 1)
    );
    const lines = result.content;
    const text = lines.map((x) => x.trimStart()).join(this.getEOL(doc.eol));
    const snippetString = new import_vscode4.SnippetString(text);
    await import_vscode4.window.activeTextEditor?.insertSnippet(
      snippetString,
      replaceRange
    );
  }
  getEOL(eol) {
    if (eol === import_vscode4.EndOfLine.CRLF) {
      return "\r\n";
    }
    return "\n";
  }
};

// src/features/ISECompatibility.ts
var vscode16 = __toESM(require("vscode"));
var ISECompatibilityFeature = class _ISECompatibilityFeature {
  // Marking settings as public so we can use it within the tests without needing to duplicate the list of settings.
  static settings = [
    { path: "debug", name: "openDebug", value: "neverOpen" },
    { path: "editor", name: "tabCompletion", value: "on" },
    {
      path: "powershell.integratedConsole",
      name: "focusConsoleOnExecute",
      value: false
    },
    { path: "files", name: "defaultLanguage", value: "powershell" },
    { path: "workbench", name: "colorTheme", value: "PowerShell ISE" },
    {
      path: "editor",
      name: "wordSeparators",
      value: "`~!@#%^&*()-=+[{]}\\|;:'\",.<>/?"
    },
    {
      path: "powershell.buttons",
      name: "showPanelMovementButtons",
      value: true
    },
    { path: "powershell.codeFolding", name: "showLastLine", value: false },
    {
      path: "powershell.sideBar",
      name: "CommandExplorerVisibility",
      value: true
    }
  ];
  commands = [];
  iseModeEnabled;
  originalSettings = {};
  constructor() {
    const testSetting = _ISECompatibilityFeature.settings[_ISECompatibilityFeature.settings.length - 1];
    this.iseModeEnabled = vscode16.workspace.getConfiguration(testSetting.path).get(testSetting.name) === testSetting.value;
    this.commands = [
      vscode16.commands.registerCommand(
        "PowerShell.EnableISEMode",
        async () => {
          await this.EnableISEMode();
        }
      ),
      vscode16.commands.registerCommand(
        "PowerShell.DisableISEMode",
        async () => {
          await this.DisableISEMode();
        }
      ),
      vscode16.commands.registerCommand(
        "PowerShell.ToggleISEMode",
        async () => {
          await this.ToggleISEMode();
        }
      )
    ];
  }
  dispose() {
    for (const command of this.commands) {
      command.dispose();
    }
  }
  async EnableISEMode() {
    this.iseModeEnabled = true;
    for (const iseSetting of _ISECompatibilityFeature.settings) {
      try {
        const config = vscode16.workspace.getConfiguration(
          iseSetting.path
        );
        this.originalSettings[iseSetting.path + iseSetting.name] = config.get(iseSetting.name);
        await config.update(iseSetting.name, iseSetting.value, true);
      } catch {
      }
    }
    await vscode16.commands.executeCommand(
      "workbench.view.extension.PowerShell"
    );
  }
  async DisableISEMode() {
    this.iseModeEnabled = false;
    for (const iseSetting of _ISECompatibilityFeature.settings) {
      const config = vscode16.workspace.getConfiguration(iseSetting.path);
      const currently = config.get(iseSetting.name);
      if (currently === iseSetting.value) {
        await config.update(
          iseSetting.name,
          this.originalSettings[iseSetting.path + iseSetting.name],
          true
        );
      }
    }
  }
  async ToggleISEMode() {
    if (this.iseModeEnabled) {
      await this.DisableISEMode();
    } else {
      await this.EnableISEMode();
    }
  }
};

// src/features/OpenInISE.ts
var ChildProcess = require("child_process");
var vscode17 = require("vscode");
var OpenInISEFeature = class {
  command;
  constructor() {
    this.command = vscode17.commands.registerCommand(
      "PowerShell.OpenInISE",
      () => {
        const editor = vscode17.window.activeTextEditor;
        if (editor === void 0) {
          return;
        }
        const document = editor.document;
        const uri = document.uri;
        let ISEPath = process.env.windir ?? "C:\\Windows";
        if (process.env.PROCESSOR_ARCHITEW6432 !== void 0) {
          ISEPath += "\\Sysnative";
        } else {
          ISEPath += "\\System32";
        }
        ISEPath += "\\WindowsPowerShell\\v1.0\\powershell_ise.exe";
        ChildProcess.exec(`${ISEPath} -File "${uri.fsPath}"`).unref();
      }
    );
  }
  dispose() {
    this.command.dispose();
  }
};

// src/features/PesterTests.ts
var path9 = __toESM(require("path"));
var vscode18 = require("vscode");
var utils5 = (init_utils(), __toCommonJS(utils_exports));
var PesterTestsFeature = class {
  constructor(sessionManager2, logger2) {
    this.sessionManager = sessionManager2;
    this.logger = logger2;
    this.invokePesterStubScriptPath = path9.resolve(
      __dirname,
      "../modules/PowerShellEditorServices/InvokePesterStub.ps1"
    );
    this.commands = [
      // File context-menu command - Run Pester Tests
      vscode18.commands.registerCommand(
        "PowerShell.RunPesterTestsFromFile",
        (fileUri) => {
          return this.launchAllTestsInActiveEditor(
            1 /* Run */,
            fileUri
          );
        }
      ),
      // File context-menu command - Debug Pester Tests
      vscode18.commands.registerCommand(
        "PowerShell.DebugPesterTestsFromFile",
        (fileUri) => {
          return this.launchAllTestsInActiveEditor(
            0 /* Debug */,
            fileUri
          );
        }
      ),
      // This command is provided for usage by PowerShellEditorServices (PSES) only
      vscode18.commands.registerCommand(
        "PowerShell.RunPesterTests",
        (uriString, runInDebugger, describeBlockName, describeBlockLineNumber, outputPath) => {
          return this.launchTests(
            vscode18.Uri.parse(uriString),
            runInDebugger,
            describeBlockName,
            describeBlockLineNumber,
            outputPath
          );
        }
      )
    ];
  }
  commands;
  invokePesterStubScriptPath;
  dispose() {
    for (const command of this.commands) {
      command.dispose();
    }
  }
  async launchAllTestsInActiveEditor(launchType, fileUri) {
    fileUri ??= vscode18.window.activeTextEditor?.document.uri;
    if (fileUri === void 0) {
      return false;
    }
    const launchConfig = this.createLaunchConfig(fileUri, launchType);
    return this.launch(launchConfig);
  }
  async launchTests(fileUri, runInDebugger, describeBlockName, describeBlockLineNumber, outputPath) {
    const launchType = runInDebugger ? 0 /* Debug */ : 1 /* Run */;
    const launchConfig = this.createLaunchConfig(
      fileUri,
      launchType,
      describeBlockName,
      describeBlockLineNumber,
      outputPath
    );
    return this.launch(launchConfig);
  }
  createLaunchConfig(fileUri, launchType, testName, lineNum, outputPath) {
    const settings = getSettings();
    const launchConfig = {
      request: "launch",
      type: "PowerShell",
      name: "PowerShell: Launch Pester Tests",
      script: this.invokePesterStubScriptPath,
      args: [
        "-ScriptPath",
        `'${utils5.escapeSingleQuotes(fileUri.fsPath)}'`
      ],
      internalConsoleOptions: "neverOpen",
      noDebug: launchType === 1 /* Run */,
      createTemporaryIntegratedConsole: settings.debugging.createTemporaryIntegratedConsole
    };
    if (lineNum) {
      launchConfig.args.push("-LineNumber", `${lineNum}`);
    } else if (testName) {
      launchConfig.args.push(
        "-TestName",
        `'${utils5.escapeSingleQuotes(testName)}'`
      );
    } else {
      launchConfig.args.push("-All");
    }
    if (!settings.pester.useLegacyCodeLens) {
      launchConfig.args.push("-MinimumVersion5");
    }
    if (launchType === 0 /* Debug */) {
      launchConfig.args.push(
        "-Output",
        `'${settings.pester.debugOutputVerbosity}'`
      );
    } else {
      launchConfig.args.push(
        "-Output",
        `'${settings.pester.outputVerbosity}'`
      );
    }
    if (outputPath) {
      launchConfig.args.push("-OutputPath", `'${outputPath}'`);
    }
    return launchConfig;
  }
  async launch(launchConfig) {
    this.sessionManager.showDebugTerminal(true);
    return await utils5.checkIfFileExists(this.invokePesterStubScriptPath) && vscode18.debug.startDebugging(
      await getChosenWorkspace(this.logger),
      launchConfig
    );
  }
};

// src/features/RemoteFiles.ts
var import_vscode_languageclient8 = __toESM(require_main4());
var os4 = require("os");
var path10 = require("path");
var vscode19 = require("vscode");
var DidSaveTextDocumentNotificationType = new import_vscode_languageclient8.NotificationType("textDocument/didSave");
var RemoteFilesFeature = class extends LanguageClientConsumer {
  command;
  tempSessionPathPrefix;
  constructor() {
    super();
    this.tempSessionPathPrefix = path10.join(os4.tmpdir(), "PSES-").toLowerCase();
    this.closeRemoteFiles();
    this.command = vscode19.workspace.onDidSaveTextDocument(async (doc) => {
      if (this.isDocumentRemote(doc)) {
        const client = await LanguageClientConsumer.getLanguageClient();
        await client.sendNotification(
          DidSaveTextDocumentNotificationType,
          {
            textDocument: import_vscode_languageclient8.TextDocumentIdentifier.create(
              doc.uri.toString()
            )
          }
        );
      }
    });
  }
  onLanguageClientSet(_languageClient) {
  }
  dispose() {
    this.command.dispose();
    this.closeRemoteFiles();
  }
  isDocumentRemote(doc) {
    return doc.fileName.toLowerCase().startsWith(this.tempSessionPathPrefix);
  }
  closeRemoteFiles() {
    const remoteDocuments = vscode19.workspace.textDocuments.filter(
      (doc) => this.isDocumentRemote(doc)
    );
    async function innerCloseFiles() {
      const doc = remoteDocuments.pop();
      if (doc === void 0) {
        return;
      }
      await vscode19.window.showTextDocument(doc);
      await vscode19.commands.executeCommand(
        "workbench.action.closeActiveEditor"
      );
      await innerCloseFiles();
    }
    void innerCloseFiles();
  }
};

// src/features/ShowHelp.ts
var import_vscode_languageclient9 = __toESM(require_main4());
var vscode20 = require("vscode");
var ShowHelpNotificationType = new import_vscode_languageclient9.NotificationType("powerShell/showHelp");
var ShowHelpFeature = class extends LanguageClientConsumer {
  command;
  constructor() {
    super();
    this.command = vscode20.commands.registerCommand(
      "PowerShell.ShowHelp",
      async (item) => {
        if (!item?.Name) {
          const editor = vscode20.window.activeTextEditor;
          if (editor === void 0) {
            return;
          }
          const selection = editor.selection;
          const doc = editor.document;
          const cwr = doc.getWordRangeAtPosition(selection.active);
          const text = doc.getText(cwr);
          const client = await LanguageClientConsumer.getLanguageClient();
          await client.sendNotification(ShowHelpNotificationType, {
            text
          });
        } else {
          const client = await LanguageClientConsumer.getLanguageClient();
          await client.sendNotification(ShowHelpNotificationType, {
            text: item.Name
          });
        }
      }
    );
  }
  onLanguageClientSet(_languageClient) {
  }
  dispose() {
    this.command.dispose();
  }
};

// src/extension.ts
init_utils();
var vscode21 = require("vscode");
var TELEMETRY_KEY = "0c6ae279ed8443289764825290e4f9e2-1a736e7c-1324-4338-be46-fc2a58ae4d14-7255";
var languageConfigurationDisposable;
var logger;
var sessionManager;
var languageClientConsumers = [];
var commandRegistrations = [];
var telemetryReporter;
var documentSelector = [
  { language: "powershell", scheme: "file" },
  { language: "powershell", scheme: "untitled" }
];
async function activate(context) {
  logger = new Logger();
  if (context.extensionMode === vscode21.ExtensionMode.Development) {
    restartOnExtensionFileChanges(context);
  }
  telemetryReporter = new import_extension_telemetry.default(TELEMETRY_KEY);
  const settings = getSettings();
  logger.writeDebug(
    `Loaded settings:
${JSON.stringify(settings, void 0, 2)}`
  );
  languageConfigurationDisposable = vscode21.languages.setLanguageConfiguration(
    PowerShellLanguageId,
    {
      // TODO: Remove the useless escapes
      wordPattern: (
        // eslint-disable-next-line no-useless-escape
        /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\=\+\[\{\]\}\\\|\;\'\"\,\.\<\>\/\?\s]+)/g
      ),
      indentationRules: {
        // ^(.*\*/)?\s*\}.*$
        decreaseIndentPattern: /^(.*\*\/)?\s*\}.*$/,
        // ^.*\{[^}"']*$
        increaseIndentPattern: /^.*\{[^}"']*$/
      },
      comments: {
        lineComment: "#",
        blockComment: ["<#", "#>"]
      },
      brackets: [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"]
      ],
      onEnterRules: [
        {
          // e.g. /** | */
          // eslint-disable-next-line no-useless-escape
          beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
          afterText: /^\s*\*\/$/,
          action: {
            indentAction: vscode21.IndentAction.IndentOutdent,
            appendText: " * "
          }
        },
        {
          // e.g. /** ...|
          // eslint-disable-next-line no-useless-escape
          beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
          action: {
            indentAction: vscode21.IndentAction.None,
            appendText: " * "
          }
        },
        {
          // e.g.  * ...|
          // eslint-disable-next-line no-useless-escape
          beforeText: /^(\t|(\ \ ))*\ \*(\ ([^\*]|\*(?!\/))*)?$/,
          action: {
            indentAction: vscode21.IndentAction.None,
            appendText: "* "
          }
        },
        {
          // e.g.  */|
          // eslint-disable-next-line no-useless-escape
          beforeText: /^(\t|(\ \ ))*\ \*\/\s*$/,
          action: {
            indentAction: vscode21.IndentAction.None,
            removeText: 1
          }
        },
        {
          // e.g.  *-----*/|
          // eslint-disable-next-line no-useless-escape
          beforeText: /^(\t|(\ \ ))*\ \*[^/]*\*\/\s*$/,
          action: {
            indentAction: vscode21.IndentAction.None,
            removeText: 1
          }
        }
      ]
    }
  );
  const packageInfo = context.extension.packageJSON;
  sessionManager = new SessionManager(
    context,
    settings,
    logger,
    documentSelector,
    packageInfo.name,
    packageInfo.displayName,
    packageInfo.version,
    packageInfo.publisher,
    telemetryReporter
  );
  commandRegistrations = [
    new ExamplesFeature(),
    new GenerateBugReportFeature(sessionManager),
    new ISECompatibilityFeature(),
    new OpenInISEFeature(),
    new PesterTestsFeature(sessionManager, logger),
    new CodeActionsFeature(logger),
    new SpecifyScriptArgsFeature(context),
    vscode21.commands.registerCommand(
      "PowerShell.OpenLogFolder",
      async () => {
        await vscode21.commands.executeCommand(
          "vscode.openFolder",
          context.logUri,
          { forceNewWindow: true }
        );
      }
    ),
    vscode21.commands.registerCommand("PowerShell.ShowLogs", () => {
      logger.showLogPanel();
    }),
    vscode21.commands.registerCommand(
      "GetVsCodeSessionId",
      () => vscode21.env.sessionId
    ),
    // Register a command that waits for the Extension Terminal to be active. Can be used by .NET Attach Tasks.
    registerWaitForPsesActivationCommand(context)
  ];
  const externalApi = new ExternalApiFeature(context, sessionManager, logger);
  languageClientConsumers = [
    new ConsoleFeature(logger),
    new ExpandAliasFeature(),
    new GetCommandsFeature(),
    new ShowHelpFeature(),
    new ExtensionCommandsFeature(logger),
    new RemoteFilesFeature(),
    new DebugSessionFeature(context, sessionManager, logger),
    new HelpCompletionFeature()
  ];
  sessionManager.setLanguageClientConsumers(languageClientConsumers);
  if (settings.startAutomatically) {
    await sessionManager.start();
  }
  return {
    registerExternalExtension: (id, apiVersion = "v1") => externalApi.registerExternalExtension(id, apiVersion),
    unregisterExternalExtension: (uuid) => externalApi.unregisterExternalExtension(uuid),
    getPowerShellVersionDetails: (uuid) => externalApi.getPowerShellVersionDetails(uuid),
    waitUntilStarted: (uuid) => externalApi.waitUntilStarted(uuid),
    getStorageUri: () => externalApi.getStorageUri(),
    getLogUri: () => externalApi.getLogUri()
  };
}
function registerWaitForPsesActivationCommand(context) {
  return vscode21.commands.registerCommand(
    "PowerShell.WaitForPsesActivationAndReturnProcessId",
    async () => {
      const pidFileName = `PSES-${vscode21.env.sessionId}.pid`;
      const pidFile = vscode21.Uri.joinPath(
        context.globalStorageUri,
        "sessions",
        pidFileName
      );
      const fs = vscode21.workspace.fs;
      while (true) {
        try {
          const pidContent = await fs.readFile(pidFile);
          const pid = parseInt(pidContent.toString(), 10);
          try {
            const NODE_TEST_PROCESS_EXISTENCE = 0;
            process.kill(pid, NODE_TEST_PROCESS_EXISTENCE);
          } catch {
            await fs.delete(pidFile);
            continue;
          }
          return pidContent.toString();
        } catch {
          await sleep(200);
        }
      }
    }
  );
}
function restartOnExtensionFileChanges(context) {
  const watcher = vscode21.workspace.createFileSystemWatcher(
    new vscode21.RelativePattern(context.extensionPath, "dist/*.js")
  );
  context.subscriptions.push(watcher);
  watcher.onDidChange(({ fsPath }) => {
    vscode21.window.showInformationMessage(
      `${fsPath.split(context.extensionPath, 2)[1]} changed. Reloading Extension Host...`
    );
    vscode21.commands.executeCommand("workbench.action.restartExtensionHost");
  });
}
async function deactivate() {
  for (const commandRegistration of commandRegistrations) {
    commandRegistration.dispose();
  }
  await sessionManager.dispose();
  logger.dispose();
  await telemetryReporter.dispose();
  languageConfigurationDisposable.dispose();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
/*! Bundled license information:

@microsoft/1ds-core-js/dist/es5/ms.core.js:
  (*!
   * 1DS JS SDK Core, 4.3.7
   * Copyright (c) Microsoft and contributors. All rights reserved.
   * (Microsoft Internal Only)
   *)
  (*! https://github.com/nevware21/ts-utils v0.12.3 *)
  (*!
   * NevWare21 Solutions LLC - ts-async, 0.5.4
   * https://github.com/nevware21/ts-async
   * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.
   * Licensed under the MIT license.
   *)

@microsoft/1ds-post-js/dist/es5/ms.post.js:
  (*!
   * 1DS JS SDK POST plugin, 4.3.7
   * Copyright (c) Microsoft and contributors. All rights reserved.
   * (Microsoft Internal Only)
   *)
  (*! https://github.com/nevware21/ts-utils v0.12.3 *)
  (*!
   * NevWare21 Solutions LLC - ts-async, 0.5.4
   * https://github.com/nevware21/ts-async
   * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.
   * Licensed under the MIT license.
   *)

@microsoft/applicationinsights-common/dist/es5/applicationinsights-common.js:
  (*!
   * Application Insights JavaScript SDK - Common, 3.3.7
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)
  (*! https://github.com/nevware21/ts-utils v0.12.3 *)

@microsoft/applicationinsights-web-basic/dist/es5/applicationinsights-web-basic.js:
  (*!
   * Application Insights JavaScript Web SDK - Basic, 3.3.7
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)
  (*! https://github.com/nevware21/ts-utils v0.12.3 *)
  (*!
   * NevWare21 Solutions LLC - ts-async, 0.5.4
   * https://github.com/nevware21/ts-async
   * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.
   * Licensed under the MIT license.
   *)
*/
//# sourceMappingURL=extension.js.map
